{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\n/*!\n * @pixi/graphics - v6.5.10\n * Compiled Thu, 06 Jul 2023 15:25:11 UTC\n *\n * @pixi/graphics is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nimport { Texture, BaseTexture, BatchDrawCall, BatchTextureArray, BatchGeometry, UniformGroup, Shader, State } from '@pixi/core';\nimport { SHAPES, Point, PI_2, Polygon, Rectangle, RoundedRectangle, Circle, Ellipse, Matrix } from '@pixi/math';\nimport { earcut, premultiplyTint, hex2rgb } from '@pixi/utils';\nimport { WRAP_MODES, DRAW_MODES, BLEND_MODES } from '@pixi/constants';\nimport { Bounds, Container } from '@pixi/display';\n\n/**\n * Supported line joints in `PIXI.LineStyle` for graphics.\n * @see PIXI.Graphics#lineStyle\n * @see https://graphicdesign.stackexchange.com/questions/59018/what-is-a-bevel-join-of-two-lines-exactly-illustrator\n * @name LINE_JOIN\n * @memberof PIXI\n * @static\n * @enum {string}\n * @property {string} MITER - 'miter': make a sharp corner where outer part of lines meet\n * @property {string} BEVEL - 'bevel': add a square butt at each end of line segment and fill the triangle at turn\n * @property {string} ROUND - 'round': add an arc at the joint\n */\nvar LINE_JOIN;\n(function (LINE_JOIN) {\n  LINE_JOIN[\"MITER\"] = \"miter\";\n  LINE_JOIN[\"BEVEL\"] = \"bevel\";\n  LINE_JOIN[\"ROUND\"] = \"round\";\n})(LINE_JOIN || (LINE_JOIN = {}));\n/**\n * Support line caps in `PIXI.LineStyle` for graphics.\n * @see PIXI.Graphics#lineStyle\n * @name LINE_CAP\n * @memberof PIXI\n * @static\n * @enum {string}\n * @property {string} BUTT - 'butt': don't add any cap at line ends (leaves orthogonal edges)\n * @property {string} ROUND - 'round': add semicircle at ends\n * @property {string} SQUARE - 'square': add square at end (like `BUTT` except more length at end)\n */\nvar LINE_CAP;\n(function (LINE_CAP) {\n  LINE_CAP[\"BUTT\"] = \"butt\";\n  LINE_CAP[\"ROUND\"] = \"round\";\n  LINE_CAP[\"SQUARE\"] = \"square\";\n})(LINE_CAP || (LINE_CAP = {}));\n/**\n * Graphics curves resolution settings. If `adaptive` flag is set to `true`,\n * the resolution is calculated based on the curve's length to ensure better visual quality.\n * Adaptive draw works with `bezierCurveTo` and `quadraticCurveTo`.\n * @static\n * @constant\n * @memberof PIXI\n * @name GRAPHICS_CURVES\n * @type {object}\n * @property {boolean} [adaptive=true] - flag indicating if the resolution should be adaptive\n * @property {number} [maxLength=10] - maximal length of a single segment of the curve (if adaptive = false, ignored)\n * @property {number} [minSegments=8] - minimal number of segments in the curve (if adaptive = false, ignored)\n * @property {number} [maxSegments=2048] - maximal number of segments in the curve (if adaptive = false, ignored)\n */\nvar GRAPHICS_CURVES = {\n  adaptive: true,\n  maxLength: 10,\n  minSegments: 8,\n  maxSegments: 2048,\n  epsilon: 0.0001,\n  _segmentsCount: function (length, defaultSegments) {\n    if (defaultSegments === void 0) {\n      defaultSegments = 20;\n    }\n    if (!this.adaptive || !length || isNaN(length)) {\n      return defaultSegments;\n    }\n    var result = Math.ceil(length / this.maxLength);\n    if (result < this.minSegments) {\n      result = this.minSegments;\n    } else if (result > this.maxSegments) {\n      result = this.maxSegments;\n    }\n    return result;\n  }\n};\n\n/**\n * Fill style object for Graphics.\n * @memberof PIXI\n */\nvar FillStyle = /** @class */function () {\n  function FillStyle() {\n    /**\n     * The hex color value used when coloring the Graphics object.\n     * @default 0xFFFFFF\n     */\n    this.color = 0xFFFFFF;\n    /** The alpha value used when filling the Graphics object. */\n    this.alpha = 1.0;\n    /**\n     * The texture to be used for the fill.\n     * @default 0\n     */\n    this.texture = Texture.WHITE;\n    /**\n     * The transform applied to the texture.\n     * @default null\n     */\n    this.matrix = null;\n    /** If the current fill is visible. */\n    this.visible = false;\n    this.reset();\n  }\n  /** Clones the object */\n  FillStyle.prototype.clone = function () {\n    var obj = new FillStyle();\n    obj.color = this.color;\n    obj.alpha = this.alpha;\n    obj.texture = this.texture;\n    obj.matrix = this.matrix;\n    obj.visible = this.visible;\n    return obj;\n  };\n  /** Reset */\n  FillStyle.prototype.reset = function () {\n    this.color = 0xFFFFFF;\n    this.alpha = 1;\n    this.texture = Texture.WHITE;\n    this.matrix = null;\n    this.visible = false;\n  };\n  /** Destroy and don't use after this. */\n  FillStyle.prototype.destroy = function () {\n    this.texture = null;\n    this.matrix = null;\n  };\n  return FillStyle;\n}();\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n/* global Reflect, Promise */\n\nvar extendStatics = function (d, b) {\n  extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) {\n      if (b.hasOwnProperty(p)) {\n        d[p] = b[p];\n      }\n    }\n  };\n  return extendStatics(d, b);\n};\nfunction __extends(d, b) {\n  extendStatics(d, b);\n  function __() {\n    this.constructor = d;\n  }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\nfunction fixOrientation(points, hole) {\n  var _a, _b;\n  if (hole === void 0) {\n    hole = false;\n  }\n  var m = points.length;\n  if (m < 6) {\n    return;\n  }\n  var area = 0;\n  for (var i = 0, x1 = points[m - 2], y1 = points[m - 1]; i < m; i += 2) {\n    var x2 = points[i];\n    var y2 = points[i + 1];\n    area += (x2 - x1) * (y2 + y1);\n    x1 = x2;\n    y1 = y2;\n  }\n  if (!hole && area > 0 || hole && area <= 0) {\n    var n = m / 2;\n    for (var i = n + n % 2; i < m; i += 2) {\n      var i1 = m - i - 2;\n      var i2 = m - i - 1;\n      var i3 = i;\n      var i4 = i + 1;\n      _a = [points[i3], points[i1]], points[i1] = _a[0], points[i3] = _a[1];\n      _b = [points[i4], points[i2]], points[i2] = _b[0], points[i4] = _b[1];\n    }\n  }\n}\n/**\n * Builds a polygon to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {object} webGLData - an object containing all the WebGL-specific information to create this shape\n * @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines\n */\nvar buildPoly = {\n  build: function (graphicsData) {\n    graphicsData.points = graphicsData.shape.points.slice();\n  },\n  triangulate: function (graphicsData, graphicsGeometry) {\n    var points = graphicsData.points;\n    var holes = graphicsData.holes;\n    var verts = graphicsGeometry.points;\n    var indices = graphicsGeometry.indices;\n    if (points.length >= 6) {\n      fixOrientation(points, false);\n      var holeArray = [];\n      // Process holes..\n      for (var i = 0; i < holes.length; i++) {\n        var hole = holes[i];\n        fixOrientation(hole.points, true);\n        holeArray.push(points.length / 2);\n        points = points.concat(hole.points);\n      }\n      // sort color\n      var triangles = earcut(points, holeArray, 2);\n      if (!triangles) {\n        return;\n      }\n      var vertPos = verts.length / 2;\n      for (var i = 0; i < triangles.length; i += 3) {\n        indices.push(triangles[i] + vertPos);\n        indices.push(triangles[i + 1] + vertPos);\n        indices.push(triangles[i + 2] + vertPos);\n      }\n      for (var i = 0; i < points.length; i++) {\n        verts.push(points[i]);\n      }\n    }\n  }\n};\n\n// for type only\n/**\n * Builds a circle to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object to draw\n * @param {object} webGLData - an object containing all the WebGL-specific information to create this shape\n * @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines\n */\nvar buildCircle = {\n  build: function (graphicsData) {\n    // need to convert points to a nice regular data\n    var points = graphicsData.points;\n    var x;\n    var y;\n    var dx;\n    var dy;\n    var rx;\n    var ry;\n    if (graphicsData.type === SHAPES.CIRC) {\n      var circle = graphicsData.shape;\n      x = circle.x;\n      y = circle.y;\n      rx = ry = circle.radius;\n      dx = dy = 0;\n    } else if (graphicsData.type === SHAPES.ELIP) {\n      var ellipse = graphicsData.shape;\n      x = ellipse.x;\n      y = ellipse.y;\n      rx = ellipse.width;\n      ry = ellipse.height;\n      dx = dy = 0;\n    } else {\n      var roundedRect = graphicsData.shape;\n      var halfWidth = roundedRect.width / 2;\n      var halfHeight = roundedRect.height / 2;\n      x = roundedRect.x + halfWidth;\n      y = roundedRect.y + halfHeight;\n      rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));\n      dx = halfWidth - rx;\n      dy = halfHeight - ry;\n    }\n    if (!(rx >= 0 && ry >= 0 && dx >= 0 && dy >= 0)) {\n      points.length = 0;\n      return;\n    }\n    // Choose a number of segments such that the maximum absolute deviation from the circle is approximately 0.029\n    var n = Math.ceil(2.3 * Math.sqrt(rx + ry));\n    var m = n * 8 + (dx ? 4 : 0) + (dy ? 4 : 0);\n    points.length = m;\n    if (m === 0) {\n      return;\n    }\n    if (n === 0) {\n      points.length = 8;\n      points[0] = points[6] = x + dx;\n      points[1] = points[3] = y + dy;\n      points[2] = points[4] = x - dx;\n      points[5] = points[7] = y - dy;\n      return;\n    }\n    var j1 = 0;\n    var j2 = n * 4 + (dx ? 2 : 0) + 2;\n    var j3 = j2;\n    var j4 = m;\n    {\n      var x0 = dx + rx;\n      var y0 = dy;\n      var x1 = x + x0;\n      var x2 = x - x0;\n      var y1 = y + y0;\n      points[j1++] = x1;\n      points[j1++] = y1;\n      points[--j2] = y1;\n      points[--j2] = x2;\n      if (dy) {\n        var y2 = y - y0;\n        points[j3++] = x2;\n        points[j3++] = y2;\n        points[--j4] = y2;\n        points[--j4] = x1;\n      }\n    }\n    for (var i = 1; i < n; i++) {\n      var a = Math.PI / 2 * (i / n);\n      var x0 = dx + Math.cos(a) * rx;\n      var y0 = dy + Math.sin(a) * ry;\n      var x1 = x + x0;\n      var x2 = x - x0;\n      var y1 = y + y0;\n      var y2 = y - y0;\n      points[j1++] = x1;\n      points[j1++] = y1;\n      points[--j2] = y1;\n      points[--j2] = x2;\n      points[j3++] = x2;\n      points[j3++] = y2;\n      points[--j4] = y2;\n      points[--j4] = x1;\n    }\n    {\n      var x0 = dx;\n      var y0 = dy + ry;\n      var x1 = x + x0;\n      var x2 = x - x0;\n      var y1 = y + y0;\n      var y2 = y - y0;\n      points[j1++] = x1;\n      points[j1++] = y1;\n      points[--j4] = y2;\n      points[--j4] = x1;\n      if (dx) {\n        points[j1++] = x2;\n        points[j1++] = y1;\n        points[--j4] = y2;\n        points[--j4] = x2;\n      }\n    }\n  },\n  triangulate: function (graphicsData, graphicsGeometry) {\n    var points = graphicsData.points;\n    var verts = graphicsGeometry.points;\n    var indices = graphicsGeometry.indices;\n    if (points.length === 0) {\n      return;\n    }\n    var vertPos = verts.length / 2;\n    var center = vertPos;\n    var x;\n    var y;\n    if (graphicsData.type !== SHAPES.RREC) {\n      var circle = graphicsData.shape;\n      x = circle.x;\n      y = circle.y;\n    } else {\n      var roundedRect = graphicsData.shape;\n      x = roundedRect.x + roundedRect.width / 2;\n      y = roundedRect.y + roundedRect.height / 2;\n    }\n    var matrix = graphicsData.matrix;\n    // Push center (special point)\n    verts.push(graphicsData.matrix ? matrix.a * x + matrix.c * y + matrix.tx : x, graphicsData.matrix ? matrix.b * x + matrix.d * y + matrix.ty : y);\n    vertPos++;\n    verts.push(points[0], points[1]);\n    for (var i = 2; i < points.length; i += 2) {\n      verts.push(points[i], points[i + 1]);\n      // add some uvs\n      indices.push(vertPos++, center, vertPos);\n    }\n    indices.push(center + 1, center, vertPos);\n  }\n};\n\n/**\n * Builds a rectangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {object} webGLData - an object containing all the WebGL-specific information to create this shape\n * @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines\n */\nvar buildRectangle = {\n  build: function (graphicsData) {\n    // --- //\n    // need to convert points to a nice regular data\n    //\n    var rectData = graphicsData.shape;\n    var x = rectData.x;\n    var y = rectData.y;\n    var width = rectData.width;\n    var height = rectData.height;\n    var points = graphicsData.points;\n    points.length = 0;\n    points.push(x, y, x + width, y, x + width, y + height, x, y + height);\n  },\n  triangulate: function (graphicsData, graphicsGeometry) {\n    var points = graphicsData.points;\n    var verts = graphicsGeometry.points;\n    var vertPos = verts.length / 2;\n    verts.push(points[0], points[1], points[2], points[3], points[6], points[7], points[4], points[5]);\n    graphicsGeometry.indices.push(vertPos, vertPos + 1, vertPos + 2, vertPos + 1, vertPos + 2, vertPos + 3);\n  }\n};\n\n/**\n * Calculate a single point for a quadratic bezier curve.\n * Utility function used by quadraticBezierCurve.\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {number} n1 - first number\n * @param {number} n2 - second number\n * @param {number} perc - percentage\n * @returns {number} the result\n */\nfunction getPt(n1, n2, perc) {\n  var diff = n2 - n1;\n  return n1 + diff * perc;\n}\n/**\n * Calculate the points for a quadratic bezier curve. (helper function..)\n * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {number} fromX - Origin point x\n * @param {number} fromY - Origin point x\n * @param {number} cpX - Control point x\n * @param {number} cpY - Control point y\n * @param {number} toX - Destination point x\n * @param {number} toY - Destination point y\n * @param {number[]} [out=[]] - The output array to add points into. If not passed, a new array is created.\n * @returns {number[]} an array of points\n */\nfunction quadraticBezierCurve(fromX, fromY, cpX, cpY, toX, toY, out) {\n  if (out === void 0) {\n    out = [];\n  }\n  var n = 20;\n  var points = out;\n  var xa = 0;\n  var ya = 0;\n  var xb = 0;\n  var yb = 0;\n  var x = 0;\n  var y = 0;\n  for (var i = 0, j = 0; i <= n; ++i) {\n    j = i / n;\n    // The Green Line\n    xa = getPt(fromX, cpX, j);\n    ya = getPt(fromY, cpY, j);\n    xb = getPt(cpX, toX, j);\n    yb = getPt(cpY, toY, j);\n    // The Black Dot\n    x = getPt(xa, xb, j);\n    y = getPt(ya, yb, j);\n    // Handle case when first curve points overlaps and earcut fails to triangulate\n    if (i === 0 && points[points.length - 2] === x && points[points.length - 1] === y) {\n      continue;\n    }\n    points.push(x, y);\n  }\n  return points;\n}\n/**\n * Builds a rounded rectangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {object} webGLData - an object containing all the WebGL-specific information to create this shape\n * @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines\n */\nvar buildRoundedRectangle = {\n  build: function (graphicsData) {\n    if (Graphics.nextRoundedRectBehavior) {\n      buildCircle.build(graphicsData);\n      return;\n    }\n    var rrectData = graphicsData.shape;\n    var points = graphicsData.points;\n    var x = rrectData.x;\n    var y = rrectData.y;\n    var width = rrectData.width;\n    var height = rrectData.height;\n    // Don't allow negative radius or greater than half the smallest width\n    var radius = Math.max(0, Math.min(rrectData.radius, Math.min(width, height) / 2));\n    points.length = 0;\n    // No radius, do a simple rectangle\n    if (!radius) {\n      points.push(x, y, x + width, y, x + width, y + height, x, y + height);\n    } else {\n      quadraticBezierCurve(x, y + radius, x, y, x + radius, y, points);\n      quadraticBezierCurve(x + width - radius, y, x + width, y, x + width, y + radius, points);\n      quadraticBezierCurve(x + width, y + height - radius, x + width, y + height, x + width - radius, y + height, points);\n      quadraticBezierCurve(x + radius, y + height, x, y + height, x, y + height - radius, points);\n    }\n  },\n  triangulate: function (graphicsData, graphicsGeometry) {\n    if (Graphics.nextRoundedRectBehavior) {\n      buildCircle.triangulate(graphicsData, graphicsGeometry);\n      return;\n    }\n    var points = graphicsData.points;\n    var verts = graphicsGeometry.points;\n    var indices = graphicsGeometry.indices;\n    var vecPos = verts.length / 2;\n    var triangles = earcut(points, null, 2);\n    for (var i = 0, j = triangles.length; i < j; i += 3) {\n      indices.push(triangles[i] + vecPos);\n      //     indices.push(triangles[i] + vecPos);\n      indices.push(triangles[i + 1] + vecPos);\n      //   indices.push(triangles[i + 2] + vecPos);\n      indices.push(triangles[i + 2] + vecPos);\n    }\n    for (var i = 0, j = points.length; i < j; i++) {\n      verts.push(points[i], points[++i]);\n    }\n  }\n};\n\n/**\n * Buffers vertices to draw a square cap.\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {number} x - X-coord of end point\n * @param {number} y - Y-coord of end point\n * @param {number} nx - X-coord of line normal pointing inside\n * @param {number} ny - Y-coord of line normal pointing inside\n * @param {number} innerWeight - Weight of inner points\n * @param {number} outerWeight - Weight of outer points\n * @param {boolean} clockwise - Whether the cap is drawn clockwise\n * @param {Array<number>} verts - vertex buffer\n * @returns {number} - no. of vertices pushed\n */\nfunction square(x, y, nx, ny, innerWeight, outerWeight, clockwise, /* rotation for square (true at left end, false at right end) */verts) {\n  var ix = x - nx * innerWeight;\n  var iy = y - ny * innerWeight;\n  var ox = x + nx * outerWeight;\n  var oy = y + ny * outerWeight;\n  /* Rotate nx,ny for extension vector */\n  var exx;\n  var eyy;\n  if (clockwise) {\n    exx = ny;\n    eyy = -nx;\n  } else {\n    exx = -ny;\n    eyy = nx;\n  }\n  /* [i|0]x,y extended at cap */\n  var eix = ix + exx;\n  var eiy = iy + eyy;\n  var eox = ox + exx;\n  var eoy = oy + eyy;\n  /* Square itself must be inserted clockwise*/\n  verts.push(eix, eiy);\n  verts.push(eox, eoy);\n  return 2;\n}\n/**\n * Buffers vertices to draw an arc at the line joint or cap.\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {number} cx - X-coord of center\n * @param {number} cy - Y-coord of center\n * @param {number} sx - X-coord of arc start\n * @param {number} sy - Y-coord of arc start\n * @param {number} ex - X-coord of arc end\n * @param {number} ey - Y-coord of arc end\n * @param {Array<number>} verts - buffer of vertices\n * @param {boolean} clockwise - orientation of vertices\n * @returns {number} - no. of vertices pushed\n */\nfunction round(cx, cy, sx, sy, ex, ey, verts, clockwise) {\n  var cx2p0x = sx - cx;\n  var cy2p0y = sy - cy;\n  var angle0 = Math.atan2(cx2p0x, cy2p0y);\n  var angle1 = Math.atan2(ex - cx, ey - cy);\n  if (clockwise && angle0 < angle1) {\n    angle0 += Math.PI * 2;\n  } else if (!clockwise && angle0 > angle1) {\n    angle1 += Math.PI * 2;\n  }\n  var startAngle = angle0;\n  var angleDiff = angle1 - angle0;\n  var absAngleDiff = Math.abs(angleDiff);\n  /* if (absAngleDiff >= PI_LBOUND && absAngleDiff <= PI_UBOUND)\n  {\n      const r1x = cx - nxtPx;\n      const r1y = cy - nxtPy;\n       if (r1x === 0)\n      {\n          if (r1y > 0)\n          {\n              angleDiff = -angleDiff;\n          }\n      }\n      else if (r1x >= -GRAPHICS_CURVES.epsilon)\n      {\n          angleDiff = -angleDiff;\n      }\n  }*/\n  var radius = Math.sqrt(cx2p0x * cx2p0x + cy2p0y * cy2p0y);\n  var segCount = (15 * absAngleDiff * Math.sqrt(radius) / Math.PI >> 0) + 1;\n  var angleInc = angleDiff / segCount;\n  startAngle += angleInc;\n  if (clockwise) {\n    verts.push(cx, cy);\n    verts.push(sx, sy);\n    for (var i = 1, angle = startAngle; i < segCount; i++, angle += angleInc) {\n      verts.push(cx, cy);\n      verts.push(cx + Math.sin(angle) * radius, cy + Math.cos(angle) * radius);\n    }\n    verts.push(cx, cy);\n    verts.push(ex, ey);\n  } else {\n    verts.push(sx, sy);\n    verts.push(cx, cy);\n    for (var i = 1, angle = startAngle; i < segCount; i++, angle += angleInc) {\n      verts.push(cx + Math.sin(angle) * radius, cy + Math.cos(angle) * radius);\n      verts.push(cx, cy);\n    }\n    verts.push(ex, ey);\n    verts.push(cx, cy);\n  }\n  return segCount * 2;\n}\n/**\n * Builds a line to draw using the polygon method.\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {PIXI.GraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {PIXI.GraphicsGeometry} graphicsGeometry - Geometry where to append output\n */\nfunction buildNonNativeLine(graphicsData, graphicsGeometry) {\n  var shape = graphicsData.shape;\n  var points = graphicsData.points || shape.points.slice();\n  var eps = graphicsGeometry.closePointEps;\n  if (points.length === 0) {\n    return;\n  }\n  // if the line width is an odd number add 0.5 to align to a whole pixel\n  // commenting this out fixes #711 and #1620\n  // if (graphicsData.lineWidth%2)\n  // {\n  //     for (i = 0; i < points.length; i++)\n  //     {\n  //         points[i] += 0.5;\n  //     }\n  // }\n  var style = graphicsData.lineStyle;\n  // get first and last point.. figure out the middle!\n  var firstPoint = new Point(points[0], points[1]);\n  var lastPoint = new Point(points[points.length - 2], points[points.length - 1]);\n  var closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;\n  var closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps && Math.abs(firstPoint.y - lastPoint.y) < eps;\n  // if the first point is the last point - gonna have issues :)\n  if (closedShape) {\n    // need to clone as we are going to slightly modify the shape..\n    points = points.slice();\n    if (closedPath) {\n      points.pop();\n      points.pop();\n      lastPoint.set(points[points.length - 2], points[points.length - 1]);\n    }\n    var midPointX = (firstPoint.x + lastPoint.x) * 0.5;\n    var midPointY = (lastPoint.y + firstPoint.y) * 0.5;\n    points.unshift(midPointX, midPointY);\n    points.push(midPointX, midPointY);\n  }\n  var verts = graphicsGeometry.points;\n  var length = points.length / 2;\n  var indexCount = points.length;\n  var indexStart = verts.length / 2;\n  // Max. inner and outer width\n  var width = style.width / 2;\n  var widthSquared = width * width;\n  var miterLimitSquared = style.miterLimit * style.miterLimit;\n  /* Line segments of interest where (x1,y1) forms the corner. */\n  var x0 = points[0];\n  var y0 = points[1];\n  var x1 = points[2];\n  var y1 = points[3];\n  var x2 = 0;\n  var y2 = 0;\n  /* perp[?](x|y) = the line normal with magnitude lineWidth. */\n  var perpx = -(y0 - y1);\n  var perpy = x0 - x1;\n  var perp1x = 0;\n  var perp1y = 0;\n  var dist = Math.sqrt(perpx * perpx + perpy * perpy);\n  perpx /= dist;\n  perpy /= dist;\n  perpx *= width;\n  perpy *= width;\n  var ratio = style.alignment; // 0.5;\n  var innerWeight = (1 - ratio) * 2;\n  var outerWeight = ratio * 2;\n  if (!closedShape) {\n    if (style.cap === LINE_CAP.ROUND) {\n      indexCount += round(x0 - perpx * (innerWeight - outerWeight) * 0.5, y0 - perpy * (innerWeight - outerWeight) * 0.5, x0 - perpx * innerWeight, y0 - perpy * innerWeight, x0 + perpx * outerWeight, y0 + perpy * outerWeight, verts, true) + 2;\n    } else if (style.cap === LINE_CAP.SQUARE) {\n      indexCount += square(x0, y0, perpx, perpy, innerWeight, outerWeight, true, verts);\n    }\n  }\n  // Push first point (below & above vertices)\n  verts.push(x0 - perpx * innerWeight, y0 - perpy * innerWeight);\n  verts.push(x0 + perpx * outerWeight, y0 + perpy * outerWeight);\n  for (var i = 1; i < length - 1; ++i) {\n    x0 = points[(i - 1) * 2];\n    y0 = points[(i - 1) * 2 + 1];\n    x1 = points[i * 2];\n    y1 = points[i * 2 + 1];\n    x2 = points[(i + 1) * 2];\n    y2 = points[(i + 1) * 2 + 1];\n    perpx = -(y0 - y1);\n    perpy = x0 - x1;\n    dist = Math.sqrt(perpx * perpx + perpy * perpy);\n    perpx /= dist;\n    perpy /= dist;\n    perpx *= width;\n    perpy *= width;\n    perp1x = -(y1 - y2);\n    perp1y = x1 - x2;\n    dist = Math.sqrt(perp1x * perp1x + perp1y * perp1y);\n    perp1x /= dist;\n    perp1y /= dist;\n    perp1x *= width;\n    perp1y *= width;\n    /* d[x|y](0|1) = the component displacement between points p(0,1|1,2) */\n    var dx0 = x1 - x0;\n    var dy0 = y0 - y1;\n    var dx1 = x1 - x2;\n    var dy1 = y2 - y1;\n    /* +ve if internal angle < 90 degree, -ve if internal angle > 90 degree. */\n    var dot = dx0 * dx1 + dy0 * dy1;\n    /* +ve if internal angle counterclockwise, -ve if internal angle clockwise. */\n    var cross = dy0 * dx1 - dy1 * dx0;\n    var clockwise = cross < 0;\n    /* Going nearly parallel? */\n    /* atan(0.001) ~= 0.001 rad ~= 0.057 degree */\n    if (Math.abs(cross) < 0.001 * Math.abs(dot)) {\n      verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);\n      verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);\n      /* 180 degree corner? */\n      if (dot >= 0) {\n        if (style.join === LINE_JOIN.ROUND) {\n          indexCount += round(x1, y1, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 4;\n        } else {\n          indexCount += 2;\n        }\n        verts.push(x1 - perp1x * outerWeight, y1 - perp1y * outerWeight);\n        verts.push(x1 + perp1x * innerWeight, y1 + perp1y * innerWeight);\n      }\n      continue;\n    }\n    /* p[x|y] is the miter point. pdist is the distance between miter point and p1. */\n    var c1 = (-perpx + x0) * (-perpy + y1) - (-perpx + x1) * (-perpy + y0);\n    var c2 = (-perp1x + x2) * (-perp1y + y1) - (-perp1x + x1) * (-perp1y + y2);\n    var px = (dx0 * c2 - dx1 * c1) / cross;\n    var py = (dy1 * c1 - dy0 * c2) / cross;\n    var pdist = (px - x1) * (px - x1) + (py - y1) * (py - y1);\n    /* Inner miter point */\n    var imx = x1 + (px - x1) * innerWeight;\n    var imy = y1 + (py - y1) * innerWeight;\n    /* Outer miter point */\n    var omx = x1 - (px - x1) * outerWeight;\n    var omy = y1 - (py - y1) * outerWeight;\n    /* Is the inside miter point too far away, creating a spike? */\n    var smallerInsideSegmentSq = Math.min(dx0 * dx0 + dy0 * dy0, dx1 * dx1 + dy1 * dy1);\n    var insideWeight = clockwise ? innerWeight : outerWeight;\n    var smallerInsideDiagonalSq = smallerInsideSegmentSq + insideWeight * insideWeight * widthSquared;\n    var insideMiterOk = pdist <= smallerInsideDiagonalSq;\n    if (insideMiterOk) {\n      if (style.join === LINE_JOIN.BEVEL || pdist / widthSquared > miterLimitSquared) {\n        if (clockwise) /* rotating at inner angle */{\n            verts.push(imx, imy); // inner miter point\n            verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight); // first segment's outer vertex\n            verts.push(imx, imy); // inner miter point\n            verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight); // second segment's outer vertex\n          } else /* rotating at outer angle */{\n            verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight); // first segment's inner vertex\n            verts.push(omx, omy); // outer miter point\n            verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight); // second segment's outer vertex\n            verts.push(omx, omy); // outer miter point\n          }\n        indexCount += 2;\n      } else if (style.join === LINE_JOIN.ROUND) {\n        if (clockwise) /* arc is outside */{\n            verts.push(imx, imy);\n            verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);\n            indexCount += round(x1, y1, x1 + perpx * outerWeight, y1 + perpy * outerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight, verts, true) + 4;\n            verts.push(imx, imy);\n            verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);\n          } else /* arc is inside */{\n            verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);\n            verts.push(omx, omy);\n            indexCount += round(x1, y1, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 4;\n            verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);\n            verts.push(omx, omy);\n          }\n      } else {\n        verts.push(imx, imy);\n        verts.push(omx, omy);\n      }\n    } else\n      // inside miter is NOT ok\n      {\n        verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight); // first segment's inner vertex\n        verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight); // first segment's outer vertex\n        if (style.join === LINE_JOIN.ROUND) {\n          if (clockwise) /* arc is outside */{\n              indexCount += round(x1, y1, x1 + perpx * outerWeight, y1 + perpy * outerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight, verts, true) + 2;\n            } else /* arc is inside */{\n              indexCount += round(x1, y1, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 2;\n            }\n        } else if (style.join === LINE_JOIN.MITER && pdist / widthSquared <= miterLimitSquared) {\n          if (clockwise) {\n            verts.push(omx, omy); // inner miter point\n            verts.push(omx, omy); // inner miter point\n          } else {\n            verts.push(imx, imy); // outer miter point\n            verts.push(imx, imy); // outer miter point\n          }\n          indexCount += 2;\n        }\n        verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight); // second segment's inner vertex\n        verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight); // second segment's outer vertex\n        indexCount += 2;\n      }\n  }\n  x0 = points[(length - 2) * 2];\n  y0 = points[(length - 2) * 2 + 1];\n  x1 = points[(length - 1) * 2];\n  y1 = points[(length - 1) * 2 + 1];\n  perpx = -(y0 - y1);\n  perpy = x0 - x1;\n  dist = Math.sqrt(perpx * perpx + perpy * perpy);\n  perpx /= dist;\n  perpy /= dist;\n  perpx *= width;\n  perpy *= width;\n  verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);\n  verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);\n  if (!closedShape) {\n    if (style.cap === LINE_CAP.ROUND) {\n      indexCount += round(x1 - perpx * (innerWeight - outerWeight) * 0.5, y1 - perpy * (innerWeight - outerWeight) * 0.5, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 + perpx * outerWeight, y1 + perpy * outerWeight, verts, false) + 2;\n    } else if (style.cap === LINE_CAP.SQUARE) {\n      indexCount += square(x1, y1, perpx, perpy, innerWeight, outerWeight, false, verts);\n    }\n  }\n  var indices = graphicsGeometry.indices;\n  var eps2 = GRAPHICS_CURVES.epsilon * GRAPHICS_CURVES.epsilon;\n  // indices.push(indexStart);\n  for (var i = indexStart; i < indexCount + indexStart - 2; ++i) {\n    x0 = verts[i * 2];\n    y0 = verts[i * 2 + 1];\n    x1 = verts[(i + 1) * 2];\n    y1 = verts[(i + 1) * 2 + 1];\n    x2 = verts[(i + 2) * 2];\n    y2 = verts[(i + 2) * 2 + 1];\n    /* Skip zero area triangles */\n    if (Math.abs(x0 * (y1 - y2) + x1 * (y2 - y0) + x2 * (y0 - y1)) < eps2) {\n      continue;\n    }\n    indices.push(i, i + 1, i + 2);\n  }\n}\n/**\n * Builds a line to draw using the gl.drawArrays(gl.LINES) method\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {PIXI.GraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {PIXI.GraphicsGeometry} graphicsGeometry - Geometry where to append output\n */\nfunction buildNativeLine(graphicsData, graphicsGeometry) {\n  var i = 0;\n  var shape = graphicsData.shape;\n  var points = graphicsData.points || shape.points;\n  var closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;\n  if (points.length === 0) {\n    return;\n  }\n  var verts = graphicsGeometry.points;\n  var indices = graphicsGeometry.indices;\n  var length = points.length / 2;\n  var startIndex = verts.length / 2;\n  var currentIndex = startIndex;\n  verts.push(points[0], points[1]);\n  for (i = 1; i < length; i++) {\n    verts.push(points[i * 2], points[i * 2 + 1]);\n    indices.push(currentIndex, currentIndex + 1);\n    currentIndex++;\n  }\n  if (closedShape) {\n    indices.push(currentIndex, startIndex);\n  }\n}\n/**\n * Builds a line to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {PIXI.GraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {PIXI.GraphicsGeometry} graphicsGeometry - Geometry where to append output\n */\nfunction buildLine(graphicsData, graphicsGeometry) {\n  if (graphicsData.lineStyle.native) {\n    buildNativeLine(graphicsData, graphicsGeometry);\n  } else {\n    buildNonNativeLine(graphicsData, graphicsGeometry);\n  }\n}\n\n/**\n * Utilities for arc curves.\n * @private\n */\nvar ArcUtils = /** @class */function () {\n  function ArcUtils() {}\n  /**\n   * The arcTo() method creates an arc/curve between two tangents on the canvas.\n   *\n   * \"borrowed\" from https://code.google.com/p/fxcanvas/ - thanks google!\n   * @private\n   * @param x1 - The x-coordinate of the beginning of the arc\n   * @param y1 - The y-coordinate of the beginning of the arc\n   * @param x2 - The x-coordinate of the end of the arc\n   * @param y2 - The y-coordinate of the end of the arc\n   * @param radius - The radius of the arc\n   * @param points -\n   * @returns - If the arc length is valid, return center of circle, radius and other info otherwise `null`.\n   */\n  ArcUtils.curveTo = function (x1, y1, x2, y2, radius, points) {\n    var fromX = points[points.length - 2];\n    var fromY = points[points.length - 1];\n    var a1 = fromY - y1;\n    var b1 = fromX - x1;\n    var a2 = y2 - y1;\n    var b2 = x2 - x1;\n    var mm = Math.abs(a1 * b2 - b1 * a2);\n    if (mm < 1.0e-8 || radius === 0) {\n      if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) {\n        points.push(x1, y1);\n      }\n      return null;\n    }\n    var dd = a1 * a1 + b1 * b1;\n    var cc = a2 * a2 + b2 * b2;\n    var tt = a1 * a2 + b1 * b2;\n    var k1 = radius * Math.sqrt(dd) / mm;\n    var k2 = radius * Math.sqrt(cc) / mm;\n    var j1 = k1 * tt / dd;\n    var j2 = k2 * tt / cc;\n    var cx = k1 * b2 + k2 * b1;\n    var cy = k1 * a2 + k2 * a1;\n    var px = b1 * (k2 + j1);\n    var py = a1 * (k2 + j1);\n    var qx = b2 * (k1 + j2);\n    var qy = a2 * (k1 + j2);\n    var startAngle = Math.atan2(py - cy, px - cx);\n    var endAngle = Math.atan2(qy - cy, qx - cx);\n    return {\n      cx: cx + x1,\n      cy: cy + y1,\n      radius: radius,\n      startAngle: startAngle,\n      endAngle: endAngle,\n      anticlockwise: b1 * a2 > b2 * a1\n    };\n  };\n  /* eslint-disable max-len */\n  /**\n   * The arc method creates an arc/curve (used to create circles, or parts of circles).\n   * @private\n   * @param _startX - Start x location of arc\n   * @param _startY - Start y location of arc\n   * @param cx - The x-coordinate of the center of the circle\n   * @param cy - The y-coordinate of the center of the circle\n   * @param radius - The radius of the circle\n   * @param startAngle - The starting angle, in radians (0 is at the 3 o'clock position\n   *  of the arc's circle)\n   * @param endAngle - The ending angle, in radians\n   * @param _anticlockwise - Specifies whether the drawing should be\n   *  counter-clockwise or clockwise. False is default, and indicates clockwise, while true\n   *  indicates counter-clockwise.\n   * @param points - Collection of points to add to\n   */\n  ArcUtils.arc = function (_startX, _startY, cx, cy, radius, startAngle, endAngle, _anticlockwise, points) {\n    var sweep = endAngle - startAngle;\n    var n = GRAPHICS_CURVES._segmentsCount(Math.abs(sweep) * radius, Math.ceil(Math.abs(sweep) / PI_2) * 40);\n    var theta = sweep / (n * 2);\n    var theta2 = theta * 2;\n    var cTheta = Math.cos(theta);\n    var sTheta = Math.sin(theta);\n    var segMinus = n - 1;\n    var remainder = segMinus % 1 / segMinus;\n    for (var i = 0; i <= segMinus; ++i) {\n      var real = i + remainder * i;\n      var angle = theta + startAngle + theta2 * real;\n      var c = Math.cos(angle);\n      var s = -Math.sin(angle);\n      points.push((cTheta * c + sTheta * s) * radius + cx, (cTheta * -s + sTheta * c) * radius + cy);\n    }\n  };\n  return ArcUtils;\n}();\n\n/**\n * Utilities for bezier curves\n * @private\n */\nvar BezierUtils = /** @class */function () {\n  function BezierUtils() {}\n  /**\n   * Calculate length of bezier curve.\n   * Analytical solution is impossible, since it involves an integral that does not integrate in general.\n   * Therefore numerical solution is used.\n   * @private\n   * @param fromX - Starting point x\n   * @param fromY - Starting point y\n   * @param cpX - Control point x\n   * @param cpY - Control point y\n   * @param cpX2 - Second Control point x\n   * @param cpY2 - Second Control point y\n   * @param toX - Destination point x\n   * @param toY - Destination point y\n   * @returns - Length of bezier curve\n   */\n  BezierUtils.curveLength = function (fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY) {\n    var n = 10;\n    var result = 0.0;\n    var t = 0.0;\n    var t2 = 0.0;\n    var t3 = 0.0;\n    var nt = 0.0;\n    var nt2 = 0.0;\n    var nt3 = 0.0;\n    var x = 0.0;\n    var y = 0.0;\n    var dx = 0.0;\n    var dy = 0.0;\n    var prevX = fromX;\n    var prevY = fromY;\n    for (var i = 1; i <= n; ++i) {\n      t = i / n;\n      t2 = t * t;\n      t3 = t2 * t;\n      nt = 1.0 - t;\n      nt2 = nt * nt;\n      nt3 = nt2 * nt;\n      x = nt3 * fromX + 3.0 * nt2 * t * cpX + 3.0 * nt * t2 * cpX2 + t3 * toX;\n      y = nt3 * fromY + 3.0 * nt2 * t * cpY + 3 * nt * t2 * cpY2 + t3 * toY;\n      dx = prevX - x;\n      dy = prevY - y;\n      prevX = x;\n      prevY = y;\n      result += Math.sqrt(dx * dx + dy * dy);\n    }\n    return result;\n  };\n  /**\n   * Calculate the points for a bezier curve and then draws it.\n   *\n   * Ignored from docs since it is not directly exposed.\n   * @ignore\n   * @param cpX - Control point x\n   * @param cpY - Control point y\n   * @param cpX2 - Second Control point x\n   * @param cpY2 - Second Control point y\n   * @param toX - Destination point x\n   * @param toY - Destination point y\n   * @param points - Path array to push points into\n   */\n  BezierUtils.curveTo = function (cpX, cpY, cpX2, cpY2, toX, toY, points) {\n    var fromX = points[points.length - 2];\n    var fromY = points[points.length - 1];\n    points.length -= 2;\n    var n = GRAPHICS_CURVES._segmentsCount(BezierUtils.curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY));\n    var dt = 0;\n    var dt2 = 0;\n    var dt3 = 0;\n    var t2 = 0;\n    var t3 = 0;\n    points.push(fromX, fromY);\n    for (var i = 1, j = 0; i <= n; ++i) {\n      j = i / n;\n      dt = 1 - j;\n      dt2 = dt * dt;\n      dt3 = dt2 * dt;\n      t2 = j * j;\n      t3 = t2 * j;\n      points.push(dt3 * fromX + 3 * dt2 * j * cpX + 3 * dt * t2 * cpX2 + t3 * toX, dt3 * fromY + 3 * dt2 * j * cpY + 3 * dt * t2 * cpY2 + t3 * toY);\n    }\n  };\n  return BezierUtils;\n}();\n\n/**\n * Utilities for quadratic curves.\n * @private\n */\nvar QuadraticUtils = /** @class */function () {\n  function QuadraticUtils() {}\n  /**\n   * Calculate length of quadratic curve\n   * @see {@link http://www.malczak.linuxpl.com/blog/quadratic-bezier-curve-length/}\n   * for the detailed explanation of math behind this.\n   * @private\n   * @param fromX - x-coordinate of curve start point\n   * @param fromY - y-coordinate of curve start point\n   * @param cpX - x-coordinate of curve control point\n   * @param cpY - y-coordinate of curve control point\n   * @param toX - x-coordinate of curve end point\n   * @param toY - y-coordinate of curve end point\n   * @returns - Length of quadratic curve\n   */\n  QuadraticUtils.curveLength = function (fromX, fromY, cpX, cpY, toX, toY) {\n    var ax = fromX - 2.0 * cpX + toX;\n    var ay = fromY - 2.0 * cpY + toY;\n    var bx = 2.0 * cpX - 2.0 * fromX;\n    var by = 2.0 * cpY - 2.0 * fromY;\n    var a = 4.0 * (ax * ax + ay * ay);\n    var b = 4.0 * (ax * bx + ay * by);\n    var c = bx * bx + by * by;\n    var s = 2.0 * Math.sqrt(a + b + c);\n    var a2 = Math.sqrt(a);\n    var a32 = 2.0 * a * a2;\n    var c2 = 2.0 * Math.sqrt(c);\n    var ba = b / a2;\n    return (a32 * s + a2 * b * (s - c2) + (4.0 * c * a - b * b) * Math.log((2.0 * a2 + ba + s) / (ba + c2))) / (4.0 * a32);\n  };\n  /**\n   * Calculate the points for a quadratic bezier curve and then draws it.\n   * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c\n   * @private\n   * @param cpX - Control point x\n   * @param cpY - Control point y\n   * @param toX - Destination point x\n   * @param toY - Destination point y\n   * @param points - Points to add segments to.\n   */\n  QuadraticUtils.curveTo = function (cpX, cpY, toX, toY, points) {\n    var fromX = points[points.length - 2];\n    var fromY = points[points.length - 1];\n    var n = GRAPHICS_CURVES._segmentsCount(QuadraticUtils.curveLength(fromX, fromY, cpX, cpY, toX, toY));\n    var xa = 0;\n    var ya = 0;\n    for (var i = 1; i <= n; ++i) {\n      var j = i / n;\n      xa = fromX + (cpX - fromX) * j;\n      ya = fromY + (cpY - fromY) * j;\n      points.push(xa + (cpX + (toX - cpX) * j - xa) * j, ya + (cpY + (toY - cpY) * j - ya) * j);\n    }\n  };\n  return QuadraticUtils;\n}();\n\n/**\n * A structure to hold interim batch objects for Graphics.\n * @memberof PIXI.graphicsUtils\n */\nvar BatchPart = /** @class */function () {\n  function BatchPart() {\n    this.reset();\n  }\n  /**\n   * Begin batch part.\n   * @param style\n   * @param startIndex\n   * @param attribStart\n   */\n  BatchPart.prototype.begin = function (style, startIndex, attribStart) {\n    this.reset();\n    this.style = style;\n    this.start = startIndex;\n    this.attribStart = attribStart;\n  };\n  /**\n   * End batch part.\n   * @param endIndex\n   * @param endAttrib\n   */\n  BatchPart.prototype.end = function (endIndex, endAttrib) {\n    this.attribSize = endAttrib - this.attribStart;\n    this.size = endIndex - this.start;\n  };\n  BatchPart.prototype.reset = function () {\n    this.style = null;\n    this.size = 0;\n    this.start = 0;\n    this.attribStart = 0;\n    this.attribSize = 0;\n  };\n  return BatchPart;\n}();\n\n/**\n * Generalized convenience utilities for Graphics.\n * @namespace graphicsUtils\n * @memberof PIXI\n */\nvar _a;\n/**\n * Map of fill commands for each shape type.\n * @memberof PIXI.graphicsUtils\n * @member {object} FILL_COMMANDS\n */\nvar FILL_COMMANDS = (_a = {}, _a[SHAPES.POLY] = buildPoly, _a[SHAPES.CIRC] = buildCircle, _a[SHAPES.ELIP] = buildCircle, _a[SHAPES.RECT] = buildRectangle, _a[SHAPES.RREC] = buildRoundedRectangle, _a);\n/**\n * Batch pool, stores unused batches for preventing allocations.\n * @memberof PIXI.graphicsUtils\n * @member {Array<PIXI.graphicsUtils.BatchPart>} BATCH_POOL\n */\nvar BATCH_POOL = [];\n/**\n * Draw call pool, stores unused draw calls for preventing allocations.\n * @memberof PIXI.graphicsUtils\n * @member {Array<PIXI.BatchDrawCall>} DRAW_CALL_POOL\n */\nvar DRAW_CALL_POOL = [];\n\n/**\n * A class to contain data useful for Graphics objects\n * @memberof PIXI\n */\nvar GraphicsData = /** @class */function () {\n  /**\n   * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.\n   * @param fillStyle - the width of the line to draw\n   * @param lineStyle - the color of the line to draw\n   * @param matrix - Transform matrix\n   */\n  function GraphicsData(shape, fillStyle, lineStyle, matrix) {\n    if (fillStyle === void 0) {\n      fillStyle = null;\n    }\n    if (lineStyle === void 0) {\n      lineStyle = null;\n    }\n    if (matrix === void 0) {\n      matrix = null;\n    }\n    /** The collection of points. */\n    this.points = [];\n    /** The collection of holes. */\n    this.holes = [];\n    this.shape = shape;\n    this.lineStyle = lineStyle;\n    this.fillStyle = fillStyle;\n    this.matrix = matrix;\n    this.type = shape.type;\n  }\n  /**\n   * Creates a new GraphicsData object with the same values as this one.\n   * @returns - Cloned GraphicsData object\n   */\n  GraphicsData.prototype.clone = function () {\n    return new GraphicsData(this.shape, this.fillStyle, this.lineStyle, this.matrix);\n  };\n  /** Destroys the Graphics data. */\n  GraphicsData.prototype.destroy = function () {\n    this.shape = null;\n    this.holes.length = 0;\n    this.holes = null;\n    this.points.length = 0;\n    this.points = null;\n    this.lineStyle = null;\n    this.fillStyle = null;\n  };\n  return GraphicsData;\n}();\nvar tmpPoint = new Point();\n/**\n * The Graphics class contains methods used to draw primitive shapes such as lines, circles and\n * rectangles to the display, and to color and fill them.\n *\n * GraphicsGeometry is designed to not be continually updating the geometry since it's expensive\n * to re-tesselate using **earcut**. Consider using {@link PIXI.Mesh} for this use-case, it's much faster.\n * @memberof PIXI\n */\nvar GraphicsGeometry = /** @class */function (_super) {\n  __extends(GraphicsGeometry, _super);\n  // eslint-disable-next-line @typescript-eslint/no-useless-constructor\n  function GraphicsGeometry() {\n    var _this = _super.call(this) || this;\n    /** Minimal distance between points that are considered different. Affects line tesselation. */\n    _this.closePointEps = 1e-4;\n    /** Padding to add to the bounds. */\n    _this.boundsPadding = 0;\n    _this.uvsFloat32 = null;\n    _this.indicesUint16 = null;\n    _this.batchable = false;\n    /** An array of points to draw, 2 numbers per point */\n    _this.points = [];\n    /** The collection of colors */\n    _this.colors = [];\n    /** The UVs collection */\n    _this.uvs = [];\n    /** The indices of the vertices */\n    _this.indices = [];\n    /** Reference to the texture IDs. */\n    _this.textureIds = [];\n    /**\n     * The collection of drawn shapes.\n     * @member {PIXI.GraphicsData[]}\n     */\n    _this.graphicsData = [];\n    /**\n     * List of current draw calls drived from the batches.\n     * @member {PIXI.BatchDrawCall[]}\n     */\n    _this.drawCalls = [];\n    /** Batches need to regenerated if the geometry is updated. */\n    _this.batchDirty = -1;\n    /**\n     * Intermediate abstract format sent to batch system.\n     * Can be converted to drawCalls or to batchable objects.\n     * @member {PIXI.graphicsUtils.BatchPart[]}\n     */\n    _this.batches = [];\n    /** Used to detect if the graphics object has changed. */\n    _this.dirty = 0;\n    /** Used to check if the cache is dirty. */\n    _this.cacheDirty = -1;\n    /** Used to detect if we cleared the graphicsData. */\n    _this.clearDirty = 0;\n    /** Index of the last batched shape in the stack of calls. */\n    _this.shapeIndex = 0;\n    /** Cached bounds. */\n    _this._bounds = new Bounds();\n    /** The bounds dirty flag. */\n    _this.boundsDirty = -1;\n    return _this;\n  }\n  Object.defineProperty(GraphicsGeometry.prototype, \"bounds\", {\n    /**\n     * Get the current bounds of the graphic geometry.\n     * @readonly\n     */\n    get: function () {\n      this.updateBatches();\n      if (this.boundsDirty !== this.dirty) {\n        this.boundsDirty = this.dirty;\n        this.calculateBounds();\n      }\n      return this._bounds;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /** Call if you changed graphicsData manually. Empties all batch buffers. */\n  GraphicsGeometry.prototype.invalidate = function () {\n    this.boundsDirty = -1;\n    this.dirty++;\n    this.batchDirty++;\n    this.shapeIndex = 0;\n    this.points.length = 0;\n    this.colors.length = 0;\n    this.uvs.length = 0;\n    this.indices.length = 0;\n    this.textureIds.length = 0;\n    for (var i = 0; i < this.drawCalls.length; i++) {\n      this.drawCalls[i].texArray.clear();\n      DRAW_CALL_POOL.push(this.drawCalls[i]);\n    }\n    this.drawCalls.length = 0;\n    for (var i = 0; i < this.batches.length; i++) {\n      var batchPart = this.batches[i];\n      batchPart.reset();\n      BATCH_POOL.push(batchPart);\n    }\n    this.batches.length = 0;\n  };\n  /**\n   * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.\n   * @returns - This GraphicsGeometry object. Good for chaining method calls\n   */\n  GraphicsGeometry.prototype.clear = function () {\n    if (this.graphicsData.length > 0) {\n      this.invalidate();\n      this.clearDirty++;\n      this.graphicsData.length = 0;\n    }\n    return this;\n  };\n  /**\n   * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.\n   * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.\n   * @param fillStyle - Defines style of the fill.\n   * @param lineStyle - Defines style of the lines.\n   * @param matrix - Transform applied to the points of the shape.\n   * @returns - Returns geometry for chaining.\n   */\n  GraphicsGeometry.prototype.drawShape = function (shape, fillStyle, lineStyle, matrix) {\n    if (fillStyle === void 0) {\n      fillStyle = null;\n    }\n    if (lineStyle === void 0) {\n      lineStyle = null;\n    }\n    if (matrix === void 0) {\n      matrix = null;\n    }\n    var data = new GraphicsData(shape, fillStyle, lineStyle, matrix);\n    this.graphicsData.push(data);\n    this.dirty++;\n    return this;\n  };\n  /**\n   * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.\n   * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.\n   * @param matrix - Transform applied to the points of the shape.\n   * @returns - Returns geometry for chaining.\n   */\n  GraphicsGeometry.prototype.drawHole = function (shape, matrix) {\n    if (matrix === void 0) {\n      matrix = null;\n    }\n    if (!this.graphicsData.length) {\n      return null;\n    }\n    var data = new GraphicsData(shape, null, null, matrix);\n    var lastShape = this.graphicsData[this.graphicsData.length - 1];\n    data.lineStyle = lastShape.lineStyle;\n    lastShape.holes.push(data);\n    this.dirty++;\n    return this;\n  };\n  /** Destroys the GraphicsGeometry object. */\n  GraphicsGeometry.prototype.destroy = function () {\n    _super.prototype.destroy.call(this);\n    // destroy each of the GraphicsData objects\n    for (var i = 0; i < this.graphicsData.length; ++i) {\n      this.graphicsData[i].destroy();\n    }\n    this.points.length = 0;\n    this.points = null;\n    this.colors.length = 0;\n    this.colors = null;\n    this.uvs.length = 0;\n    this.uvs = null;\n    this.indices.length = 0;\n    this.indices = null;\n    this.indexBuffer.destroy();\n    this.indexBuffer = null;\n    this.graphicsData.length = 0;\n    this.graphicsData = null;\n    this.drawCalls.length = 0;\n    this.drawCalls = null;\n    this.batches.length = 0;\n    this.batches = null;\n    this._bounds = null;\n  };\n  /**\n   * Check to see if a point is contained within this geometry.\n   * @param point - Point to check if it's contained.\n   * @returns {boolean} `true` if the point is contained within geometry.\n   */\n  GraphicsGeometry.prototype.containsPoint = function (point) {\n    var graphicsData = this.graphicsData;\n    for (var i = 0; i < graphicsData.length; ++i) {\n      var data = graphicsData[i];\n      if (!data.fillStyle.visible) {\n        continue;\n      }\n      // only deal with fills..\n      if (data.shape) {\n        if (data.matrix) {\n          data.matrix.applyInverse(point, tmpPoint);\n        } else {\n          tmpPoint.copyFrom(point);\n        }\n        if (data.shape.contains(tmpPoint.x, tmpPoint.y)) {\n          var hitHole = false;\n          if (data.holes) {\n            for (var i_1 = 0; i_1 < data.holes.length; i_1++) {\n              var hole = data.holes[i_1];\n              if (hole.shape.contains(tmpPoint.x, tmpPoint.y)) {\n                hitHole = true;\n                break;\n              }\n            }\n          }\n          if (!hitHole) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  };\n  /**\n   * Generates intermediate batch data. Either gets converted to drawCalls\n   * or used to convert to batch objects directly by the Graphics object.\n   */\n  GraphicsGeometry.prototype.updateBatches = function () {\n    if (!this.graphicsData.length) {\n      this.batchable = true;\n      return;\n    }\n    if (!this.validateBatching()) {\n      return;\n    }\n    this.cacheDirty = this.dirty;\n    var uvs = this.uvs;\n    var graphicsData = this.graphicsData;\n    var batchPart = null;\n    var currentStyle = null;\n    if (this.batches.length > 0) {\n      batchPart = this.batches[this.batches.length - 1];\n      currentStyle = batchPart.style;\n    }\n    for (var i = this.shapeIndex; i < graphicsData.length; i++) {\n      this.shapeIndex++;\n      var data = graphicsData[i];\n      var fillStyle = data.fillStyle;\n      var lineStyle = data.lineStyle;\n      var command = FILL_COMMANDS[data.type];\n      // build out the shapes points..\n      command.build(data);\n      if (data.matrix) {\n        this.transformPoints(data.points, data.matrix);\n      }\n      if (fillStyle.visible || lineStyle.visible) {\n        this.processHoles(data.holes);\n      }\n      for (var j = 0; j < 2; j++) {\n        var style = j === 0 ? fillStyle : lineStyle;\n        if (!style.visible) {\n          continue;\n        }\n        var nextTexture = style.texture.baseTexture;\n        var index_1 = this.indices.length;\n        var attribIndex = this.points.length / 2;\n        nextTexture.wrapMode = WRAP_MODES.REPEAT;\n        if (j === 0) {\n          this.processFill(data);\n        } else {\n          this.processLine(data);\n        }\n        var size = this.points.length / 2 - attribIndex;\n        if (size === 0) {\n          continue;\n        }\n        // close batch if style is different\n        if (batchPart && !this._compareStyles(currentStyle, style)) {\n          batchPart.end(index_1, attribIndex);\n          batchPart = null;\n        }\n        // spawn new batch if its first batch or previous was closed\n        if (!batchPart) {\n          batchPart = BATCH_POOL.pop() || new BatchPart();\n          batchPart.begin(style, index_1, attribIndex);\n          this.batches.push(batchPart);\n          currentStyle = style;\n        }\n        this.addUvs(this.points, uvs, style.texture, attribIndex, size, style.matrix);\n      }\n    }\n    var index = this.indices.length;\n    var attrib = this.points.length / 2;\n    if (batchPart) {\n      batchPart.end(index, attrib);\n    }\n    if (this.batches.length === 0) {\n      // there are no visible styles in GraphicsData\n      // its possible that someone wants Graphics just for the bounds\n      this.batchable = true;\n      return;\n    }\n    var need32 = attrib > 0xffff;\n    // prevent allocation when length is same as buffer\n    if (this.indicesUint16 && this.indices.length === this.indicesUint16.length && need32 === this.indicesUint16.BYTES_PER_ELEMENT > 2) {\n      this.indicesUint16.set(this.indices);\n    } else {\n      this.indicesUint16 = need32 ? new Uint32Array(this.indices) : new Uint16Array(this.indices);\n    }\n    // TODO make this a const..\n    this.batchable = this.isBatchable();\n    if (this.batchable) {\n      this.packBatches();\n    } else {\n      this.buildDrawCalls();\n    }\n  };\n  /**\n   * Affinity check\n   * @param styleA\n   * @param styleB\n   */\n  GraphicsGeometry.prototype._compareStyles = function (styleA, styleB) {\n    if (!styleA || !styleB) {\n      return false;\n    }\n    if (styleA.texture.baseTexture !== styleB.texture.baseTexture) {\n      return false;\n    }\n    if (styleA.color + styleA.alpha !== styleB.color + styleB.alpha) {\n      return false;\n    }\n    if (!!styleA.native !== !!styleB.native) {\n      return false;\n    }\n    return true;\n  };\n  /** Test geometry for batching process. */\n  GraphicsGeometry.prototype.validateBatching = function () {\n    if (this.dirty === this.cacheDirty || !this.graphicsData.length) {\n      return false;\n    }\n    for (var i = 0, l = this.graphicsData.length; i < l; i++) {\n      var data = this.graphicsData[i];\n      var fill = data.fillStyle;\n      var line = data.lineStyle;\n      if (fill && !fill.texture.baseTexture.valid) {\n        return false;\n      }\n      if (line && !line.texture.baseTexture.valid) {\n        return false;\n      }\n    }\n    return true;\n  };\n  /** Offset the indices so that it works with the batcher. */\n  GraphicsGeometry.prototype.packBatches = function () {\n    this.batchDirty++;\n    this.uvsFloat32 = new Float32Array(this.uvs);\n    var batches = this.batches;\n    for (var i = 0, l = batches.length; i < l; i++) {\n      var batch = batches[i];\n      for (var j = 0; j < batch.size; j++) {\n        var index = batch.start + j;\n        this.indicesUint16[index] = this.indicesUint16[index] - batch.attribStart;\n      }\n    }\n  };\n  /**\n   * Checks to see if this graphics geometry can be batched.\n   * Currently it needs to be small enough and not contain any native lines.\n   */\n  GraphicsGeometry.prototype.isBatchable = function () {\n    // prevent heavy mesh batching\n    if (this.points.length > 0xffff * 2) {\n      return false;\n    }\n    var batches = this.batches;\n    for (var i = 0; i < batches.length; i++) {\n      if (batches[i].style.native) {\n        return false;\n      }\n    }\n    return this.points.length < GraphicsGeometry.BATCHABLE_SIZE * 2;\n  };\n  /** Converts intermediate batches data to drawCalls. */\n  GraphicsGeometry.prototype.buildDrawCalls = function () {\n    var TICK = ++BaseTexture._globalBatch;\n    for (var i = 0; i < this.drawCalls.length; i++) {\n      this.drawCalls[i].texArray.clear();\n      DRAW_CALL_POOL.push(this.drawCalls[i]);\n    }\n    this.drawCalls.length = 0;\n    var colors = this.colors;\n    var textureIds = this.textureIds;\n    var currentGroup = DRAW_CALL_POOL.pop();\n    if (!currentGroup) {\n      currentGroup = new BatchDrawCall();\n      currentGroup.texArray = new BatchTextureArray();\n    }\n    currentGroup.texArray.count = 0;\n    currentGroup.start = 0;\n    currentGroup.size = 0;\n    currentGroup.type = DRAW_MODES.TRIANGLES;\n    var textureCount = 0;\n    var currentTexture = null;\n    var textureId = 0;\n    var native = false;\n    var drawMode = DRAW_MODES.TRIANGLES;\n    var index = 0;\n    this.drawCalls.push(currentGroup);\n    // TODO - this can be simplified\n    for (var i = 0; i < this.batches.length; i++) {\n      var data = this.batches[i];\n      // TODO add some full on MAX_TEXTURE CODE..\n      var MAX_TEXTURES = 8;\n      // Forced cast for checking `native` without errors\n      var style = data.style;\n      var nextTexture = style.texture.baseTexture;\n      if (native !== !!style.native) {\n        native = !!style.native;\n        drawMode = native ? DRAW_MODES.LINES : DRAW_MODES.TRIANGLES;\n        // force the batch to break!\n        currentTexture = null;\n        textureCount = MAX_TEXTURES;\n        TICK++;\n      }\n      if (currentTexture !== nextTexture) {\n        currentTexture = nextTexture;\n        if (nextTexture._batchEnabled !== TICK) {\n          if (textureCount === MAX_TEXTURES) {\n            TICK++;\n            textureCount = 0;\n            if (currentGroup.size > 0) {\n              currentGroup = DRAW_CALL_POOL.pop();\n              if (!currentGroup) {\n                currentGroup = new BatchDrawCall();\n                currentGroup.texArray = new BatchTextureArray();\n              }\n              this.drawCalls.push(currentGroup);\n            }\n            currentGroup.start = index;\n            currentGroup.size = 0;\n            currentGroup.texArray.count = 0;\n            currentGroup.type = drawMode;\n          }\n          // TODO add this to the render part..\n          // Hack! Because texture has protected `touched`\n          nextTexture.touched = 1; // touch;\n          nextTexture._batchEnabled = TICK;\n          nextTexture._batchLocation = textureCount;\n          nextTexture.wrapMode = WRAP_MODES.REPEAT;\n          currentGroup.texArray.elements[currentGroup.texArray.count++] = nextTexture;\n          textureCount++;\n        }\n      }\n      currentGroup.size += data.size;\n      index += data.size;\n      textureId = nextTexture._batchLocation;\n      this.addColors(colors, style.color, style.alpha, data.attribSize, data.attribStart);\n      this.addTextureIds(textureIds, textureId, data.attribSize, data.attribStart);\n    }\n    BaseTexture._globalBatch = TICK;\n    // upload..\n    // merge for now!\n    this.packAttributes();\n  };\n  /** Packs attributes to single buffer. */\n  GraphicsGeometry.prototype.packAttributes = function () {\n    var verts = this.points;\n    var uvs = this.uvs;\n    var colors = this.colors;\n    var textureIds = this.textureIds;\n    // verts are 2 positions.. so we * by 3 as there are 6 properties.. then 4 cos its bytes\n    var glPoints = new ArrayBuffer(verts.length * 3 * 4);\n    var f32 = new Float32Array(glPoints);\n    var u32 = new Uint32Array(glPoints);\n    var p = 0;\n    for (var i = 0; i < verts.length / 2; i++) {\n      f32[p++] = verts[i * 2];\n      f32[p++] = verts[i * 2 + 1];\n      f32[p++] = uvs[i * 2];\n      f32[p++] = uvs[i * 2 + 1];\n      u32[p++] = colors[i];\n      f32[p++] = textureIds[i];\n    }\n    this._buffer.update(glPoints);\n    this._indexBuffer.update(this.indicesUint16);\n  };\n  /**\n   * Process fill part of Graphics.\n   * @param data\n   */\n  GraphicsGeometry.prototype.processFill = function (data) {\n    if (data.holes.length) {\n      buildPoly.triangulate(data, this);\n    } else {\n      var command = FILL_COMMANDS[data.type];\n      command.triangulate(data, this);\n    }\n  };\n  /**\n   * Process line part of Graphics.\n   * @param data\n   */\n  GraphicsGeometry.prototype.processLine = function (data) {\n    buildLine(data, this);\n    for (var i = 0; i < data.holes.length; i++) {\n      buildLine(data.holes[i], this);\n    }\n  };\n  /**\n   * Process the holes data.\n   * @param holes\n   */\n  GraphicsGeometry.prototype.processHoles = function (holes) {\n    for (var i = 0; i < holes.length; i++) {\n      var hole = holes[i];\n      var command = FILL_COMMANDS[hole.type];\n      command.build(hole);\n      if (hole.matrix) {\n        this.transformPoints(hole.points, hole.matrix);\n      }\n    }\n  };\n  /** Update the local bounds of the object. Expensive to use performance-wise. */\n  GraphicsGeometry.prototype.calculateBounds = function () {\n    var bounds = this._bounds;\n    bounds.clear();\n    bounds.addVertexData(this.points, 0, this.points.length);\n    bounds.pad(this.boundsPadding, this.boundsPadding);\n  };\n  /**\n   * Transform points using matrix.\n   * @param points - Points to transform\n   * @param matrix - Transform matrix\n   */\n  GraphicsGeometry.prototype.transformPoints = function (points, matrix) {\n    for (var i = 0; i < points.length / 2; i++) {\n      var x = points[i * 2];\n      var y = points[i * 2 + 1];\n      points[i * 2] = matrix.a * x + matrix.c * y + matrix.tx;\n      points[i * 2 + 1] = matrix.b * x + matrix.d * y + matrix.ty;\n    }\n  };\n  /**\n   * Add colors.\n   * @param colors - List of colors to add to\n   * @param color - Color to add\n   * @param alpha - Alpha to use\n   * @param size - Number of colors to add\n   * @param offset\n   */\n  GraphicsGeometry.prototype.addColors = function (colors, color, alpha, size, offset) {\n    if (offset === void 0) {\n      offset = 0;\n    }\n    // TODO use the premultiply bits Ivan added\n    var rgb = (color >> 16) + (color & 0xff00) + ((color & 0xff) << 16);\n    var rgba = premultiplyTint(rgb, alpha);\n    colors.length = Math.max(colors.length, offset + size);\n    for (var i = 0; i < size; i++) {\n      colors[offset + i] = rgba;\n    }\n  };\n  /**\n   * Add texture id that the shader/fragment wants to use.\n   * @param textureIds\n   * @param id\n   * @param size\n   * @param offset\n   */\n  GraphicsGeometry.prototype.addTextureIds = function (textureIds, id, size, offset) {\n    if (offset === void 0) {\n      offset = 0;\n    }\n    textureIds.length = Math.max(textureIds.length, offset + size);\n    for (var i = 0; i < size; i++) {\n      textureIds[offset + i] = id;\n    }\n  };\n  /**\n   * Generates the UVs for a shape.\n   * @param verts - Vertices\n   * @param uvs - UVs\n   * @param texture - Reference to Texture\n   * @param start - Index buffer start index.\n   * @param size - The size/length for index buffer.\n   * @param matrix - Optional transform for all points.\n   */\n  GraphicsGeometry.prototype.addUvs = function (verts, uvs, texture, start, size, matrix) {\n    if (matrix === void 0) {\n      matrix = null;\n    }\n    var index = 0;\n    var uvsStart = uvs.length;\n    var frame = texture.frame;\n    while (index < size) {\n      var x = verts[(start + index) * 2];\n      var y = verts[(start + index) * 2 + 1];\n      if (matrix) {\n        var nx = matrix.a * x + matrix.c * y + matrix.tx;\n        y = matrix.b * x + matrix.d * y + matrix.ty;\n        x = nx;\n      }\n      index++;\n      uvs.push(x / frame.width, y / frame.height);\n    }\n    var baseTexture = texture.baseTexture;\n    if (frame.width < baseTexture.width || frame.height < baseTexture.height) {\n      this.adjustUvs(uvs, texture, uvsStart, size);\n    }\n  };\n  /**\n   * Modify uvs array according to position of texture region\n   * Does not work with rotated or trimmed textures\n   * @param uvs - array\n   * @param texture - region\n   * @param start - starting index for uvs\n   * @param size - how many points to adjust\n   */\n  GraphicsGeometry.prototype.adjustUvs = function (uvs, texture, start, size) {\n    var baseTexture = texture.baseTexture;\n    var eps = 1e-6;\n    var finish = start + size * 2;\n    var frame = texture.frame;\n    var scaleX = frame.width / baseTexture.width;\n    var scaleY = frame.height / baseTexture.height;\n    var offsetX = frame.x / frame.width;\n    var offsetY = frame.y / frame.height;\n    var minX = Math.floor(uvs[start] + eps);\n    var minY = Math.floor(uvs[start + 1] + eps);\n    for (var i = start + 2; i < finish; i += 2) {\n      minX = Math.min(minX, Math.floor(uvs[i] + eps));\n      minY = Math.min(minY, Math.floor(uvs[i + 1] + eps));\n    }\n    offsetX -= minX;\n    offsetY -= minY;\n    for (var i = start; i < finish; i += 2) {\n      uvs[i] = (uvs[i] + offsetX) * scaleX;\n      uvs[i + 1] = (uvs[i + 1] + offsetY) * scaleY;\n    }\n  };\n  /**\n   * The maximum number of points to consider an object \"batchable\",\n   * able to be batched by the renderer's batch system.\n  \\\n   */\n  GraphicsGeometry.BATCHABLE_SIZE = 100;\n  return GraphicsGeometry;\n}(BatchGeometry);\n\n/**\n * Represents the line style for Graphics.\n * @memberof PIXI\n */\nvar LineStyle = /** @class */function (_super) {\n  __extends(LineStyle, _super);\n  function LineStyle() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /** The width (thickness) of any lines drawn. */\n    _this.width = 0;\n    /** The alignment of any lines drawn (0.5 = middle, 1 = outer, 0 = inner). WebGL only. */\n    _this.alignment = 0.5;\n    /** If true the lines will be draw using LINES instead of TRIANGLE_STRIP. */\n    _this.native = false;\n    /**\n     * Line cap style.\n     * @member {PIXI.LINE_CAP}\n     * @default PIXI.LINE_CAP.BUTT\n     */\n    _this.cap = LINE_CAP.BUTT;\n    /**\n     * Line join style.\n     * @member {PIXI.LINE_JOIN}\n     * @default PIXI.LINE_JOIN.MITER\n     */\n    _this.join = LINE_JOIN.MITER;\n    /** Miter limit. */\n    _this.miterLimit = 10;\n    return _this;\n  }\n  /** Clones the object. */\n  LineStyle.prototype.clone = function () {\n    var obj = new LineStyle();\n    obj.color = this.color;\n    obj.alpha = this.alpha;\n    obj.texture = this.texture;\n    obj.matrix = this.matrix;\n    obj.visible = this.visible;\n    obj.width = this.width;\n    obj.alignment = this.alignment;\n    obj.native = this.native;\n    obj.cap = this.cap;\n    obj.join = this.join;\n    obj.miterLimit = this.miterLimit;\n    return obj;\n  };\n  /** Reset the line style to default. */\n  LineStyle.prototype.reset = function () {\n    _super.prototype.reset.call(this);\n    // Override default line style color\n    this.color = 0x0;\n    this.alignment = 0.5;\n    this.width = 0;\n    this.native = false;\n  };\n  return LineStyle;\n}(FillStyle);\nvar temp = new Float32Array(3);\n// a default shaders map used by graphics..\nvar DEFAULT_SHADERS = {};\n/**\n * The Graphics class is primarily used to render primitive shapes such as lines, circles and\n * rectangles to the display, and to color and fill them.  However, you can also use a Graphics\n * object to build a list of primitives to use as a mask, or as a complex hitArea.\n *\n * Please note that due to legacy naming conventions, the behavior of some functions in this class\n * can be confusing.  Each call to `drawRect()`, `drawPolygon()`, etc. actually stores that primitive\n * in the Geometry class's GraphicsGeometry object for later use in rendering or hit testing - the\n * functions do not directly draw anything to the screen.  Similarly, the `clear()` function doesn't\n * change the screen, it simply resets the list of primitives, which can be useful if you want to\n * rebuild the contents of an existing Graphics object.\n *\n * Once a GraphicsGeometry list is built, you can re-use it in other Geometry objects as\n * an optimization, by passing it into a new Geometry object's constructor.  Because of this\n * ability, it's important to call `destroy()` on Geometry objects once you are done with them, to\n * properly dereference each GraphicsGeometry and prevent memory leaks.\n * @memberof PIXI\n */\nvar Graphics = /** @class */function (_super) {\n  __extends(Graphics, _super);\n  /**\n   * @param geometry - Geometry to use, if omitted will create a new GraphicsGeometry instance.\n   */\n  function Graphics(geometry) {\n    if (geometry === void 0) {\n      geometry = null;\n    }\n    var _this = _super.call(this) || this;\n    /**\n     * Represents the vertex and fragment shaders that processes the geometry and runs on the GPU.\n     * Can be shared between multiple Graphics objects.\n     */\n    _this.shader = null;\n    /** Renderer plugin for batching */\n    _this.pluginName = 'batch';\n    /**\n     * Current path\n     * @readonly\n     */\n    _this.currentPath = null;\n    /** A collections of batches! These can be drawn by the renderer batch system. */\n    _this.batches = [];\n    /** Update dirty for limiting calculating tints for batches. */\n    _this.batchTint = -1;\n    /** Update dirty for limiting calculating batches.*/\n    _this.batchDirty = -1;\n    /** Copy of the object vertex data. */\n    _this.vertexData = null;\n    /** Current fill style. */\n    _this._fillStyle = new FillStyle();\n    /** Current line style. */\n    _this._lineStyle = new LineStyle();\n    /** Current shape transform matrix. */\n    _this._matrix = null;\n    /** Current hole mode is enabled. */\n    _this._holeMode = false;\n    /**\n     * Represents the WebGL state the Graphics required to render, excludes shader and geometry. E.g.,\n     * blend mode, culling, depth testing, direction of rendering triangles, backface, etc.\n     */\n    _this.state = State.for2d();\n    _this._geometry = geometry || new GraphicsGeometry();\n    _this._geometry.refCount++;\n    /**\n     * When cacheAsBitmap is set to true the graphics object will be rendered as if it was a sprite.\n     * This is useful if your graphics element does not change often, as it will speed up the rendering\n     * of the object in exchange for taking up texture memory. It is also useful if you need the graphics\n     * object to be anti-aliased, because it will be rendered using canvas. This is not recommended if\n     * you are constantly redrawing the graphics element.\n     * @name cacheAsBitmap\n     * @member {boolean}\n     * @memberof PIXI.Graphics#\n     * @default false\n     */\n    _this._transformID = -1;\n    // Set default\n    _this.tint = 0xFFFFFF;\n    _this.blendMode = BLEND_MODES.NORMAL;\n    return _this;\n  }\n  Object.defineProperty(Graphics.prototype, \"geometry\", {\n    /**\n     * Includes vertex positions, face indices, normals, colors, UVs, and\n     * custom attributes within buffers, reducing the cost of passing all\n     * this data to the GPU. Can be shared between multiple Mesh or Graphics objects.\n     * @readonly\n     */\n    get: function () {\n      return this._geometry;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Creates a new Graphics object with the same values as this one.\n   * Note that only the geometry of the object is cloned, not its transform (position,scale,etc)\n   * @returns - A clone of the graphics object\n   */\n  Graphics.prototype.clone = function () {\n    this.finishPoly();\n    return new Graphics(this._geometry);\n  };\n  Object.defineProperty(Graphics.prototype, \"blendMode\", {\n    get: function () {\n      return this.state.blendMode;\n    },\n    /**\n     * The blend mode to be applied to the graphic shape. Apply a value of\n     * `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.  Note that, since each\n     * primitive in the GraphicsGeometry list is rendered sequentially, modes\n     * such as `PIXI.BLEND_MODES.ADD` and `PIXI.BLEND_MODES.MULTIPLY` will\n     * be applied per-primitive.\n     * @default PIXI.BLEND_MODES.NORMAL\n     */\n    set: function (value) {\n      this.state.blendMode = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Graphics.prototype, \"tint\", {\n    /**\n     * The tint applied to each graphic shape. This is a hex value. A value of\n     * 0xFFFFFF will remove any tint effect.\n     * @default 0xFFFFFF\n     */\n    get: function () {\n      return this._tint;\n    },\n    set: function (value) {\n      this._tint = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Graphics.prototype, \"fill\", {\n    /**\n     * The current fill style.\n     * @readonly\n     */\n    get: function () {\n      return this._fillStyle;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Graphics.prototype, \"line\", {\n    /**\n     * The current line style.\n     * @readonly\n     */\n    get: function () {\n      return this._lineStyle;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Graphics.prototype.lineStyle = function (options, color, alpha, alignment, native) {\n    if (options === void 0) {\n      options = null;\n    }\n    if (color === void 0) {\n      color = 0x0;\n    }\n    if (alpha === void 0) {\n      alpha = 1;\n    }\n    if (alignment === void 0) {\n      alignment = 0.5;\n    }\n    if (native === void 0) {\n      native = false;\n    }\n    // Support non-object params: (width, color, alpha, alignment, native)\n    if (typeof options === 'number') {\n      options = {\n        width: options,\n        color: color,\n        alpha: alpha,\n        alignment: alignment,\n        native: native\n      };\n    }\n    return this.lineTextureStyle(options);\n  };\n  /**\n   * Like line style but support texture for line fill.\n   * @param [options] - Collection of options for setting line style.\n   * @param {number} [options.width=0] - width of the line to draw, will update the objects stored style\n   * @param {PIXI.Texture} [options.texture=PIXI.Texture.WHITE] - Texture to use\n   * @param {number} [options.color=0x0] - color of the line to draw, will update the objects stored style.\n   *  Default 0xFFFFFF if texture present.\n   * @param {number} [options.alpha=1] - alpha of the line to draw, will update the objects stored style\n   * @param {PIXI.Matrix} [options.matrix=null] - Texture matrix to transform texture\n   * @param {number} [options.alignment=0.5] - alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outer).\n   *        WebGL only.\n   * @param {boolean} [options.native=false] - If true the lines will be draw using LINES instead of TRIANGLE_STRIP\n   * @param {PIXI.LINE_CAP}[options.cap=PIXI.LINE_CAP.BUTT] - line cap style\n   * @param {PIXI.LINE_JOIN}[options.join=PIXI.LINE_JOIN.MITER] - line join style\n   * @param {number}[options.miterLimit=10] - miter limit ratio\n   * @returns {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n  Graphics.prototype.lineTextureStyle = function (options) {\n    // Apply defaults\n    options = Object.assign({\n      width: 0,\n      texture: Texture.WHITE,\n      color: options && options.texture ? 0xFFFFFF : 0x0,\n      alpha: 1,\n      matrix: null,\n      alignment: 0.5,\n      native: false,\n      cap: LINE_CAP.BUTT,\n      join: LINE_JOIN.MITER,\n      miterLimit: 10\n    }, options);\n    if (this.currentPath) {\n      this.startPoly();\n    }\n    var visible = options.width > 0 && options.alpha > 0;\n    if (!visible) {\n      this._lineStyle.reset();\n    } else {\n      if (options.matrix) {\n        options.matrix = options.matrix.clone();\n        options.matrix.invert();\n      }\n      Object.assign(this._lineStyle, {\n        visible: visible\n      }, options);\n    }\n    return this;\n  };\n  /**\n   * Start a polygon object internally.\n   * @protected\n   */\n  Graphics.prototype.startPoly = function () {\n    if (this.currentPath) {\n      var points = this.currentPath.points;\n      var len = this.currentPath.points.length;\n      if (len > 2) {\n        this.drawShape(this.currentPath);\n        this.currentPath = new Polygon();\n        this.currentPath.closeStroke = false;\n        this.currentPath.points.push(points[len - 2], points[len - 1]);\n      }\n    } else {\n      this.currentPath = new Polygon();\n      this.currentPath.closeStroke = false;\n    }\n  };\n  /**\n   * Finish the polygon object.\n   * @protected\n   */\n  Graphics.prototype.finishPoly = function () {\n    if (this.currentPath) {\n      if (this.currentPath.points.length > 2) {\n        this.drawShape(this.currentPath);\n        this.currentPath = null;\n      } else {\n        this.currentPath.points.length = 0;\n      }\n    }\n  };\n  /**\n   * Moves the current drawing position to x, y.\n   * @param x - the X coordinate to move to\n   * @param y - the Y coordinate to move to\n   * @returns - This Graphics object. Good for chaining method calls\n   */\n  Graphics.prototype.moveTo = function (x, y) {\n    this.startPoly();\n    this.currentPath.points[0] = x;\n    this.currentPath.points[1] = y;\n    return this;\n  };\n  /**\n   * Draws a line using the current line style from the current drawing position to (x, y);\n   * The current drawing position is then set to (x, y).\n   * @param x - the X coordinate to draw to\n   * @param y - the Y coordinate to draw to\n   * @returns - This Graphics object. Good for chaining method calls\n   */\n  Graphics.prototype.lineTo = function (x, y) {\n    if (!this.currentPath) {\n      this.moveTo(0, 0);\n    }\n    // remove duplicates..\n    var points = this.currentPath.points;\n    var fromX = points[points.length - 2];\n    var fromY = points[points.length - 1];\n    if (fromX !== x || fromY !== y) {\n      points.push(x, y);\n    }\n    return this;\n  };\n  /**\n   * Initialize the curve\n   * @param x\n   * @param y\n   */\n  Graphics.prototype._initCurve = function (x, y) {\n    if (x === void 0) {\n      x = 0;\n    }\n    if (y === void 0) {\n      y = 0;\n    }\n    if (this.currentPath) {\n      if (this.currentPath.points.length === 0) {\n        this.currentPath.points = [x, y];\n      }\n    } else {\n      this.moveTo(x, y);\n    }\n  };\n  /**\n   * Calculate the points for a quadratic bezier curve and then draws it.\n   * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c\n   * @param cpX - Control point x\n   * @param cpY - Control point y\n   * @param toX - Destination point x\n   * @param toY - Destination point y\n   * @returns - This Graphics object. Good for chaining method calls\n   */\n  Graphics.prototype.quadraticCurveTo = function (cpX, cpY, toX, toY) {\n    this._initCurve();\n    var points = this.currentPath.points;\n    if (points.length === 0) {\n      this.moveTo(0, 0);\n    }\n    QuadraticUtils.curveTo(cpX, cpY, toX, toY, points);\n    return this;\n  };\n  /**\n   * Calculate the points for a bezier curve and then draws it.\n   * @param cpX - Control point x\n   * @param cpY - Control point y\n   * @param cpX2 - Second Control point x\n   * @param cpY2 - Second Control point y\n   * @param toX - Destination point x\n   * @param toY - Destination point y\n   * @returns This Graphics object. Good for chaining method calls\n   */\n  Graphics.prototype.bezierCurveTo = function (cpX, cpY, cpX2, cpY2, toX, toY) {\n    this._initCurve();\n    BezierUtils.curveTo(cpX, cpY, cpX2, cpY2, toX, toY, this.currentPath.points);\n    return this;\n  };\n  /**\n   * The arcTo() method creates an arc/curve between two tangents on the canvas.\n   *\n   * \"borrowed\" from https://code.google.com/p/fxcanvas/ - thanks google!\n   * @param x1 - The x-coordinate of the first tangent point of the arc\n   * @param y1 - The y-coordinate of the first tangent point of the arc\n   * @param x2 - The x-coordinate of the end of the arc\n   * @param y2 - The y-coordinate of the end of the arc\n   * @param radius - The radius of the arc\n   * @returns - This Graphics object. Good for chaining method calls\n   */\n  Graphics.prototype.arcTo = function (x1, y1, x2, y2, radius) {\n    this._initCurve(x1, y1);\n    var points = this.currentPath.points;\n    var result = ArcUtils.curveTo(x1, y1, x2, y2, radius, points);\n    if (result) {\n      var cx = result.cx,\n        cy = result.cy,\n        radius_1 = result.radius,\n        startAngle = result.startAngle,\n        endAngle = result.endAngle,\n        anticlockwise = result.anticlockwise;\n      this.arc(cx, cy, radius_1, startAngle, endAngle, anticlockwise);\n    }\n    return this;\n  };\n  /**\n   * The arc method creates an arc/curve (used to create circles, or parts of circles).\n   * @param cx - The x-coordinate of the center of the circle\n   * @param cy - The y-coordinate of the center of the circle\n   * @param radius - The radius of the circle\n   * @param startAngle - The starting angle, in radians (0 is at the 3 o'clock position\n   *  of the arc's circle)\n   * @param endAngle - The ending angle, in radians\n   * @param anticlockwise - Specifies whether the drawing should be\n   *  counter-clockwise or clockwise. False is default, and indicates clockwise, while true\n   *  indicates counter-clockwise.\n   * @returns - This Graphics object. Good for chaining method calls\n   */\n  Graphics.prototype.arc = function (cx, cy, radius, startAngle, endAngle, anticlockwise) {\n    if (anticlockwise === void 0) {\n      anticlockwise = false;\n    }\n    if (startAngle === endAngle) {\n      return this;\n    }\n    if (!anticlockwise && endAngle <= startAngle) {\n      endAngle += PI_2;\n    } else if (anticlockwise && startAngle <= endAngle) {\n      startAngle += PI_2;\n    }\n    var sweep = endAngle - startAngle;\n    if (sweep === 0) {\n      return this;\n    }\n    var startX = cx + Math.cos(startAngle) * radius;\n    var startY = cy + Math.sin(startAngle) * radius;\n    var eps = this._geometry.closePointEps;\n    // If the currentPath exists, take its points. Otherwise call `moveTo` to start a path.\n    var points = this.currentPath ? this.currentPath.points : null;\n    if (points) {\n      // TODO: make a better fix.\n      // We check how far our start is from the last existing point\n      var xDiff = Math.abs(points[points.length - 2] - startX);\n      var yDiff = Math.abs(points[points.length - 1] - startY);\n      if (xDiff < eps && yDiff < eps) ;else {\n        points.push(startX, startY);\n      }\n    } else {\n      this.moveTo(startX, startY);\n      points = this.currentPath.points;\n    }\n    ArcUtils.arc(startX, startY, cx, cy, radius, startAngle, endAngle, anticlockwise, points);\n    return this;\n  };\n  /**\n   * Specifies a simple one-color fill that subsequent calls to other Graphics methods\n   * (such as lineTo() or drawCircle()) use when drawing.\n   * @param color - the color of the fill\n   * @param alpha - the alpha of the fill\n   * @returns - This Graphics object. Good for chaining method calls\n   */\n  Graphics.prototype.beginFill = function (color, alpha) {\n    if (color === void 0) {\n      color = 0;\n    }\n    if (alpha === void 0) {\n      alpha = 1;\n    }\n    return this.beginTextureFill({\n      texture: Texture.WHITE,\n      color: color,\n      alpha: alpha\n    });\n  };\n  /**\n   * Begin the texture fill\n   * @param options - Object object.\n   * @param {PIXI.Texture} [options.texture=PIXI.Texture.WHITE] - Texture to fill\n   * @param {number} [options.color=0xffffff] - Background to fill behind texture\n   * @param {number} [options.alpha=1] - Alpha of fill\n   * @param {PIXI.Matrix} [options.matrix=null] - Transform matrix\n   * @returns {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n  Graphics.prototype.beginTextureFill = function (options) {\n    // Apply defaults\n    options = Object.assign({\n      texture: Texture.WHITE,\n      color: 0xFFFFFF,\n      alpha: 1,\n      matrix: null\n    }, options);\n    if (this.currentPath) {\n      this.startPoly();\n    }\n    var visible = options.alpha > 0;\n    if (!visible) {\n      this._fillStyle.reset();\n    } else {\n      if (options.matrix) {\n        options.matrix = options.matrix.clone();\n        options.matrix.invert();\n      }\n      Object.assign(this._fillStyle, {\n        visible: visible\n      }, options);\n    }\n    return this;\n  };\n  /**\n   * Applies a fill to the lines and shapes that were added since the last call to the beginFill() method.\n   * @returns - This Graphics object. Good for chaining method calls\n   */\n  Graphics.prototype.endFill = function () {\n    this.finishPoly();\n    this._fillStyle.reset();\n    return this;\n  };\n  /**\n   * Draws a rectangle shape.\n   * @param x - The X coord of the top-left of the rectangle\n   * @param y - The Y coord of the top-left of the rectangle\n   * @param width - The width of the rectangle\n   * @param height - The height of the rectangle\n   * @returns - This Graphics object. Good for chaining method calls\n   */\n  Graphics.prototype.drawRect = function (x, y, width, height) {\n    return this.drawShape(new Rectangle(x, y, width, height));\n  };\n  /**\n   * Draw a rectangle shape with rounded/beveled corners.\n   * @param x - The X coord of the top-left of the rectangle\n   * @param y - The Y coord of the top-left of the rectangle\n   * @param width - The width of the rectangle\n   * @param height - The height of the rectangle\n   * @param radius - Radius of the rectangle corners\n   * @returns - This Graphics object. Good for chaining method calls\n   */\n  Graphics.prototype.drawRoundedRect = function (x, y, width, height, radius) {\n    return this.drawShape(new RoundedRectangle(x, y, width, height, radius));\n  };\n  /**\n   * Draws a circle.\n   * @param x - The X coordinate of the center of the circle\n   * @param y - The Y coordinate of the center of the circle\n   * @param radius - The radius of the circle\n   * @returns - This Graphics object. Good for chaining method calls\n   */\n  Graphics.prototype.drawCircle = function (x, y, radius) {\n    return this.drawShape(new Circle(x, y, radius));\n  };\n  /**\n   * Draws an ellipse.\n   * @param x - The X coordinate of the center of the ellipse\n   * @param y - The Y coordinate of the center of the ellipse\n   * @param width - The half width of the ellipse\n   * @param height - The half height of the ellipse\n   * @returns - This Graphics object. Good for chaining method calls\n   */\n  Graphics.prototype.drawEllipse = function (x, y, width, height) {\n    return this.drawShape(new Ellipse(x, y, width, height));\n  };\n  /**\n   * Draws a polygon using the given path.\n   * @param {number[]|PIXI.IPointData[]|PIXI.Polygon} path - The path data used to construct the polygon.\n   * @returns - This Graphics object. Good for chaining method calls\n   */\n  Graphics.prototype.drawPolygon = function () {\n    var arguments$1 = arguments;\n    var path = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      path[_i] = arguments$1[_i];\n    }\n    var points;\n    var closeStroke = true; // !!this._fillStyle;\n    var poly = path[0];\n    // check if data has points..\n    if (poly.points) {\n      closeStroke = poly.closeStroke;\n      points = poly.points;\n    } else if (Array.isArray(path[0])) {\n      points = path[0];\n    } else {\n      points = path;\n    }\n    var shape = new Polygon(points);\n    shape.closeStroke = closeStroke;\n    this.drawShape(shape);\n    return this;\n  };\n  /**\n   * Draw any shape.\n   * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - Shape to draw\n   * @returns - This Graphics object. Good for chaining method calls\n   */\n  Graphics.prototype.drawShape = function (shape) {\n    if (!this._holeMode) {\n      this._geometry.drawShape(shape, this._fillStyle.clone(), this._lineStyle.clone(), this._matrix);\n    } else {\n      this._geometry.drawHole(shape, this._matrix);\n    }\n    return this;\n  };\n  /**\n   * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.\n   * @returns - This Graphics object. Good for chaining method calls\n   */\n  Graphics.prototype.clear = function () {\n    this._geometry.clear();\n    this._lineStyle.reset();\n    this._fillStyle.reset();\n    this._boundsID++;\n    this._matrix = null;\n    this._holeMode = false;\n    this.currentPath = null;\n    return this;\n  };\n  /**\n   * True if graphics consists of one rectangle, and thus, can be drawn like a Sprite and\n   * masked with gl.scissor.\n   * @returns - True if only 1 rect.\n   */\n  Graphics.prototype.isFastRect = function () {\n    var data = this._geometry.graphicsData;\n    return data.length === 1 && data[0].shape.type === SHAPES.RECT && !data[0].matrix && !data[0].holes.length && !(data[0].lineStyle.visible && data[0].lineStyle.width);\n  };\n  /**\n   * Renders the object using the WebGL renderer\n   * @param renderer - The renderer\n   */\n  Graphics.prototype._render = function (renderer) {\n    this.finishPoly();\n    var geometry = this._geometry;\n    // batch part..\n    // batch it!\n    geometry.updateBatches();\n    if (geometry.batchable) {\n      if (this.batchDirty !== geometry.batchDirty) {\n        this._populateBatches();\n      }\n      this._renderBatched(renderer);\n    } else {\n      // no batching...\n      renderer.batch.flush();\n      this._renderDirect(renderer);\n    }\n  };\n  /** Populating batches for rendering. */\n  Graphics.prototype._populateBatches = function () {\n    var geometry = this._geometry;\n    var blendMode = this.blendMode;\n    var len = geometry.batches.length;\n    this.batchTint = -1;\n    this._transformID = -1;\n    this.batchDirty = geometry.batchDirty;\n    this.batches.length = len;\n    this.vertexData = new Float32Array(geometry.points);\n    for (var i = 0; i < len; i++) {\n      var gI = geometry.batches[i];\n      var color = gI.style.color;\n      var vertexData = new Float32Array(this.vertexData.buffer, gI.attribStart * 4 * 2, gI.attribSize * 2);\n      var uvs = new Float32Array(geometry.uvsFloat32.buffer, gI.attribStart * 4 * 2, gI.attribSize * 2);\n      var indices = new Uint16Array(geometry.indicesUint16.buffer, gI.start * 2, gI.size);\n      var batch = {\n        vertexData: vertexData,\n        blendMode: blendMode,\n        indices: indices,\n        uvs: uvs,\n        _batchRGB: hex2rgb(color),\n        _tintRGB: color,\n        _texture: gI.style.texture,\n        alpha: gI.style.alpha,\n        worldAlpha: 1\n      };\n      this.batches[i] = batch;\n    }\n  };\n  /**\n   * Renders the batches using the BathedRenderer plugin\n   * @param renderer - The renderer\n   */\n  Graphics.prototype._renderBatched = function (renderer) {\n    if (!this.batches.length) {\n      return;\n    }\n    renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);\n    this.calculateVertices();\n    this.calculateTints();\n    for (var i = 0, l = this.batches.length; i < l; i++) {\n      var batch = this.batches[i];\n      batch.worldAlpha = this.worldAlpha * batch.alpha;\n      renderer.plugins[this.pluginName].render(batch);\n    }\n  };\n  /**\n   * Renders the graphics direct\n   * @param renderer - The renderer\n   */\n  Graphics.prototype._renderDirect = function (renderer) {\n    var shader = this._resolveDirectShader(renderer);\n    var geometry = this._geometry;\n    var tint = this.tint;\n    var worldAlpha = this.worldAlpha;\n    var uniforms = shader.uniforms;\n    var drawCalls = geometry.drawCalls;\n    // lets set the transfomr\n    uniforms.translationMatrix = this.transform.worldTransform;\n    // and then lets set the tint..\n    uniforms.tint[0] = (tint >> 16 & 0xFF) / 255 * worldAlpha;\n    uniforms.tint[1] = (tint >> 8 & 0xFF) / 255 * worldAlpha;\n    uniforms.tint[2] = (tint & 0xFF) / 255 * worldAlpha;\n    uniforms.tint[3] = worldAlpha;\n    // the first draw call, we can set the uniforms of the shader directly here.\n    // this means that we can tack advantage of the sync function of pixi!\n    // bind and sync uniforms..\n    // there is a way to optimise this..\n    renderer.shader.bind(shader);\n    renderer.geometry.bind(geometry, shader);\n    // set state..\n    renderer.state.set(this.state);\n    // then render the rest of them...\n    for (var i = 0, l = drawCalls.length; i < l; i++) {\n      this._renderDrawCallDirect(renderer, geometry.drawCalls[i]);\n    }\n  };\n  /**\n   * Renders specific DrawCall\n   * @param renderer\n   * @param drawCall\n   */\n  Graphics.prototype._renderDrawCallDirect = function (renderer, drawCall) {\n    var texArray = drawCall.texArray,\n      type = drawCall.type,\n      size = drawCall.size,\n      start = drawCall.start;\n    var groupTextureCount = texArray.count;\n    for (var j = 0; j < groupTextureCount; j++) {\n      renderer.texture.bind(texArray.elements[j], j);\n    }\n    renderer.geometry.draw(type, size, start);\n  };\n  /**\n   * Resolves shader for direct rendering\n   * @param renderer - The renderer\n   */\n  Graphics.prototype._resolveDirectShader = function (renderer) {\n    var shader = this.shader;\n    var pluginName = this.pluginName;\n    if (!shader) {\n      // if there is no shader here, we can use the default shader.\n      // and that only gets created if we actually need it..\n      // but may be more than one plugins for graphics\n      if (!DEFAULT_SHADERS[pluginName]) {\n        var MAX_TEXTURES = renderer.plugins[pluginName].MAX_TEXTURES;\n        var sampleValues = new Int32Array(MAX_TEXTURES);\n        for (var i = 0; i < MAX_TEXTURES; i++) {\n          sampleValues[i] = i;\n        }\n        var uniforms = {\n          tint: new Float32Array([1, 1, 1, 1]),\n          translationMatrix: new Matrix(),\n          default: UniformGroup.from({\n            uSamplers: sampleValues\n          }, true)\n        };\n        var program = renderer.plugins[pluginName]._shader.program;\n        DEFAULT_SHADERS[pluginName] = new Shader(program, uniforms);\n      }\n      shader = DEFAULT_SHADERS[pluginName];\n    }\n    return shader;\n  };\n  /** Retrieves the bounds of the graphic shape as a rectangle object. */\n  Graphics.prototype._calculateBounds = function () {\n    this.finishPoly();\n    var geometry = this._geometry;\n    // skipping when graphics is empty, like a container\n    if (!geometry.graphicsData.length) {\n      return;\n    }\n    var _a = geometry.bounds,\n      minX = _a.minX,\n      minY = _a.minY,\n      maxX = _a.maxX,\n      maxY = _a.maxY;\n    this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);\n  };\n  /**\n   * Tests if a point is inside this graphics object\n   * @param point - the point to test\n   * @returns - the result of the test\n   */\n  Graphics.prototype.containsPoint = function (point) {\n    this.worldTransform.applyInverse(point, Graphics._TEMP_POINT);\n    return this._geometry.containsPoint(Graphics._TEMP_POINT);\n  };\n  /** Recalculate the tint by applying tint to batches using Graphics tint. */\n  Graphics.prototype.calculateTints = function () {\n    if (this.batchTint !== this.tint) {\n      this.batchTint = this.tint;\n      var tintRGB = hex2rgb(this.tint, temp);\n      for (var i = 0; i < this.batches.length; i++) {\n        var batch = this.batches[i];\n        var batchTint = batch._batchRGB;\n        var r = tintRGB[0] * batchTint[0] * 255;\n        var g = tintRGB[1] * batchTint[1] * 255;\n        var b = tintRGB[2] * batchTint[2] * 255;\n        // TODO Ivan, can this be done in one go?\n        var color = (r << 16) + (g << 8) + (b | 0);\n        batch._tintRGB = (color >> 16) + (color & 0xff00) + ((color & 0xff) << 16);\n      }\n    }\n  };\n  /** If there's a transform update or a change to the shape of the geometry, recalculate the vertices. */\n  Graphics.prototype.calculateVertices = function () {\n    var wtID = this.transform._worldID;\n    if (this._transformID === wtID) {\n      return;\n    }\n    this._transformID = wtID;\n    var wt = this.transform.worldTransform;\n    var a = wt.a;\n    var b = wt.b;\n    var c = wt.c;\n    var d = wt.d;\n    var tx = wt.tx;\n    var ty = wt.ty;\n    var data = this._geometry.points; // batch.vertexDataOriginal;\n    var vertexData = this.vertexData;\n    var count = 0;\n    for (var i = 0; i < data.length; i += 2) {\n      var x = data[i];\n      var y = data[i + 1];\n      vertexData[count++] = a * x + c * y + tx;\n      vertexData[count++] = d * y + b * x + ty;\n    }\n  };\n  /**\n   * Closes the current path.\n   * @returns - Returns itself.\n   */\n  Graphics.prototype.closePath = function () {\n    var currentPath = this.currentPath;\n    if (currentPath) {\n      // we don't need to add extra point in the end because buildLine will take care of that\n      currentPath.closeStroke = true;\n      // ensure that the polygon is completed, and is available for hit detection\n      // (even if the graphics is not rendered yet)\n      this.finishPoly();\n    }\n    return this;\n  };\n  /**\n   * Apply a matrix to the positional data.\n   * @param matrix - Matrix to use for transform current shape.\n   * @returns - Returns itself.\n   */\n  Graphics.prototype.setMatrix = function (matrix) {\n    this._matrix = matrix;\n    return this;\n  };\n  /**\n   * Begin adding holes to the last draw shape\n   * IMPORTANT: holes must be fully inside a shape to work\n   * Also weirdness ensues if holes overlap!\n   * Ellipses, Circles, Rectangles and Rounded Rectangles cannot be holes or host for holes in CanvasRenderer,\n   * please use `moveTo` `lineTo`, `quadraticCurveTo` if you rely on pixi-legacy bundle.\n   * @returns - Returns itself.\n   */\n  Graphics.prototype.beginHole = function () {\n    this.finishPoly();\n    this._holeMode = true;\n    return this;\n  };\n  /**\n   * End adding holes to the last draw shape.\n   * @returns - Returns itself.\n   */\n  Graphics.prototype.endHole = function () {\n    this.finishPoly();\n    this._holeMode = false;\n    return this;\n  };\n  /**\n   * Destroys the Graphics object.\n   * @param options - Options parameter. A boolean will act as if all\n   *  options have been set to that value\n   * @param {boolean} [options.children=false] - if set to true, all the children will have\n   *  their destroy method called as well. 'options' will be passed on to those calls.\n   * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true\n   *  Should it destroy the texture of the child sprite\n   * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true\n   *  Should it destroy the base texture of the child sprite\n   */\n  Graphics.prototype.destroy = function (options) {\n    this._geometry.refCount--;\n    if (this._geometry.refCount === 0) {\n      this._geometry.dispose();\n    }\n    this._matrix = null;\n    this.currentPath = null;\n    this._lineStyle.destroy();\n    this._lineStyle = null;\n    this._fillStyle.destroy();\n    this._fillStyle = null;\n    this._geometry = null;\n    this.shader = null;\n    this.vertexData = null;\n    this.batches.length = 0;\n    this.batches = null;\n    _super.prototype.destroy.call(this, options);\n  };\n  /**\n   * New rendering behavior for rounded rectangles: circular arcs instead of quadratic bezier curves.\n   * In the next major release, we'll enable this by default.\n   */\n  Graphics.nextRoundedRectBehavior = false;\n  /**\n   * Temporary point to use for containsPoint.\n   * @private\n   */\n  Graphics._TEMP_POINT = new Point();\n  return Graphics;\n}(Container);\nvar graphicsUtils = {\n  buildPoly: buildPoly,\n  buildCircle: buildCircle,\n  buildRectangle: buildRectangle,\n  buildRoundedRectangle: buildRoundedRectangle,\n  buildLine: buildLine,\n  ArcUtils: ArcUtils,\n  BezierUtils: BezierUtils,\n  QuadraticUtils: QuadraticUtils,\n  BatchPart: BatchPart,\n  FILL_COMMANDS: FILL_COMMANDS,\n  BATCH_POOL: BATCH_POOL,\n  DRAW_CALL_POOL: DRAW_CALL_POOL\n};\nexport { FillStyle, GRAPHICS_CURVES, Graphics, GraphicsData, GraphicsGeometry, LINE_CAP, LINE_JOIN, LineStyle, graphicsUtils };","map":{"version":3,"names":["LINE_JOIN","LINE_CAP","GRAPHICS_CURVES","adaptive","maxLength","minSegments","maxSegments","epsilon","_segmentsCount","length","defaultSegments","isNaN","result","Math","ceil","FillStyle","color","alpha","texture","Texture","WHITE","matrix","visible","reset","prototype","clone","obj","destroy","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__extends","__","constructor","create","fixOrientation","points","hole","m","area","i","x1","y1","x2","y2","n","i1","i2","i3","i4","_a","_b","buildPoly","build","graphicsData","shape","slice","triangulate","graphicsGeometry","holes","verts","indices","holeArray","push","concat","triangles","earcut","vertPos","buildCircle","x","y","dx","dy","rx","ry","type","SHAPES","CIRC","circle","radius","ELIP","ellipse","width","height","roundedRect","halfWidth","halfHeight","max","min","sqrt","j1","j2","j3","j4","x0","y0","a","PI","cos","sin","center","RREC","c","tx","ty","buildRectangle","rectData","getPt","n1","n2","perc","diff","quadraticBezierCurve","fromX","fromY","cpX","cpY","toX","toY","out","xa","ya","xb","yb","j","buildRoundedRectangle","Graphics","nextRoundedRectBehavior","rrectData","vecPos","square","nx","ny","innerWeight","outerWeight","clockwise","ix","iy","ox","oy","exx","eyy","eix","eiy","eox","eoy","round","cx","cy","sx","sy","ex","ey","cx2p0x","cy2p0y","angle0","atan2","angle1","startAngle","angleDiff","absAngleDiff","abs","segCount","angleInc","angle","buildNonNativeLine","eps","closePointEps","style","lineStyle","firstPoint","Point","lastPoint","closedShape","POLY","closeStroke","closedPath","pop","set","midPointX","midPointY","unshift","indexCount","indexStart","widthSquared","miterLimitSquared","miterLimit","perpx","perpy","perp1x","perp1y","dist","ratio","alignment","cap","ROUND","SQUARE","dx0","dy0","dx1","dy1","dot","cross","join","c1","c2","px","py","pdist","imx","imy","omx","omy","smallerInsideSegmentSq","insideWeight","smallerInsideDiagonalSq","insideMiterOk","BEVEL","MITER","eps2","buildNativeLine","startIndex","currentIndex","buildLine","native","ArcUtils","curveTo","a1","b1","a2","b2","mm","dd","cc","tt","k1","k2","qx","qy","endAngle","anticlockwise","arc","_startX","_startY","_anticlockwise","sweep","PI_2","theta","theta2","cTheta","sTheta","segMinus","remainder","real","s","BezierUtils","curveLength","cpX2","cpY2","t","t2","t3","nt","nt2","nt3","prevX","prevY","dt","dt2","dt3","QuadraticUtils","ax","ay","bx","by","a32","ba","log","BatchPart","begin","attribStart","start","end","endIndex","endAttrib","attribSize","size","FILL_COMMANDS","RECT","BATCH_POOL","DRAW_CALL_POOL","GraphicsData","fillStyle","tmpPoint","GraphicsGeometry","_super","_this","call","boundsPadding","uvsFloat32","indicesUint16","batchable","colors","uvs","textureIds","drawCalls","batchDirty","batches","dirty","cacheDirty","clearDirty","shapeIndex","_bounds","Bounds","boundsDirty","defineProperty","get","updateBatches","calculateBounds","invalidate","texArray","clear","batchPart","drawShape","data","drawHole","lastShape","indexBuffer","containsPoint","point","applyInverse","copyFrom","contains","hitHole","i_1","validateBatching","currentStyle","command","transformPoints","processHoles","nextTexture","baseTexture","index_1","attribIndex","wrapMode","WRAP_MODES","REPEAT","processFill","processLine","_compareStyles","addUvs","index","attrib","need32","BYTES_PER_ELEMENT","Uint32Array","Uint16Array","isBatchable","packBatches","buildDrawCalls","styleA","styleB","l","fill","line","valid","Float32Array","batch","BATCHABLE_SIZE","TICK","BaseTexture","_globalBatch","currentGroup","BatchDrawCall","BatchTextureArray","count","DRAW_MODES","TRIANGLES","textureCount","currentTexture","textureId","drawMode","MAX_TEXTURES","LINES","_batchEnabled","touched","_batchLocation","elements","addColors","addTextureIds","packAttributes","glPoints","ArrayBuffer","f32","u32","_buffer","update","_indexBuffer","bounds","addVertexData","pad","offset","rgb","rgba","premultiplyTint","id","uvsStart","frame","adjustUvs","finish","scaleX","scaleY","offsetX","offsetY","minX","floor","minY","BatchGeometry","LineStyle","apply","arguments","BUTT","temp","DEFAULT_SHADERS","geometry","shader","pluginName","currentPath","batchTint","vertexData","_fillStyle","_lineStyle","_matrix","_holeMode","state","State","for2d","_geometry","refCount","_transformID","tint","blendMode","BLEND_MODES","NORMAL","finishPoly","value","_tint","options","lineTextureStyle","assign","startPoly","invert","len","Polygon","moveTo","lineTo","_initCurve","quadraticCurveTo","bezierCurveTo","arcTo","radius_1","startX","startY","xDiff","yDiff","beginFill","beginTextureFill","endFill","drawRect","Rectangle","drawRoundedRect","RoundedRectangle","drawCircle","Circle","drawEllipse","Ellipse","drawPolygon","path","_i","arguments$1","poly","isArray","_boundsID","isFastRect","_render","renderer","_populateBatches","_renderBatched","flush","_renderDirect","gI","buffer","_batchRGB","hex2rgb","_tintRGB","_texture","worldAlpha","setObjectRenderer","plugins","calculateVertices","calculateTints","render","_resolveDirectShader","uniforms","translationMatrix","transform","worldTransform","bind","_renderDrawCallDirect","drawCall","groupTextureCount","draw","sampleValues","Int32Array","Matrix","default","UniformGroup","from","uSamplers","program","_shader","Shader","_calculateBounds","maxX","maxY","addFrame","_TEMP_POINT","tintRGB","r","g","wtID","_worldID","wt","closePath","setMatrix","beginHole","endHole","dispose","Container","graphicsUtils"],"sources":["../../src/const.ts","../../src/styles/FillStyle.ts","../../../../node_modules/tslib/tslib.es6.js","../../src/utils/buildPoly.ts","../../src/utils/buildCircle.ts","../../src/utils/buildRectangle.ts","../../src/utils/buildRoundedRectangle.ts","../../src/utils/buildLine.ts","../../src/utils/ArcUtils.ts","../../src/utils/BezierUtils.ts","../../src/utils/QuadraticUtils.ts","../../src/utils/BatchPart.ts","../../src/utils/index.ts","../../src/GraphicsData.ts","../../src/GraphicsGeometry.ts","../../src/styles/LineStyle.ts","../../src/Graphics.ts","../../src/index.ts"],"sourcesContent":["/**\n * Supported line joints in `PIXI.LineStyle` for graphics.\n * @see PIXI.Graphics#lineStyle\n * @see https://graphicdesign.stackexchange.com/questions/59018/what-is-a-bevel-join-of-two-lines-exactly-illustrator\n * @name LINE_JOIN\n * @memberof PIXI\n * @static\n * @enum {string}\n * @property {string} MITER - 'miter': make a sharp corner where outer part of lines meet\n * @property {string} BEVEL - 'bevel': add a square butt at each end of line segment and fill the triangle at turn\n * @property {string} ROUND - 'round': add an arc at the joint\n */\nexport enum LINE_JOIN\n// eslint-disable-next-line @typescript-eslint/indent\n{\n    MITER = 'miter',\n    BEVEL = 'bevel',\n    ROUND = 'round'\n}\n\n/**\n * Support line caps in `PIXI.LineStyle` for graphics.\n * @see PIXI.Graphics#lineStyle\n * @name LINE_CAP\n * @memberof PIXI\n * @static\n * @enum {string}\n * @property {string} BUTT - 'butt': don't add any cap at line ends (leaves orthogonal edges)\n * @property {string} ROUND - 'round': add semicircle at ends\n * @property {string} SQUARE - 'square': add square at end (like `BUTT` except more length at end)\n */\nexport enum LINE_CAP\n// eslint-disable-next-line @typescript-eslint/indent\n{\n    BUTT = 'butt',\n    ROUND = 'round',\n    SQUARE = 'square'\n}\n\nexport interface IGraphicsCurvesSettings\n{\n    adaptive: boolean;\n    maxLength: number;\n    minSegments: number;\n    maxSegments: number;\n\n    epsilon: number;\n\n    _segmentsCount(length: number, defaultSegments?: number): number;\n}\n\n/**\n * Graphics curves resolution settings. If `adaptive` flag is set to `true`,\n * the resolution is calculated based on the curve's length to ensure better visual quality.\n * Adaptive draw works with `bezierCurveTo` and `quadraticCurveTo`.\n * @static\n * @constant\n * @memberof PIXI\n * @name GRAPHICS_CURVES\n * @type {object}\n * @property {boolean} [adaptive=true] - flag indicating if the resolution should be adaptive\n * @property {number} [maxLength=10] - maximal length of a single segment of the curve (if adaptive = false, ignored)\n * @property {number} [minSegments=8] - minimal number of segments in the curve (if adaptive = false, ignored)\n * @property {number} [maxSegments=2048] - maximal number of segments in the curve (if adaptive = false, ignored)\n */\nexport const GRAPHICS_CURVES: IGraphicsCurvesSettings = {\n    adaptive: true,\n    maxLength: 10,\n    minSegments: 8,\n    maxSegments:  2048,\n\n    epsilon: 0.0001,\n\n    _segmentsCount(length: number, defaultSegments = 20)\n    {\n        if (!this.adaptive || !length || isNaN(length))\n        {\n            return defaultSegments;\n        }\n\n        let result = Math.ceil(length / this.maxLength);\n\n        if (result < this.minSegments)\n        {\n            result = this.minSegments;\n        }\n        else if (result > this.maxSegments)\n        {\n            result = this.maxSegments;\n        }\n\n        return result;\n    },\n};\n","import { Texture } from '@pixi/core';\nimport type { Matrix } from '@pixi/math';\n\n/**\n * Fill style object for Graphics.\n * @memberof PIXI\n */\nexport class FillStyle\n{\n    /**\n     * The hex color value used when coloring the Graphics object.\n     * @default 0xFFFFFF\n     */\n    public color = 0xFFFFFF;\n\n    /** The alpha value used when filling the Graphics object. */\n    public alpha = 1.0;\n\n    /**\n     * The texture to be used for the fill.\n     * @default 0\n     */\n    public texture: Texture = Texture.WHITE;\n\n    /**\n     * The transform applied to the texture.\n     * @default null\n     */\n    public matrix: Matrix = null;\n\n    /** If the current fill is visible. */\n    public visible = false;\n\n    constructor()\n    {\n        this.reset();\n    }\n\n    /** Clones the object */\n    public clone(): FillStyle\n    {\n        const obj = new FillStyle();\n\n        obj.color = this.color;\n        obj.alpha = this.alpha;\n        obj.texture = this.texture;\n        obj.matrix = this.matrix;\n        obj.visible = this.visible;\n\n        return obj;\n    }\n\n    /** Reset */\n    public reset(): void\n    {\n        this.color = 0xFFFFFF;\n        this.alpha = 1;\n        this.texture = Texture.WHITE;\n        this.matrix = null;\n        this.visible = false;\n    }\n\n    /** Destroy and don't use after this. */\n    public destroy(): void\n    {\n        this.texture = null;\n        this.matrix = null;\n    }\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __createBinding(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","import { earcut } from '@pixi/utils';\n\nimport type { IShapeBuildCommand } from './IShapeBuildCommand';\nimport type { Polygon } from '@pixi/math';\n\nfunction fixOrientation(points: number[], hole = false)\n{\n    const m = points.length;\n\n    if (m < 6)\n    {\n        return;\n    }\n\n    let area = 0;\n\n    for (let i = 0, x1 = points[m - 2], y1 = points[m - 1]; i < m; i += 2)\n    {\n        const x2 = points[i];\n        const y2 = points[i + 1];\n\n        area += (x2 - x1) * (y2 + y1);\n\n        x1 = x2;\n        y1 = y2;\n    }\n\n    if ((!hole && area > 0) || (hole && area <= 0))\n    {\n        const n = m / 2;\n\n        for (let i = n + (n % 2); i < m; i += 2)\n        {\n            const i1 = m - i - 2;\n            const i2 = m - i - 1;\n            const i3 = i;\n            const i4 = i + 1;\n\n            [points[i1], points[i3]] = [points[i3], points[i1]];\n            [points[i2], points[i4]] = [points[i4], points[i2]];\n        }\n    }\n}\n/**\n * Builds a polygon to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {object} webGLData - an object containing all the WebGL-specific information to create this shape\n * @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines\n */\nexport const buildPoly: IShapeBuildCommand = {\n\n    build(graphicsData)\n    {\n        graphicsData.points = (graphicsData.shape as Polygon).points.slice();\n    },\n\n    triangulate(graphicsData, graphicsGeometry)\n    {\n        let points = graphicsData.points;\n        const holes = graphicsData.holes;\n        const verts = graphicsGeometry.points;\n        const indices = graphicsGeometry.indices;\n\n        if (points.length >= 6)\n        {\n            fixOrientation(points, false);\n\n            const holeArray = [];\n            // Process holes..\n\n            for (let i = 0; i < holes.length; i++)\n            {\n                const hole = holes[i];\n\n                fixOrientation(hole.points, true);\n\n                holeArray.push(points.length / 2);\n                points = points.concat(hole.points);\n            }\n\n            // sort color\n            const triangles = earcut(points, holeArray, 2);\n\n            if (!triangles)\n            {\n                return;\n            }\n\n            const vertPos = verts.length / 2;\n\n            for (let i = 0; i < triangles.length; i += 3)\n            {\n                indices.push(triangles[i] + vertPos);\n                indices.push(triangles[i + 1] + vertPos);\n                indices.push(triangles[i + 2] + vertPos);\n            }\n\n            for (let i = 0; i < points.length; i++)\n            {\n                verts.push(points[i]);\n            }\n        }\n    },\n};\n","// for type only\nimport { SHAPES } from '@pixi/math';\n\nimport type { Circle, Ellipse, RoundedRectangle } from '@pixi/math';\nimport type { IShapeBuildCommand } from './IShapeBuildCommand';\n\n/**\n * Builds a circle to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object to draw\n * @param {object} webGLData - an object containing all the WebGL-specific information to create this shape\n * @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines\n */\nexport const buildCircle: IShapeBuildCommand = {\n\n    build(graphicsData)\n    {\n        // need to convert points to a nice regular data\n        const points = graphicsData.points;\n\n        let x;\n        let y;\n        let dx;\n        let dy;\n        let rx;\n        let ry;\n\n        if (graphicsData.type === SHAPES.CIRC)\n        {\n            const circle = graphicsData.shape as Circle;\n\n            x = circle.x;\n            y = circle.y;\n            rx = ry = circle.radius;\n            dx = dy = 0;\n        }\n        else if (graphicsData.type === SHAPES.ELIP)\n        {\n            const ellipse = graphicsData.shape as Ellipse;\n\n            x = ellipse.x;\n            y = ellipse.y;\n            rx = ellipse.width;\n            ry = ellipse.height;\n            dx = dy = 0;\n        }\n        else\n        {\n            const roundedRect = graphicsData.shape as RoundedRectangle;\n            const halfWidth = roundedRect.width / 2;\n            const halfHeight = roundedRect.height / 2;\n\n            x = roundedRect.x + halfWidth;\n            y = roundedRect.y + halfHeight;\n            rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));\n            dx = halfWidth - rx;\n            dy = halfHeight - ry;\n        }\n\n        if (!(rx >= 0 && ry >= 0 && dx >= 0 && dy >= 0))\n        {\n            points.length = 0;\n\n            return;\n        }\n\n        // Choose a number of segments such that the maximum absolute deviation from the circle is approximately 0.029\n        const n = Math.ceil(2.3 * Math.sqrt(rx + ry));\n        const m = (n * 8) + (dx ? 4 : 0) + (dy ? 4 : 0);\n\n        points.length = m;\n\n        if (m === 0)\n        {\n            return;\n        }\n\n        if (n === 0)\n        {\n            points.length = 8;\n            points[0] = points[6] = x + dx;\n            points[1] = points[3] = y + dy;\n            points[2] = points[4] = x - dx;\n            points[5] = points[7] = y - dy;\n\n            return;\n        }\n\n        let j1 = 0;\n        let j2 = (n * 4) + (dx ? 2 : 0) + 2;\n        let j3 = j2;\n        let j4 = m;\n\n        {\n            const x0 = dx + rx;\n            const y0 = dy;\n            const x1 = x + x0;\n            const x2 = x - x0;\n            const y1 = y + y0;\n\n            points[j1++] = x1;\n            points[j1++] = y1;\n            points[--j2] = y1;\n            points[--j2] = x2;\n\n            if (dy)\n            {\n                const y2 = y - y0;\n\n                points[j3++] = x2;\n                points[j3++] = y2;\n                points[--j4] = y2;\n                points[--j4] = x1;\n            }\n        }\n\n        for (let i = 1; i < n; i++)\n        {\n            const a = Math.PI / 2 * (i / n);\n            const x0 = dx + (Math.cos(a) * rx);\n            const y0 = dy + (Math.sin(a) * ry);\n            const x1 = x + x0;\n            const x2 = x - x0;\n            const y1 = y + y0;\n            const y2 = y - y0;\n\n            points[j1++] = x1;\n            points[j1++] = y1;\n            points[--j2] = y1;\n            points[--j2] = x2;\n            points[j3++] = x2;\n            points[j3++] = y2;\n            points[--j4] = y2;\n            points[--j4] = x1;\n        }\n\n        {\n            const x0 = dx;\n            const y0 = dy + ry;\n            const x1 = x + x0;\n            const x2 = x - x0;\n            const y1 = y + y0;\n            const y2 = y - y0;\n\n            points[j1++] = x1;\n            points[j1++] = y1;\n            points[--j4] = y2;\n            points[--j4] = x1;\n\n            if (dx)\n            {\n                points[j1++] = x2;\n                points[j1++] = y1;\n                points[--j4] = y2;\n                points[--j4] = x2;\n            }\n        }\n    },\n\n    triangulate(graphicsData, graphicsGeometry)\n    {\n        const points = graphicsData.points;\n        const verts = graphicsGeometry.points;\n        const indices = graphicsGeometry.indices;\n\n        if (points.length === 0)\n        {\n            return;\n        }\n\n        let vertPos = verts.length / 2;\n        const center = vertPos;\n\n        let x;\n        let y;\n\n        if (graphicsData.type !== SHAPES.RREC)\n        {\n            const circle = graphicsData.shape as Circle;\n\n            x = circle.x;\n            y = circle.y;\n        }\n        else\n        {\n            const roundedRect = graphicsData.shape as RoundedRectangle;\n\n            x = roundedRect.x + (roundedRect.width / 2);\n            y = roundedRect.y + (roundedRect.height / 2);\n        }\n\n        const matrix = graphicsData.matrix;\n\n        // Push center (special point)\n        verts.push(\n            graphicsData.matrix ? (matrix.a * x) + (matrix.c * y) + matrix.tx : x,\n            graphicsData.matrix ? (matrix.b * x) + (matrix.d * y) + matrix.ty : y);\n\n        vertPos++;\n\n        verts.push(points[0], points[1]);\n\n        for (let i = 2; i < points.length; i += 2)\n        {\n            verts.push(points[i], points[i + 1]);\n\n            // add some uvs\n            indices.push(vertPos++, center, vertPos);\n        }\n\n        indices.push(center + 1, center, vertPos);\n    },\n};\n","import type { IShapeBuildCommand } from './IShapeBuildCommand';\nimport type { Rectangle } from '@pixi/math';\n\n/**\n * Builds a rectangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {object} webGLData - an object containing all the WebGL-specific information to create this shape\n * @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines\n */\nexport const buildRectangle: IShapeBuildCommand = {\n\n    build(graphicsData)\n    {\n        // --- //\n        // need to convert points to a nice regular data\n        //\n        const rectData = graphicsData.shape as Rectangle;\n        const x = rectData.x;\n        const y = rectData.y;\n        const width = rectData.width;\n        const height = rectData.height;\n\n        const points = graphicsData.points;\n\n        points.length = 0;\n\n        points.push(x, y,\n            x + width, y,\n            x + width, y + height,\n            x, y + height);\n    },\n\n    triangulate(graphicsData, graphicsGeometry)\n    {\n        const points = graphicsData.points;\n        const verts = graphicsGeometry.points;\n\n        const vertPos = verts.length / 2;\n\n        verts.push(points[0], points[1],\n            points[2], points[3],\n            points[6], points[7],\n            points[4], points[5]);\n\n        graphicsGeometry.indices.push(vertPos, vertPos + 1, vertPos + 2,\n            vertPos + 1, vertPos + 2, vertPos + 3);\n    },\n};\n","import { earcut } from '@pixi/utils';\n\n// for type only\nimport type { IShapeBuildCommand } from './IShapeBuildCommand';\nimport type { RoundedRectangle } from '@pixi/math';\nimport { Graphics } from '../Graphics';\nimport { buildCircle } from './buildCircle';\n\n/**\n * Calculate a single point for a quadratic bezier curve.\n * Utility function used by quadraticBezierCurve.\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {number} n1 - first number\n * @param {number} n2 - second number\n * @param {number} perc - percentage\n * @returns {number} the result\n */\nfunction getPt(n1: number, n2: number, perc: number): number\n{\n    const diff = n2 - n1;\n\n    return n1 + (diff * perc);\n}\n\n/**\n * Calculate the points for a quadratic bezier curve. (helper function..)\n * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {number} fromX - Origin point x\n * @param {number} fromY - Origin point x\n * @param {number} cpX - Control point x\n * @param {number} cpY - Control point y\n * @param {number} toX - Destination point x\n * @param {number} toY - Destination point y\n * @param {number[]} [out=[]] - The output array to add points into. If not passed, a new array is created.\n * @returns {number[]} an array of points\n */\nfunction quadraticBezierCurve(\n    fromX: number, fromY: number,\n    cpX: number, cpY: number,\n    toX: number, toY: number,\n    out: Array<number> = []): Array<number>\n{\n    const n = 20;\n    const points = out;\n\n    let xa = 0;\n    let ya = 0;\n    let xb = 0;\n    let yb = 0;\n    let x = 0;\n    let y = 0;\n\n    for (let i = 0, j = 0; i <= n; ++i)\n    {\n        j = i / n;\n\n        // The Green Line\n        xa = getPt(fromX, cpX, j);\n        ya = getPt(fromY, cpY, j);\n        xb = getPt(cpX, toX, j);\n        yb = getPt(cpY, toY, j);\n\n        // The Black Dot\n        x = getPt(xa, xb, j);\n        y = getPt(ya, yb, j);\n\n        // Handle case when first curve points overlaps and earcut fails to triangulate\n        if (i === 0 && points[points.length - 2] === x && points[points.length - 1] === y)\n        {\n            continue;\n        }\n\n        points.push(x, y);\n    }\n\n    return points;\n}\n\n/**\n * Builds a rounded rectangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {object} webGLData - an object containing all the WebGL-specific information to create this shape\n * @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines\n */\nexport const buildRoundedRectangle: IShapeBuildCommand = {\n\n    build(graphicsData)\n    {\n        if (Graphics.nextRoundedRectBehavior)\n        {\n            buildCircle.build(graphicsData);\n\n            return;\n        }\n\n        const rrectData = graphicsData.shape as RoundedRectangle;\n        const points = graphicsData.points;\n        const x = rrectData.x;\n        const y = rrectData.y;\n        const width = rrectData.width;\n        const height = rrectData.height;\n\n        // Don't allow negative radius or greater than half the smallest width\n        const radius = Math.max(0, Math.min(rrectData.radius, Math.min(width, height) / 2));\n\n        points.length = 0;\n\n        // No radius, do a simple rectangle\n        if (!radius)\n        {\n            points.push(x, y,\n                x + width, y,\n                x + width, y + height,\n                x, y + height);\n        }\n        else\n        {\n            quadraticBezierCurve(x, y + radius,\n                x, y,\n                x + radius, y,\n                points);\n            quadraticBezierCurve(x + width - radius,\n                y, x + width, y,\n                x + width, y + radius,\n                points);\n            quadraticBezierCurve(x + width, y + height - radius,\n                x + width, y + height,\n                x + width - radius, y + height,\n                points);\n            quadraticBezierCurve(x + radius, y + height,\n                x, y + height,\n                x, y + height - radius,\n                points);\n        }\n    },\n\n    triangulate(graphicsData, graphicsGeometry)\n    {\n        if (Graphics.nextRoundedRectBehavior)\n        {\n            buildCircle.triangulate(graphicsData, graphicsGeometry);\n\n            return;\n        }\n\n        const points = graphicsData.points;\n\n        const verts = graphicsGeometry.points;\n        const indices = graphicsGeometry.indices;\n\n        const vecPos = verts.length / 2;\n\n        const triangles = earcut(points, null, 2);\n\n        for (let i = 0, j = triangles.length; i < j; i += 3)\n        {\n            indices.push(triangles[i] + vecPos);\n            //     indices.push(triangles[i] + vecPos);\n            indices.push(triangles[i + 1] + vecPos);\n            //   indices.push(triangles[i + 2] + vecPos);\n            indices.push(triangles[i + 2] + vecPos);\n        }\n\n        for (let i = 0, j = points.length; i < j; i++)\n        {\n            verts.push(points[i], points[++i]);\n        }\n    },\n};\n","import { Point, SHAPES } from '@pixi/math';\n\nimport type { Polygon } from '@pixi/math';\nimport type { GraphicsData } from '../GraphicsData';\nimport type { GraphicsGeometry } from '../GraphicsGeometry';\nimport { LINE_JOIN, LINE_CAP, GRAPHICS_CURVES } from '../const';\n\n/**\n * Buffers vertices to draw a square cap.\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {number} x - X-coord of end point\n * @param {number} y - Y-coord of end point\n * @param {number} nx - X-coord of line normal pointing inside\n * @param {number} ny - Y-coord of line normal pointing inside\n * @param {number} innerWeight - Weight of inner points\n * @param {number} outerWeight - Weight of outer points\n * @param {boolean} clockwise - Whether the cap is drawn clockwise\n * @param {Array<number>} verts - vertex buffer\n * @returns {number} - no. of vertices pushed\n */\nfunction square(\n    x: number,\n    y: number,\n    nx: number,\n    ny: number,\n    innerWeight: number,\n    outerWeight: number,\n    clockwise: boolean, /* rotation for square (true at left end, false at right end) */\n    verts: Array<number>\n): number\n{\n    const ix = x - (nx * innerWeight);\n    const iy = y - (ny * innerWeight);\n    const ox = x + (nx * outerWeight);\n    const oy = y + (ny * outerWeight);\n\n    /* Rotate nx,ny for extension vector */\n    let exx; let\n        eyy;\n\n    if (clockwise)\n    {\n        exx = ny;\n        eyy = -nx;\n    }\n    else\n    {\n        exx = -ny;\n        eyy = nx;\n    }\n\n    /* [i|0]x,y extended at cap */\n    const eix = ix + exx;\n    const eiy = iy + eyy;\n    const eox = ox + exx;\n    const eoy = oy + eyy;\n\n    /* Square itself must be inserted clockwise*/\n    verts.push(eix, eiy);\n    verts.push(eox, eoy);\n\n    return 2;\n}\n\n/**\n * Buffers vertices to draw an arc at the line joint or cap.\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {number} cx - X-coord of center\n * @param {number} cy - Y-coord of center\n * @param {number} sx - X-coord of arc start\n * @param {number} sy - Y-coord of arc start\n * @param {number} ex - X-coord of arc end\n * @param {number} ey - Y-coord of arc end\n * @param {Array<number>} verts - buffer of vertices\n * @param {boolean} clockwise - orientation of vertices\n * @returns {number} - no. of vertices pushed\n */\nfunction round(\n    cx: number,\n    cy: number,\n    sx: number,\n    sy: number,\n    ex: number,\n    ey: number,\n    verts: Array<number>,\n    clockwise: boolean, /* if not cap, then clockwise is turn of joint, otherwise rotation from angle0 to angle1 */\n): number\n{\n    const cx2p0x = sx - cx;\n    const cy2p0y = sy - cy;\n\n    let angle0 = Math.atan2(cx2p0x, cy2p0y);\n    let angle1 = Math.atan2(ex - cx, ey - cy);\n\n    if (clockwise && angle0 < angle1)\n    {\n        angle0 += Math.PI * 2;\n    }\n    else if (!clockwise && angle0 > angle1)\n    {\n        angle1 += Math.PI * 2;\n    }\n\n    let startAngle = angle0;\n    const angleDiff = angle1 - angle0;\n    const absAngleDiff = Math.abs(angleDiff);\n\n    /* if (absAngleDiff >= PI_LBOUND && absAngleDiff <= PI_UBOUND)\n    {\n        const r1x = cx - nxtPx;\n        const r1y = cy - nxtPy;\n\n        if (r1x === 0)\n        {\n            if (r1y > 0)\n            {\n                angleDiff = -angleDiff;\n            }\n        }\n        else if (r1x >= -GRAPHICS_CURVES.epsilon)\n        {\n            angleDiff = -angleDiff;\n        }\n    }*/\n\n    const radius = Math.sqrt((cx2p0x * cx2p0x) + (cy2p0y * cy2p0y));\n    const segCount = ((15 * absAngleDiff * Math.sqrt(radius) / Math.PI) >> 0) + 1;\n    const angleInc = angleDiff / segCount;\n\n    startAngle += angleInc;\n\n    if (clockwise)\n    {\n        verts.push(cx, cy);\n        verts.push(sx, sy);\n\n        for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc)\n        {\n            verts.push(cx, cy);\n            verts.push(cx + ((Math.sin(angle) * radius)),\n                cy + ((Math.cos(angle) * radius)));\n        }\n\n        verts.push(cx, cy);\n        verts.push(ex, ey);\n    }\n    else\n    {\n        verts.push(sx, sy);\n        verts.push(cx, cy);\n\n        for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc)\n        {\n            verts.push(cx + ((Math.sin(angle) * radius)),\n                cy + ((Math.cos(angle) * radius)));\n            verts.push(cx, cy);\n        }\n\n        verts.push(ex, ey);\n        verts.push(cx, cy);\n    }\n\n    return segCount * 2;\n}\n\n/**\n * Builds a line to draw using the polygon method.\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {PIXI.GraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {PIXI.GraphicsGeometry} graphicsGeometry - Geometry where to append output\n */\nfunction buildNonNativeLine(graphicsData: GraphicsData, graphicsGeometry: GraphicsGeometry): void\n{\n    const shape = graphicsData.shape as Polygon;\n    let points = graphicsData.points || shape.points.slice();\n    const eps = graphicsGeometry.closePointEps;\n\n    if (points.length === 0)\n    {\n        return;\n    }\n    // if the line width is an odd number add 0.5 to align to a whole pixel\n    // commenting this out fixes #711 and #1620\n    // if (graphicsData.lineWidth%2)\n    // {\n    //     for (i = 0; i < points.length; i++)\n    //     {\n    //         points[i] += 0.5;\n    //     }\n    // }\n\n    const style = graphicsData.lineStyle;\n\n    // get first and last point.. figure out the middle!\n    const firstPoint = new Point(points[0], points[1]);\n    const lastPoint = new Point(points[points.length - 2], points[points.length - 1]);\n    const closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;\n    const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps\n        && Math.abs(firstPoint.y - lastPoint.y) < eps;\n\n    // if the first point is the last point - gonna have issues :)\n    if (closedShape)\n    {\n        // need to clone as we are going to slightly modify the shape..\n        points = points.slice();\n\n        if (closedPath)\n        {\n            points.pop();\n            points.pop();\n            lastPoint.set(points[points.length - 2], points[points.length - 1]);\n        }\n\n        const midPointX = (firstPoint.x + lastPoint.x) * 0.5;\n        const midPointY = (lastPoint.y + firstPoint.y) * 0.5;\n\n        points.unshift(midPointX, midPointY);\n        points.push(midPointX, midPointY);\n    }\n\n    const verts = graphicsGeometry.points;\n    const length = points.length / 2;\n    let indexCount = points.length;\n    const indexStart = verts.length / 2;\n\n    // Max. inner and outer width\n    const width = style.width / 2;\n    const widthSquared = width * width;\n    const miterLimitSquared = style.miterLimit * style.miterLimit;\n\n    /* Line segments of interest where (x1,y1) forms the corner. */\n    let x0 = points[0];\n    let y0 = points[1];\n    let x1 = points[2];\n    let y1 = points[3];\n    let x2 = 0;\n    let y2 = 0;\n\n    /* perp[?](x|y) = the line normal with magnitude lineWidth. */\n    let perpx = -(y0 - y1);\n    let perpy = x0 - x1;\n    let perp1x = 0;\n    let perp1y = 0;\n\n    let dist = Math.sqrt((perpx * perpx) + (perpy * perpy));\n\n    perpx /= dist;\n    perpy /= dist;\n    perpx *= width;\n    perpy *= width;\n\n    const ratio = style.alignment;// 0.5;\n    const innerWeight = (1 - ratio) * 2;\n    const outerWeight = ratio * 2;\n\n    if (!closedShape)\n    {\n        if (style.cap === LINE_CAP.ROUND)\n        {\n            indexCount += round(\n                x0 - (perpx * (innerWeight - outerWeight) * 0.5),\n                y0 - (perpy * (innerWeight - outerWeight) * 0.5),\n                x0 - (perpx * innerWeight),\n                y0 - (perpy * innerWeight),\n                x0 + (perpx * outerWeight),\n                y0 + (perpy * outerWeight),\n                verts,\n                true,\n            ) + 2;\n        }\n        else if (style.cap === LINE_CAP.SQUARE)\n        {\n            indexCount += square(x0, y0, perpx, perpy, innerWeight, outerWeight, true, verts);\n        }\n    }\n\n    // Push first point (below & above vertices)\n    verts.push(\n        x0 - (perpx * innerWeight),\n        y0 - (perpy * innerWeight));\n    verts.push(\n        x0 + (perpx * outerWeight),\n        y0 + (perpy * outerWeight));\n\n    for (let i = 1; i < length - 1; ++i)\n    {\n        x0 = points[(i - 1) * 2];\n        y0 = points[((i - 1) * 2) + 1];\n\n        x1 = points[i * 2];\n        y1 = points[(i * 2) + 1];\n\n        x2 = points[(i + 1) * 2];\n        y2 = points[((i + 1) * 2) + 1];\n\n        perpx = -(y0 - y1);\n        perpy = x0 - x1;\n\n        dist = Math.sqrt((perpx * perpx) + (perpy * perpy));\n        perpx /= dist;\n        perpy /= dist;\n        perpx *= width;\n        perpy *= width;\n\n        perp1x = -(y1 - y2);\n        perp1y = x1 - x2;\n\n        dist = Math.sqrt((perp1x * perp1x) + (perp1y * perp1y));\n        perp1x /= dist;\n        perp1y /= dist;\n        perp1x *= width;\n        perp1y *= width;\n\n        /* d[x|y](0|1) = the component displacement between points p(0,1|1,2) */\n        const dx0 = x1 - x0;\n        const dy0 = y0 - y1;\n        const dx1 = x1 - x2;\n        const dy1 = y2 - y1;\n\n        /* +ve if internal angle < 90 degree, -ve if internal angle > 90 degree. */\n        const dot = (dx0 * dx1) + (dy0 * dy1);\n        /* +ve if internal angle counterclockwise, -ve if internal angle clockwise. */\n        const cross = (dy0 * dx1) - (dy1 * dx0);\n        const clockwise = (cross < 0);\n\n        /* Going nearly parallel? */\n        /* atan(0.001) ~= 0.001 rad ~= 0.057 degree */\n        if (Math.abs(cross) < 0.001 * Math.abs(dot))\n        {\n            verts.push(\n                x1 - (perpx * innerWeight),\n                y1 - (perpy * innerWeight));\n            verts.push(\n                x1 + (perpx * outerWeight),\n                y1 + (perpy * outerWeight));\n\n            /* 180 degree corner? */\n            if (dot >= 0)\n            {\n                if (style.join === LINE_JOIN.ROUND)\n                {\n                    indexCount += round(\n                        x1, y1,\n                        x1 - (perpx * innerWeight), y1 - (perpy * innerWeight),\n                        x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight),\n                        verts, false) + 4;\n                }\n                else\n                {\n                    indexCount += 2;\n                }\n\n                verts.push(\n                    x1 - (perp1x * outerWeight),\n                    y1 - (perp1y * outerWeight));\n                verts.push(\n                    x1 + (perp1x * innerWeight),\n                    y1 + (perp1y * innerWeight));\n            }\n\n            continue;\n        }\n\n        /* p[x|y] is the miter point. pdist is the distance between miter point and p1. */\n        const c1 = ((-perpx + x0) * (-perpy + y1)) - ((-perpx + x1) * (-perpy + y0));\n        const c2 = ((-perp1x + x2) * (-perp1y + y1)) - ((-perp1x + x1) * (-perp1y + y2));\n        const px = ((dx0 * c2) - (dx1 * c1)) / cross;\n        const py = ((dy1 * c1) - (dy0 * c2)) / cross;\n        const pdist = ((px - x1) * (px - x1)) + ((py - y1) * (py - y1));\n\n        /* Inner miter point */\n        const imx = x1 + ((px - x1) * innerWeight);\n        const imy = y1 + ((py - y1) * innerWeight);\n        /* Outer miter point */\n        const omx = x1 - ((px - x1) * outerWeight);\n        const omy = y1 - ((py - y1) * outerWeight);\n\n        /* Is the inside miter point too far away, creating a spike? */\n        const smallerInsideSegmentSq = Math.min((dx0 * dx0) + (dy0 * dy0), (dx1 * dx1) + (dy1 * dy1));\n        const insideWeight = clockwise ? innerWeight : outerWeight;\n        const smallerInsideDiagonalSq = smallerInsideSegmentSq + (insideWeight * insideWeight * widthSquared);\n        const insideMiterOk = pdist <= smallerInsideDiagonalSq;\n\n        if (insideMiterOk)\n        {\n            if (style.join === LINE_JOIN.BEVEL || pdist / widthSquared > miterLimitSquared)\n            {\n                if (clockwise) /* rotating at inner angle */\n                {\n                    verts.push(imx, imy); // inner miter point\n                    verts.push(x1 + (perpx * outerWeight), y1 + (perpy * outerWeight)); // first segment's outer vertex\n                    verts.push(imx, imy); // inner miter point\n                    verts.push(x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight)); // second segment's outer vertex\n                }\n                else /* rotating at outer angle */\n                {\n                    verts.push(x1 - (perpx * innerWeight), y1 - (perpy * innerWeight)); // first segment's inner vertex\n                    verts.push(omx, omy); // outer miter point\n                    verts.push(x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight)); // second segment's outer vertex\n                    verts.push(omx, omy); // outer miter point\n                }\n\n                indexCount += 2;\n            }\n            else if (style.join === LINE_JOIN.ROUND)\n            {\n                if (clockwise) /* arc is outside */\n                {\n                    verts.push(imx, imy);\n                    verts.push(x1 + (perpx * outerWeight), y1 + (perpy * outerWeight));\n\n                    indexCount += round(\n                        x1, y1,\n                        x1 + (perpx * outerWeight), y1 + (perpy * outerWeight),\n                        x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight),\n                        verts, true\n                    ) + 4;\n\n                    verts.push(imx, imy);\n                    verts.push(x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight));\n                }\n                else /* arc is inside */\n                {\n                    verts.push(x1 - (perpx * innerWeight), y1 - (perpy * innerWeight));\n                    verts.push(omx, omy);\n\n                    indexCount += round(\n                        x1, y1,\n                        x1 - (perpx * innerWeight), y1 - (perpy * innerWeight),\n                        x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight),\n                        verts, false\n                    ) + 4;\n\n                    verts.push(x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight));\n                    verts.push(omx, omy);\n                }\n            }\n            else\n            {\n                verts.push(imx, imy);\n                verts.push(omx, omy);\n            }\n        }\n        else // inside miter is NOT ok\n        {\n            verts.push(x1 - (perpx * innerWeight), y1 - (perpy * innerWeight)); // first segment's inner vertex\n            verts.push(x1 + (perpx * outerWeight), y1 + (perpy * outerWeight)); // first segment's outer vertex\n            if (style.join === LINE_JOIN.ROUND)\n            {\n                if (clockwise) /* arc is outside */\n                {\n                    indexCount += round(\n                        x1, y1,\n                        x1 + (perpx * outerWeight), y1 + (perpy * outerWeight),\n                        x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight),\n                        verts, true\n                    ) + 2;\n                }\n                else /* arc is inside */\n                {\n                    indexCount += round(\n                        x1, y1,\n                        x1 - (perpx * innerWeight), y1 - (perpy * innerWeight),\n                        x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight),\n                        verts, false\n                    ) + 2;\n                }\n            }\n            else if (style.join === LINE_JOIN.MITER && pdist / widthSquared <= miterLimitSquared)\n            {\n                if (clockwise)\n                {\n                    verts.push(omx, omy); // inner miter point\n                    verts.push(omx, omy); // inner miter point\n                }\n                else\n                {\n                    verts.push(imx, imy); // outer miter point\n                    verts.push(imx, imy); // outer miter point\n                }\n                indexCount += 2;\n            }\n            verts.push(x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight)); // second segment's inner vertex\n            verts.push(x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight)); // second segment's outer vertex\n            indexCount += 2;\n        }\n    }\n\n    x0 = points[(length - 2) * 2];\n    y0 = points[((length - 2) * 2) + 1];\n\n    x1 = points[(length - 1) * 2];\n    y1 = points[((length - 1) * 2) + 1];\n\n    perpx = -(y0 - y1);\n    perpy = x0 - x1;\n\n    dist = Math.sqrt((perpx * perpx) + (perpy * perpy));\n    perpx /= dist;\n    perpy /= dist;\n    perpx *= width;\n    perpy *= width;\n\n    verts.push(x1 - (perpx * innerWeight), y1 - (perpy * innerWeight));\n    verts.push(x1 + (perpx * outerWeight), y1 + (perpy * outerWeight));\n\n    if (!closedShape)\n    {\n        if (style.cap === LINE_CAP.ROUND)\n        {\n            indexCount += round(\n                x1 - (perpx * (innerWeight - outerWeight) * 0.5),\n                y1 - (perpy * (innerWeight - outerWeight) * 0.5),\n                x1 - (perpx * innerWeight),\n                y1 - (perpy * innerWeight),\n                x1 + (perpx * outerWeight),\n                y1 + (perpy * outerWeight),\n                verts,\n                false\n            ) + 2;\n        }\n        else if (style.cap === LINE_CAP.SQUARE)\n        {\n            indexCount += square(x1, y1, perpx, perpy, innerWeight, outerWeight, false, verts);\n        }\n    }\n\n    const indices = graphicsGeometry.indices;\n    const eps2 = GRAPHICS_CURVES.epsilon * GRAPHICS_CURVES.epsilon;\n\n    // indices.push(indexStart);\n    for (let i = indexStart; i < indexCount + indexStart - 2; ++i)\n    {\n        x0 = verts[(i * 2)];\n        y0 = verts[(i * 2) + 1];\n\n        x1 = verts[(i + 1) * 2];\n        y1 = verts[((i + 1) * 2) + 1];\n\n        x2 = verts[(i + 2) * 2];\n        y2 = verts[((i + 2) * 2) + 1];\n\n        /* Skip zero area triangles */\n        if (Math.abs((x0 * (y1 - y2)) + (x1 * (y2 - y0)) + (x2 * (y0 - y1))) < eps2)\n        {\n            continue;\n        }\n\n        indices.push(i, i + 1, i + 2);\n    }\n}\n\n/**\n * Builds a line to draw using the gl.drawArrays(gl.LINES) method\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {PIXI.GraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {PIXI.GraphicsGeometry} graphicsGeometry - Geometry where to append output\n */\nfunction buildNativeLine(graphicsData: GraphicsData, graphicsGeometry: GraphicsGeometry): void\n{\n    let i = 0;\n\n    const shape = graphicsData.shape as Polygon;\n    const points = graphicsData.points || shape.points;\n    const closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;\n\n    if (points.length === 0) return;\n\n    const verts = graphicsGeometry.points;\n    const indices = graphicsGeometry.indices;\n    const length = points.length / 2;\n\n    const startIndex = verts.length / 2;\n    let currentIndex = startIndex;\n\n    verts.push(points[0], points[1]);\n\n    for (i = 1; i < length; i++)\n    {\n        verts.push(points[i * 2], points[(i * 2) + 1]);\n        indices.push(currentIndex, currentIndex + 1);\n\n        currentIndex++;\n    }\n\n    if (closedShape)\n    {\n        indices.push(currentIndex, startIndex);\n    }\n}\n\n/**\n * Builds a line to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {PIXI.GraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {PIXI.GraphicsGeometry} graphicsGeometry - Geometry where to append output\n */\nexport function buildLine(graphicsData: GraphicsData, graphicsGeometry: GraphicsGeometry): void\n{\n    if (graphicsData.lineStyle.native)\n    {\n        buildNativeLine(graphicsData, graphicsGeometry);\n    }\n    else\n    {\n        buildNonNativeLine(graphicsData, graphicsGeometry);\n    }\n}\n","import { GRAPHICS_CURVES } from '../const';\nimport { PI_2 } from '@pixi/math';\n\ninterface IArcLikeShape\n{\n    cx: number;\n    cy: number;\n    radius: number;\n    startAngle: number;\n    endAngle: number;\n    anticlockwise: boolean;\n}\n\n/**\n * Utilities for arc curves.\n * @private\n */\nexport class ArcUtils\n{\n    /**\n     * The arcTo() method creates an arc/curve between two tangents on the canvas.\n     *\n     * \"borrowed\" from https://code.google.com/p/fxcanvas/ - thanks google!\n     * @private\n     * @param x1 - The x-coordinate of the beginning of the arc\n     * @param y1 - The y-coordinate of the beginning of the arc\n     * @param x2 - The x-coordinate of the end of the arc\n     * @param y2 - The y-coordinate of the end of the arc\n     * @param radius - The radius of the arc\n     * @param points -\n     * @returns - If the arc length is valid, return center of circle, radius and other info otherwise `null`.\n     */\n    static curveTo(x1: number, y1: number, x2: number, y2: number, radius: number, points: Array<number>): IArcLikeShape\n    {\n        const fromX = points[points.length - 2];\n        const fromY = points[points.length - 1];\n\n        const a1 = fromY - y1;\n        const b1 = fromX - x1;\n        const a2 = y2 - y1;\n        const b2 = x2 - x1;\n        const mm = Math.abs((a1 * b2) - (b1 * a2));\n\n        if (mm < 1.0e-8 || radius === 0)\n        {\n            if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1)\n            {\n                points.push(x1, y1);\n            }\n\n            return null;\n        }\n\n        const dd = (a1 * a1) + (b1 * b1);\n        const cc = (a2 * a2) + (b2 * b2);\n        const tt = (a1 * a2) + (b1 * b2);\n        const k1 = radius * Math.sqrt(dd) / mm;\n        const k2 = radius * Math.sqrt(cc) / mm;\n        const j1 = k1 * tt / dd;\n        const j2 = k2 * tt / cc;\n        const cx = (k1 * b2) + (k2 * b1);\n        const cy = (k1 * a2) + (k2 * a1);\n        const px = b1 * (k2 + j1);\n        const py = a1 * (k2 + j1);\n        const qx = b2 * (k1 + j2);\n        const qy = a2 * (k1 + j2);\n        const startAngle = Math.atan2(py - cy, px - cx);\n        const endAngle = Math.atan2(qy - cy, qx - cx);\n\n        return {\n            cx: (cx + x1),\n            cy: (cy + y1),\n            radius,\n            startAngle,\n            endAngle,\n            anticlockwise: (b1 * a2 > b2 * a1),\n        };\n    }\n\n    /* eslint-disable max-len */\n    /**\n     * The arc method creates an arc/curve (used to create circles, or parts of circles).\n     * @private\n     * @param _startX - Start x location of arc\n     * @param _startY - Start y location of arc\n     * @param cx - The x-coordinate of the center of the circle\n     * @param cy - The y-coordinate of the center of the circle\n     * @param radius - The radius of the circle\n     * @param startAngle - The starting angle, in radians (0 is at the 3 o'clock position\n     *  of the arc's circle)\n     * @param endAngle - The ending angle, in radians\n     * @param _anticlockwise - Specifies whether the drawing should be\n     *  counter-clockwise or clockwise. False is default, and indicates clockwise, while true\n     *  indicates counter-clockwise.\n     * @param points - Collection of points to add to\n     */\n    static arc(_startX: number, _startY: number, cx: number, cy: number, radius: number,\n        startAngle: number, endAngle: number, _anticlockwise: boolean, points: Array<number>): void\n    {\n        const sweep = endAngle - startAngle;\n        const n = GRAPHICS_CURVES._segmentsCount(\n            Math.abs(sweep) * radius,\n            Math.ceil(Math.abs(sweep) / PI_2) * 40\n        );\n\n        const theta = (sweep) / (n * 2);\n        const theta2 = theta * 2;\n        const cTheta = Math.cos(theta);\n        const sTheta = Math.sin(theta);\n        const segMinus = n - 1;\n        const remainder = (segMinus % 1) / segMinus;\n\n        for (let i = 0; i <= segMinus; ++i)\n        {\n            const real = i + (remainder * i);\n            const angle = ((theta) + startAngle + (theta2 * real));\n            const c = Math.cos(angle);\n            const s = -Math.sin(angle);\n\n            points.push(\n                (((cTheta * c) + (sTheta * s)) * radius) + cx,\n                (((cTheta * -s) + (sTheta * c)) * radius) + cy\n            );\n        }\n    }\n    /* eslint-enable max-len */\n}\n","import { GRAPHICS_CURVES } from '../const';\n\n/**\n * Utilities for bezier curves\n * @private\n */\nexport class BezierUtils\n{\n    /**\n     * Calculate length of bezier curve.\n     * Analytical solution is impossible, since it involves an integral that does not integrate in general.\n     * Therefore numerical solution is used.\n     * @private\n     * @param fromX - Starting point x\n     * @param fromY - Starting point y\n     * @param cpX - Control point x\n     * @param cpY - Control point y\n     * @param cpX2 - Second Control point x\n     * @param cpY2 - Second Control point y\n     * @param toX - Destination point x\n     * @param toY - Destination point y\n     * @returns - Length of bezier curve\n     */\n    static curveLength(\n        fromX: number, fromY: number,\n        cpX: number, cpY: number,\n        cpX2: number, cpY2: number,\n        toX: number, toY: number): number\n    {\n        const n = 10;\n        let result = 0.0;\n        let t = 0.0;\n        let t2 = 0.0;\n        let t3 = 0.0;\n        let nt = 0.0;\n        let nt2 = 0.0;\n        let nt3 = 0.0;\n        let x = 0.0;\n        let y = 0.0;\n        let dx = 0.0;\n        let dy = 0.0;\n        let prevX = fromX;\n        let prevY = fromY;\n\n        for (let i = 1; i <= n; ++i)\n        {\n            t = i / n;\n            t2 = t * t;\n            t3 = t2 * t;\n            nt = (1.0 - t);\n            nt2 = nt * nt;\n            nt3 = nt2 * nt;\n\n            x = (nt3 * fromX) + (3.0 * nt2 * t * cpX) + (3.0 * nt * t2 * cpX2) + (t3 * toX);\n            y = (nt3 * fromY) + (3.0 * nt2 * t * cpY) + (3 * nt * t2 * cpY2) + (t3 * toY);\n            dx = prevX - x;\n            dy = prevY - y;\n            prevX = x;\n            prevY = y;\n\n            result += Math.sqrt((dx * dx) + (dy * dy));\n        }\n\n        return result;\n    }\n\n    /**\n     * Calculate the points for a bezier curve and then draws it.\n     *\n     * Ignored from docs since it is not directly exposed.\n     * @ignore\n     * @param cpX - Control point x\n     * @param cpY - Control point y\n     * @param cpX2 - Second Control point x\n     * @param cpY2 - Second Control point y\n     * @param toX - Destination point x\n     * @param toY - Destination point y\n     * @param points - Path array to push points into\n     */\n    static curveTo(\n        cpX: number, cpY: number,\n        cpX2: number, cpY2: number,\n        toX: number, toY: number,\n        points: Array<number>): void\n    {\n        const fromX = points[points.length - 2];\n        const fromY = points[points.length - 1];\n\n        points.length -= 2;\n\n        const n = GRAPHICS_CURVES._segmentsCount(\n            BezierUtils.curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY)\n        );\n\n        let dt = 0;\n        let dt2 = 0;\n        let dt3 = 0;\n        let t2 = 0;\n        let t3 = 0;\n\n        points.push(fromX, fromY);\n\n        for (let i = 1, j = 0; i <= n; ++i)\n        {\n            j = i / n;\n\n            dt = (1 - j);\n            dt2 = dt * dt;\n            dt3 = dt2 * dt;\n\n            t2 = j * j;\n            t3 = t2 * j;\n\n            points.push(\n                (dt3 * fromX) + (3 * dt2 * j * cpX) + (3 * dt * t2 * cpX2) + (t3 * toX),\n                (dt3 * fromY) + (3 * dt2 * j * cpY) + (3 * dt * t2 * cpY2) + (t3 * toY)\n            );\n        }\n    }\n}\n","import { GRAPHICS_CURVES } from '../const';\n\n/**\n * Utilities for quadratic curves.\n * @private\n */\nexport class QuadraticUtils\n{\n    /**\n     * Calculate length of quadratic curve\n     * @see {@link http://www.malczak.linuxpl.com/blog/quadratic-bezier-curve-length/}\n     * for the detailed explanation of math behind this.\n     * @private\n     * @param fromX - x-coordinate of curve start point\n     * @param fromY - y-coordinate of curve start point\n     * @param cpX - x-coordinate of curve control point\n     * @param cpY - y-coordinate of curve control point\n     * @param toX - x-coordinate of curve end point\n     * @param toY - y-coordinate of curve end point\n     * @returns - Length of quadratic curve\n     */\n    static curveLength(\n        fromX: number, fromY: number,\n        cpX: number, cpY: number,\n        toX: number, toY: number): number\n    {\n        const ax = fromX - (2.0 * cpX) + toX;\n        const ay = fromY - (2.0 * cpY) + toY;\n        const bx = (2.0 * cpX) - (2.0 * fromX);\n        const by = (2.0 * cpY) - (2.0 * fromY);\n        const a = 4.0 * ((ax * ax) + (ay * ay));\n        const b = 4.0 * ((ax * bx) + (ay * by));\n        const c = (bx * bx) + (by * by);\n\n        const s = 2.0 * Math.sqrt(a + b + c);\n        const a2 = Math.sqrt(a);\n        const a32 = 2.0 * a * a2;\n        const c2 = 2.0 * Math.sqrt(c);\n        const ba = b / a2;\n\n        return (\n            (a32 * s)\n                + (a2 * b * (s - c2))\n                + (\n                    ((4.0 * c * a) - (b * b))\n                   * Math.log(((2.0 * a2) + ba + s) / (ba + c2))\n                )\n        ) / (4.0 * a32);\n    }\n\n    /**\n     * Calculate the points for a quadratic bezier curve and then draws it.\n     * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c\n     * @private\n     * @param cpX - Control point x\n     * @param cpY - Control point y\n     * @param toX - Destination point x\n     * @param toY - Destination point y\n     * @param points - Points to add segments to.\n     */\n    static curveTo(cpX: number, cpY: number, toX: number, toY: number, points: Array<number>): void\n    {\n        const fromX = points[points.length - 2];\n        const fromY = points[points.length - 1];\n\n        const n = GRAPHICS_CURVES._segmentsCount(\n            QuadraticUtils.curveLength(fromX, fromY, cpX, cpY, toX, toY)\n        );\n\n        let xa = 0;\n        let ya = 0;\n\n        for (let i = 1; i <= n; ++i)\n        {\n            const j = i / n;\n\n            xa = fromX + ((cpX - fromX) * j);\n            ya = fromY + ((cpY - fromY) * j);\n\n            points.push(xa + (((cpX + ((toX - cpX) * j)) - xa) * j),\n                ya + (((cpY + ((toY - cpY) * j)) - ya) * j));\n        }\n    }\n}\n","import type { LineStyle } from '../styles/LineStyle';\nimport type { FillStyle } from '../styles/FillStyle';\n\n/**\n * A structure to hold interim batch objects for Graphics.\n * @memberof PIXI.graphicsUtils\n */\nexport class BatchPart\n{\n    public style: LineStyle | FillStyle;\n    public start: number;\n    public size: number;\n    public attribStart: number;\n    public attribSize: number;\n\n    constructor()\n    {\n        this.reset();\n    }\n\n    /**\n     * Begin batch part.\n     * @param style\n     * @param startIndex\n     * @param attribStart\n     */\n    public begin(style: LineStyle | FillStyle, startIndex: number, attribStart: number): void\n    {\n        this.reset();\n        this.style = style;\n        this.start = startIndex;\n        this.attribStart = attribStart;\n    }\n\n    /**\n     * End batch part.\n     * @param endIndex\n     * @param endAttrib\n     */\n    public end(endIndex: number, endAttrib: number): void\n    {\n        this.attribSize = endAttrib - this.attribStart;\n        this.size = endIndex - this.start;\n    }\n\n    public reset(): void\n    {\n        this.style = null;\n        this.size = 0;\n        this.start = 0;\n        this.attribStart = 0;\n        this.attribSize = 0;\n    }\n}\n","/**\n * Generalized convenience utilities for Graphics.\n * @namespace graphicsUtils\n * @memberof PIXI\n */\n\nimport { buildPoly } from './buildPoly';\nexport { buildPoly };\n\nimport { buildCircle } from './buildCircle';\nexport { buildCircle };\n\nimport { buildRectangle } from './buildRectangle';\nexport { buildRectangle };\n\nimport { buildRoundedRectangle } from './buildRoundedRectangle';\nexport { buildRoundedRectangle };\n\nexport * from './buildLine';\nexport * from './ArcUtils';\nexport * from './BezierUtils';\nexport * from './QuadraticUtils';\nexport * from './BatchPart';\n\n// for type only\nimport type { BatchPart } from './BatchPart';\nimport { SHAPES } from '@pixi/math';\nimport type { BatchDrawCall } from '@pixi/core';\nimport type { IShapeBuildCommand } from './IShapeBuildCommand';\n\n/**\n * Map of fill commands for each shape type.\n * @memberof PIXI.graphicsUtils\n * @member {object} FILL_COMMANDS\n */\nexport const FILL_COMMANDS: Record<SHAPES, IShapeBuildCommand> = {\n    [SHAPES.POLY]: buildPoly,\n    [SHAPES.CIRC]: buildCircle,\n    [SHAPES.ELIP]: buildCircle,\n    [SHAPES.RECT]: buildRectangle,\n    [SHAPES.RREC]: buildRoundedRectangle,\n};\n\n/**\n * Batch pool, stores unused batches for preventing allocations.\n * @memberof PIXI.graphicsUtils\n * @member {Array<PIXI.graphicsUtils.BatchPart>} BATCH_POOL\n */\nexport const BATCH_POOL: Array<BatchPart> = [];\n\n/**\n * Draw call pool, stores unused draw calls for preventing allocations.\n * @memberof PIXI.graphicsUtils\n * @member {Array<PIXI.BatchDrawCall>} DRAW_CALL_POOL\n */\nexport const DRAW_CALL_POOL: Array<BatchDrawCall> = [];\n","import type { Matrix, SHAPES, IShape } from '@pixi/math';\nimport type { FillStyle } from './styles/FillStyle';\nimport type { LineStyle } from './styles/LineStyle';\n\n/**\n * A class to contain data useful for Graphics objects\n * @memberof PIXI\n */\nexport class GraphicsData\n{\n    /**\n     * The shape object to draw.\n     * @member {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle}\n     */\n    shape: IShape;\n\n    /** The style of the line. */\n    lineStyle: LineStyle;\n\n    /** The style of the fill. */\n    fillStyle: FillStyle;\n\n    /** The transform matrix. */\n    matrix: Matrix;\n\n    /** The type of the shape, see the Const.Shapes file for all the existing types, */\n    type: SHAPES;\n\n    /** The collection of points. */\n    points: number[] = [];\n\n    /** The collection of holes. */\n\n    holes: Array<GraphicsData> = [];\n\n    /**\n     * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.\n     * @param fillStyle - the width of the line to draw\n     * @param lineStyle - the color of the line to draw\n     * @param matrix - Transform matrix\n     */\n    constructor(shape: IShape, fillStyle: FillStyle = null, lineStyle: LineStyle = null, matrix: Matrix = null)\n    {\n        this.shape = shape;\n        this.lineStyle = lineStyle;\n        this.fillStyle = fillStyle;\n        this.matrix = matrix;\n        this.type = shape.type;\n    }\n\n    /**\n     * Creates a new GraphicsData object with the same values as this one.\n     * @returns - Cloned GraphicsData object\n     */\n    public clone(): GraphicsData\n    {\n        return new GraphicsData(\n            this.shape,\n            this.fillStyle,\n            this.lineStyle,\n            this.matrix\n        );\n    }\n\n    /** Destroys the Graphics data. */\n    public destroy(): void\n    {\n        this.shape = null;\n        this.holes.length = 0;\n        this.holes = null;\n        this.points.length = 0;\n        this.points = null;\n        this.lineStyle = null;\n        this.fillStyle = null;\n    }\n}\n","import {\n    buildLine,\n    buildPoly,\n    BatchPart,\n    FILL_COMMANDS,\n    BATCH_POOL,\n    DRAW_CALL_POOL,\n} from './utils';\n\nimport type {\n    Texture } from '@pixi/core';\nimport {\n    BatchGeometry,\n    BatchDrawCall,\n    BatchTextureArray,\n    BaseTexture\n} from '@pixi/core';\n\nimport { DRAW_MODES, WRAP_MODES } from '@pixi/constants';\nimport { Point } from '@pixi/math';\nimport { GraphicsData } from './GraphicsData';\nimport { premultiplyTint } from '@pixi/utils';\nimport { Bounds } from '@pixi/display';\n\nimport type { Circle, Ellipse, Polygon, Rectangle, RoundedRectangle, IPointData, Matrix } from '@pixi/math';\nimport type { FillStyle } from './styles/FillStyle';\nimport type { LineStyle } from './styles/LineStyle';\n\n/*\n * Complex shape type\n * @todo Move to Math shapes\n */\ntype IShape = Circle | Ellipse | Polygon | Rectangle | RoundedRectangle;\n\nconst tmpPoint = new Point();\n\n/**\n * The Graphics class contains methods used to draw primitive shapes such as lines, circles and\n * rectangles to the display, and to color and fill them.\n *\n * GraphicsGeometry is designed to not be continually updating the geometry since it's expensive\n * to re-tesselate using **earcut**. Consider using {@link PIXI.Mesh} for this use-case, it's much faster.\n * @memberof PIXI\n */\nexport class GraphicsGeometry extends BatchGeometry\n{\n    /**\n     * The maximum number of points to consider an object \"batchable\",\n     * able to be batched by the renderer's batch system.\n\\\n     */\n    public static BATCHABLE_SIZE = 100;\n\n    /** Minimal distance between points that are considered different. Affects line tesselation. */\n    public closePointEps = 1e-4;\n\n    /** Padding to add to the bounds. */\n    public boundsPadding = 0;\n\n    uvsFloat32: Float32Array = null;\n    indicesUint16: Uint16Array | Uint32Array = null;\n    batchable = false;\n\n    /** An array of points to draw, 2 numbers per point */\n    points: number[] = [];\n\n    /** The collection of colors */\n    colors: number[] = [];\n\n    /** The UVs collection */\n    uvs: number[] = [];\n\n    /** The indices of the vertices */\n    indices: number[] = [];\n\n    /** Reference to the texture IDs. */\n    textureIds: number[] = [];\n\n    /**\n     * The collection of drawn shapes.\n     * @member {PIXI.GraphicsData[]}\n     */\n    graphicsData: Array<GraphicsData> = [];\n\n    /**\n     * List of current draw calls drived from the batches.\n     * @member {PIXI.BatchDrawCall[]}\n     */\n    drawCalls: Array<BatchDrawCall> = [];\n\n    /** Batches need to regenerated if the geometry is updated. */\n    batchDirty = -1;\n\n    /**\n     * Intermediate abstract format sent to batch system.\n     * Can be converted to drawCalls or to batchable objects.\n     * @member {PIXI.graphicsUtils.BatchPart[]}\n     */\n    batches: Array<BatchPart> = [];\n\n    /** Used to detect if the graphics object has changed. */\n    protected dirty = 0;\n\n    /** Used to check if the cache is dirty. */\n    protected cacheDirty = -1;\n\n    /** Used to detect if we cleared the graphicsData. */\n    protected clearDirty = 0;\n\n    /** Index of the last batched shape in the stack of calls. */\n    protected shapeIndex = 0;\n\n    /** Cached bounds. */\n    protected _bounds: Bounds = new Bounds();\n\n    /** The bounds dirty flag. */\n    protected boundsDirty = -1;\n\n    // eslint-disable-next-line @typescript-eslint/no-useless-constructor\n    constructor()\n    {\n        super();\n    }\n\n    /**\n     * Get the current bounds of the graphic geometry.\n     * @readonly\n     */\n    public get bounds(): Bounds\n    {\n        this.updateBatches();\n\n        if (this.boundsDirty !== this.dirty)\n        {\n            this.boundsDirty = this.dirty;\n            this.calculateBounds();\n        }\n\n        return this._bounds;\n    }\n\n    /** Call if you changed graphicsData manually. Empties all batch buffers. */\n    protected invalidate(): void\n    {\n        this.boundsDirty = -1;\n        this.dirty++;\n        this.batchDirty++;\n        this.shapeIndex = 0;\n\n        this.points.length = 0;\n        this.colors.length = 0;\n        this.uvs.length = 0;\n        this.indices.length = 0;\n        this.textureIds.length = 0;\n\n        for (let i = 0; i < this.drawCalls.length; i++)\n        {\n            this.drawCalls[i].texArray.clear();\n            DRAW_CALL_POOL.push(this.drawCalls[i]);\n        }\n\n        this.drawCalls.length = 0;\n\n        for (let i = 0; i < this.batches.length; i++)\n        {\n            const batchPart = this.batches[i];\n\n            batchPart.reset();\n            BATCH_POOL.push(batchPart);\n        }\n\n        this.batches.length = 0;\n    }\n\n    /**\n     * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.\n     * @returns - This GraphicsGeometry object. Good for chaining method calls\n     */\n    public clear(): GraphicsGeometry\n    {\n        if (this.graphicsData.length > 0)\n        {\n            this.invalidate();\n            this.clearDirty++;\n            this.graphicsData.length = 0;\n        }\n\n        return this;\n    }\n\n    /**\n     * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.\n     * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.\n     * @param fillStyle - Defines style of the fill.\n     * @param lineStyle - Defines style of the lines.\n     * @param matrix - Transform applied to the points of the shape.\n     * @returns - Returns geometry for chaining.\n     */\n    public drawShape(\n        shape: IShape,\n        fillStyle: FillStyle = null,\n        lineStyle: LineStyle = null,\n        matrix: Matrix = null): GraphicsGeometry\n    {\n        const data = new GraphicsData(shape, fillStyle, lineStyle, matrix);\n\n        this.graphicsData.push(data);\n        this.dirty++;\n\n        return this;\n    }\n\n    /**\n     * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.\n     * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.\n     * @param matrix - Transform applied to the points of the shape.\n     * @returns - Returns geometry for chaining.\n     */\n    public drawHole(shape: IShape, matrix: Matrix = null): GraphicsGeometry\n    {\n        if (!this.graphicsData.length)\n        {\n            return null;\n        }\n\n        const data = new GraphicsData(shape, null, null, matrix);\n\n        const lastShape = this.graphicsData[this.graphicsData.length - 1];\n\n        data.lineStyle = lastShape.lineStyle;\n\n        lastShape.holes.push(data);\n\n        this.dirty++;\n\n        return this;\n    }\n\n    /** Destroys the GraphicsGeometry object. */\n    public destroy(): void\n    {\n        super.destroy();\n\n        // destroy each of the GraphicsData objects\n        for (let i = 0; i < this.graphicsData.length; ++i)\n        {\n            this.graphicsData[i].destroy();\n        }\n\n        this.points.length = 0;\n        this.points = null;\n        this.colors.length = 0;\n        this.colors = null;\n        this.uvs.length = 0;\n        this.uvs = null;\n        this.indices.length = 0;\n        this.indices = null;\n        this.indexBuffer.destroy();\n        this.indexBuffer = null;\n        this.graphicsData.length = 0;\n        this.graphicsData = null;\n        this.drawCalls.length = 0;\n        this.drawCalls = null;\n        this.batches.length = 0;\n        this.batches = null;\n        this._bounds = null;\n    }\n\n    /**\n     * Check to see if a point is contained within this geometry.\n     * @param point - Point to check if it's contained.\n     * @returns {boolean} `true` if the point is contained within geometry.\n     */\n    public containsPoint(point: IPointData): boolean\n    {\n        const graphicsData = this.graphicsData;\n\n        for (let i = 0; i < graphicsData.length; ++i)\n        {\n            const data = graphicsData[i];\n\n            if (!data.fillStyle.visible)\n            {\n                continue;\n            }\n\n            // only deal with fills..\n            if (data.shape)\n            {\n                if (data.matrix)\n                {\n                    data.matrix.applyInverse(point, tmpPoint);\n                }\n                else\n                {\n                    tmpPoint.copyFrom(point);\n                }\n\n                if (data.shape.contains(tmpPoint.x, tmpPoint.y))\n                {\n                    let hitHole = false;\n\n                    if (data.holes)\n                    {\n                        for (let i = 0; i < data.holes.length; i++)\n                        {\n                            const hole = data.holes[i];\n\n                            if (hole.shape.contains(tmpPoint.x, tmpPoint.y))\n                            {\n                                hitHole = true;\n                                break;\n                            }\n                        }\n                    }\n\n                    if (!hitHole)\n                    {\n                        return true;\n                    }\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Generates intermediate batch data. Either gets converted to drawCalls\n     * or used to convert to batch objects directly by the Graphics object.\n     */\n    updateBatches(): void\n    {\n        if (!this.graphicsData.length)\n        {\n            this.batchable = true;\n\n            return;\n        }\n\n        if (!this.validateBatching())\n        {\n            return;\n        }\n\n        this.cacheDirty = this.dirty;\n\n        const uvs = this.uvs;\n        const graphicsData = this.graphicsData;\n\n        let batchPart: BatchPart = null;\n\n        let currentStyle = null;\n\n        if (this.batches.length > 0)\n        {\n            batchPart = this.batches[this.batches.length - 1];\n            currentStyle = batchPart.style;\n        }\n\n        for (let i = this.shapeIndex; i < graphicsData.length; i++)\n        {\n            this.shapeIndex++;\n\n            const data = graphicsData[i];\n            const fillStyle = data.fillStyle;\n            const lineStyle = data.lineStyle;\n            const command = FILL_COMMANDS[data.type];\n\n            // build out the shapes points..\n            command.build(data);\n\n            if (data.matrix)\n            {\n                this.transformPoints(data.points, data.matrix);\n            }\n\n            if (fillStyle.visible || lineStyle.visible)\n            {\n                this.processHoles(data.holes);\n            }\n\n            for (let j = 0; j < 2; j++)\n            {\n                const style = (j === 0) ? fillStyle : lineStyle;\n\n                if (!style.visible) continue;\n\n                const nextTexture = style.texture.baseTexture;\n                const index = this.indices.length;\n                const attribIndex = this.points.length / 2;\n\n                nextTexture.wrapMode = WRAP_MODES.REPEAT;\n\n                if (j === 0)\n                {\n                    this.processFill(data);\n                }\n                else\n                {\n                    this.processLine(data);\n                }\n\n                const size = (this.points.length / 2) - attribIndex;\n\n                if (size === 0) continue;\n                // close batch if style is different\n                if (batchPart && !this._compareStyles(currentStyle, style))\n                {\n                    batchPart.end(index, attribIndex);\n                    batchPart = null;\n                }\n                // spawn new batch if its first batch or previous was closed\n                if (!batchPart)\n                {\n                    batchPart = BATCH_POOL.pop() || new BatchPart();\n                    batchPart.begin(style, index, attribIndex);\n                    this.batches.push(batchPart);\n                    currentStyle = style;\n                }\n\n                this.addUvs(this.points, uvs, style.texture, attribIndex, size, style.matrix);\n            }\n        }\n\n        const index = this.indices.length;\n        const attrib = this.points.length / 2;\n\n        if (batchPart)\n        {\n            batchPart.end(index, attrib);\n        }\n\n        if (this.batches.length === 0)\n        {\n            // there are no visible styles in GraphicsData\n            // its possible that someone wants Graphics just for the bounds\n            this.batchable = true;\n\n            return;\n        }\n\n        const need32 = attrib > 0xffff;\n\n        // prevent allocation when length is same as buffer\n        if (this.indicesUint16 && this.indices.length === this.indicesUint16.length\n            && need32 === (this.indicesUint16.BYTES_PER_ELEMENT > 2))\n        {\n            this.indicesUint16.set(this.indices);\n        }\n        else\n        {\n            this.indicesUint16 = need32 ? new Uint32Array(this.indices) : new Uint16Array(this.indices);\n        }\n\n        // TODO make this a const..\n        this.batchable = this.isBatchable();\n\n        if (this.batchable)\n        {\n            this.packBatches();\n        }\n        else\n        {\n            this.buildDrawCalls();\n        }\n    }\n\n    /**\n     * Affinity check\n     * @param styleA\n     * @param styleB\n     */\n    protected _compareStyles(styleA: FillStyle | LineStyle, styleB: FillStyle | LineStyle): boolean\n    {\n        if (!styleA || !styleB)\n        {\n            return false;\n        }\n\n        if (styleA.texture.baseTexture !== styleB.texture.baseTexture)\n        {\n            return false;\n        }\n\n        if (styleA.color + styleA.alpha !== styleB.color + styleB.alpha)\n        {\n            return false;\n        }\n\n        if (!!(styleA as LineStyle).native !== !!(styleB as LineStyle).native)\n        {\n            return false;\n        }\n\n        return true;\n    }\n\n    /** Test geometry for batching process. */\n    protected validateBatching(): boolean\n    {\n        if (this.dirty === this.cacheDirty || !this.graphicsData.length)\n        {\n            return false;\n        }\n\n        for (let i = 0, l = this.graphicsData.length; i < l; i++)\n        {\n            const data = this.graphicsData[i];\n            const fill = data.fillStyle;\n            const line = data.lineStyle;\n\n            if (fill && !fill.texture.baseTexture.valid) return false;\n            if (line && !line.texture.baseTexture.valid) return false;\n        }\n\n        return true;\n    }\n\n    /** Offset the indices so that it works with the batcher. */\n    protected packBatches(): void\n    {\n        this.batchDirty++;\n        this.uvsFloat32 = new Float32Array(this.uvs);\n\n        const batches = this.batches;\n\n        for (let i = 0, l = batches.length; i < l; i++)\n        {\n            const batch = batches[i];\n\n            for (let j = 0; j < batch.size; j++)\n            {\n                const index = batch.start + j;\n\n                this.indicesUint16[index] = this.indicesUint16[index] - batch.attribStart;\n            }\n        }\n    }\n\n    /**\n     * Checks to see if this graphics geometry can be batched.\n     * Currently it needs to be small enough and not contain any native lines.\n     */\n    protected isBatchable(): boolean\n    {\n        // prevent heavy mesh batching\n        if (this.points.length > 0xffff * 2)\n        {\n            return false;\n        }\n\n        const batches = this.batches;\n\n        for (let i = 0; i < batches.length; i++)\n        {\n            if ((batches[i].style as LineStyle).native)\n            {\n                return false;\n            }\n        }\n\n        return (this.points.length < GraphicsGeometry.BATCHABLE_SIZE * 2);\n    }\n\n    /** Converts intermediate batches data to drawCalls. */\n    protected buildDrawCalls(): void\n    {\n        let TICK = ++BaseTexture._globalBatch;\n\n        for (let i = 0; i < this.drawCalls.length; i++)\n        {\n            this.drawCalls[i].texArray.clear();\n            DRAW_CALL_POOL.push(this.drawCalls[i]);\n        }\n\n        this.drawCalls.length = 0;\n\n        const colors = this.colors;\n        const textureIds = this.textureIds;\n\n        let currentGroup: BatchDrawCall =  DRAW_CALL_POOL.pop();\n\n        if (!currentGroup)\n        {\n            currentGroup = new BatchDrawCall();\n            currentGroup.texArray = new BatchTextureArray();\n        }\n        currentGroup.texArray.count = 0;\n        currentGroup.start = 0;\n        currentGroup.size = 0;\n        currentGroup.type = DRAW_MODES.TRIANGLES;\n\n        let textureCount = 0;\n        let currentTexture = null;\n        let textureId = 0;\n        let native = false;\n        let drawMode = DRAW_MODES.TRIANGLES;\n\n        let index = 0;\n\n        this.drawCalls.push(currentGroup);\n\n        // TODO - this can be simplified\n        for (let i = 0; i < this.batches.length; i++)\n        {\n            const data = this.batches[i];\n\n            // TODO add some full on MAX_TEXTURE CODE..\n            const MAX_TEXTURES = 8;\n\n            // Forced cast for checking `native` without errors\n            const style = data.style as LineStyle;\n\n            const nextTexture = style.texture.baseTexture;\n\n            if (native !== !!style.native)\n            {\n                native = !!style.native;\n                drawMode = native ? DRAW_MODES.LINES : DRAW_MODES.TRIANGLES;\n\n                // force the batch to break!\n                currentTexture = null;\n                textureCount = MAX_TEXTURES;\n                TICK++;\n            }\n\n            if (currentTexture !== nextTexture)\n            {\n                currentTexture = nextTexture;\n\n                if (nextTexture._batchEnabled !== TICK)\n                {\n                    if (textureCount === MAX_TEXTURES)\n                    {\n                        TICK++;\n\n                        textureCount = 0;\n\n                        if (currentGroup.size > 0)\n                        {\n                            currentGroup = DRAW_CALL_POOL.pop();\n                            if (!currentGroup)\n                            {\n                                currentGroup = new BatchDrawCall();\n                                currentGroup.texArray = new BatchTextureArray();\n                            }\n                            this.drawCalls.push(currentGroup);\n                        }\n\n                        currentGroup.start = index;\n                        currentGroup.size = 0;\n                        currentGroup.texArray.count = 0;\n                        currentGroup.type = drawMode;\n                    }\n\n                    // TODO add this to the render part..\n                    // Hack! Because texture has protected `touched`\n                    nextTexture.touched = 1;// touch;\n\n                    nextTexture._batchEnabled = TICK;\n                    nextTexture._batchLocation = textureCount;\n                    nextTexture.wrapMode = WRAP_MODES.REPEAT;\n\n                    currentGroup.texArray.elements[currentGroup.texArray.count++] = nextTexture;\n                    textureCount++;\n                }\n            }\n\n            currentGroup.size += data.size;\n            index += data.size;\n\n            textureId = nextTexture._batchLocation;\n\n            this.addColors(colors, style.color, style.alpha, data.attribSize, data.attribStart);\n            this.addTextureIds(textureIds, textureId, data.attribSize, data.attribStart);\n        }\n\n        BaseTexture._globalBatch = TICK;\n\n        // upload..\n        // merge for now!\n        this.packAttributes();\n    }\n\n    /** Packs attributes to single buffer. */\n    protected packAttributes(): void\n    {\n        const verts = this.points;\n        const uvs = this.uvs;\n        const colors = this.colors;\n        const textureIds = this.textureIds;\n\n        // verts are 2 positions.. so we * by 3 as there are 6 properties.. then 4 cos its bytes\n        const glPoints = new ArrayBuffer(verts.length * 3 * 4);\n        const f32 = new Float32Array(glPoints);\n        const u32 = new Uint32Array(glPoints);\n\n        let p = 0;\n\n        for (let i = 0; i < verts.length / 2; i++)\n        {\n            f32[p++] = verts[i * 2];\n            f32[p++] = verts[(i * 2) + 1];\n\n            f32[p++] = uvs[i * 2];\n            f32[p++] = uvs[(i * 2) + 1];\n\n            u32[p++] = colors[i];\n\n            f32[p++] = textureIds[i];\n        }\n\n        this._buffer.update(glPoints);\n        this._indexBuffer.update(this.indicesUint16);\n    }\n\n    /**\n     * Process fill part of Graphics.\n     * @param data\n     */\n    protected processFill(data: GraphicsData): void\n    {\n        if (data.holes.length)\n        {\n            buildPoly.triangulate(data, this);\n        }\n        else\n        {\n            const command = FILL_COMMANDS[data.type];\n\n            command.triangulate(data, this);\n        }\n    }\n\n    /**\n     * Process line part of Graphics.\n     * @param data\n     */\n    protected processLine(data: GraphicsData): void\n    {\n        buildLine(data, this);\n\n        for (let i = 0; i < data.holes.length; i++)\n        {\n            buildLine(data.holes[i], this);\n        }\n    }\n\n    /**\n     * Process the holes data.\n     * @param holes\n     */\n    protected processHoles(holes: Array<GraphicsData>): void\n    {\n        for (let i = 0; i < holes.length; i++)\n        {\n            const hole = holes[i];\n            const command = FILL_COMMANDS[hole.type];\n\n            command.build(hole);\n\n            if (hole.matrix)\n            {\n                this.transformPoints(hole.points, hole.matrix);\n            }\n        }\n    }\n\n    /** Update the local bounds of the object. Expensive to use performance-wise. */\n    protected calculateBounds(): void\n    {\n        const bounds = this._bounds;\n\n        bounds.clear();\n        bounds.addVertexData((this.points as any), 0, this.points.length);\n        bounds.pad(this.boundsPadding, this.boundsPadding);\n    }\n\n    /**\n     * Transform points using matrix.\n     * @param points - Points to transform\n     * @param matrix - Transform matrix\n     */\n    protected transformPoints(points: Array<number>, matrix: Matrix): void\n    {\n        for (let i = 0; i < points.length / 2; i++)\n        {\n            const x = points[(i * 2)];\n            const y = points[(i * 2) + 1];\n\n            points[(i * 2)] = (matrix.a * x) + (matrix.c * y) + matrix.tx;\n            points[(i * 2) + 1] = (matrix.b * x) + (matrix.d * y) + matrix.ty;\n        }\n    }\n\n    /**\n     * Add colors.\n     * @param colors - List of colors to add to\n     * @param color - Color to add\n     * @param alpha - Alpha to use\n     * @param size - Number of colors to add\n     * @param offset\n     */\n    protected addColors(\n        colors: Array<number>,\n        color: number,\n        alpha: number,\n        size: number,\n        offset = 0): void\n    {\n        // TODO use the premultiply bits Ivan added\n        const rgb = (color >> 16) + (color & 0xff00) + ((color & 0xff) << 16);\n\n        const rgba =  premultiplyTint(rgb, alpha);\n\n        colors.length = Math.max(colors.length, offset + size);\n\n        for (let i = 0; i < size; i++)\n        {\n            colors[offset + i] = rgba;\n        }\n    }\n\n    /**\n     * Add texture id that the shader/fragment wants to use.\n     * @param textureIds\n     * @param id\n     * @param size\n     * @param offset\n     */\n    protected addTextureIds(\n        textureIds: Array<number>,\n        id: number,\n        size: number,\n        offset = 0): void\n    {\n        textureIds.length = Math.max(textureIds.length, offset + size);\n\n        for (let i = 0; i < size; i++)\n        {\n            textureIds[offset + i] = id;\n        }\n    }\n\n    /**\n     * Generates the UVs for a shape.\n     * @param verts - Vertices\n     * @param uvs - UVs\n     * @param texture - Reference to Texture\n     * @param start - Index buffer start index.\n     * @param size - The size/length for index buffer.\n     * @param matrix - Optional transform for all points.\n     */\n    protected addUvs(\n        verts: Array<number>,\n        uvs: Array<number>,\n        texture: Texture,\n        start: number,\n        size: number,\n        matrix: Matrix = null): void\n    {\n        let index = 0;\n        const uvsStart = uvs.length;\n        const frame = texture.frame;\n\n        while (index < size)\n        {\n            let x = verts[(start + index) * 2];\n            let y = verts[((start + index) * 2) + 1];\n\n            if (matrix)\n            {\n                const nx = (matrix.a * x) + (matrix.c * y) + matrix.tx;\n\n                y = (matrix.b * x) + (matrix.d * y) + matrix.ty;\n                x = nx;\n            }\n\n            index++;\n\n            uvs.push(x / frame.width, y / frame.height);\n        }\n\n        const baseTexture = texture.baseTexture;\n\n        if (frame.width < baseTexture.width\n            || frame.height < baseTexture.height)\n        {\n            this.adjustUvs(uvs, texture, uvsStart, size);\n        }\n    }\n\n    /**\n     * Modify uvs array according to position of texture region\n     * Does not work with rotated or trimmed textures\n     * @param uvs - array\n     * @param texture - region\n     * @param start - starting index for uvs\n     * @param size - how many points to adjust\n     */\n    protected adjustUvs(uvs: Array<number>, texture: Texture, start: number, size: number): void\n    {\n        const baseTexture = texture.baseTexture;\n        const eps = 1e-6;\n        const finish = start + (size * 2);\n        const frame = texture.frame;\n        const scaleX = frame.width / baseTexture.width;\n        const scaleY = frame.height / baseTexture.height;\n        let offsetX = frame.x / frame.width;\n        let offsetY = frame.y / frame.height;\n        let minX = Math.floor(uvs[start] + eps);\n        let minY = Math.floor(uvs[start + 1] + eps);\n\n        for (let i = start + 2; i < finish; i += 2)\n        {\n            minX = Math.min(minX, Math.floor(uvs[i] + eps));\n            minY = Math.min(minY, Math.floor(uvs[i + 1] + eps));\n        }\n        offsetX -= minX;\n        offsetY -= minY;\n        for (let i = start; i < finish; i += 2)\n        {\n            uvs[i] = (uvs[i] + offsetX) * scaleX;\n            uvs[i + 1] = (uvs[i + 1] + offsetY) * scaleY;\n        }\n    }\n}\n","import { FillStyle } from './FillStyle';\nimport { LINE_JOIN, LINE_CAP } from '../const';\n\n/**\n * Represents the line style for Graphics.\n * @memberof PIXI\n */\nexport class LineStyle extends FillStyle\n{\n    /** The width (thickness) of any lines drawn. */\n    public width = 0;\n\n    /** The alignment of any lines drawn (0.5 = middle, 1 = outer, 0 = inner). WebGL only. */\n    public alignment = 0.5;\n\n    /** If true the lines will be draw using LINES instead of TRIANGLE_STRIP. */\n    public native = false;\n\n    /**\n     * Line cap style.\n     * @member {PIXI.LINE_CAP}\n     * @default PIXI.LINE_CAP.BUTT\n     */\n    public cap = LINE_CAP.BUTT;\n\n    /**\n     * Line join style.\n     * @member {PIXI.LINE_JOIN}\n     * @default PIXI.LINE_JOIN.MITER\n     */\n    public join = LINE_JOIN.MITER;\n\n    /** Miter limit. */\n    public miterLimit = 10;\n\n    /** Clones the object. */\n    public clone(): LineStyle\n    {\n        const obj = new LineStyle();\n\n        obj.color = this.color;\n        obj.alpha = this.alpha;\n        obj.texture = this.texture;\n        obj.matrix = this.matrix;\n        obj.visible = this.visible;\n        obj.width = this.width;\n        obj.alignment = this.alignment;\n        obj.native = this.native;\n        obj.cap = this.cap;\n        obj.join = this.join;\n        obj.miterLimit = this.miterLimit;\n\n        return obj;\n    }\n\n    /** Reset the line style to default. */\n    public reset(): void\n    {\n        super.reset();\n\n        // Override default line style color\n        this.color = 0x0;\n\n        this.alignment = 0.5;\n        this.width = 0;\n        this.native = false;\n    }\n}\n","import {\n    Circle,\n    Ellipse,\n    PI_2,\n    Point,\n    Polygon,\n    Rectangle,\n    RoundedRectangle,\n    Matrix,\n    SHAPES,\n} from '@pixi/math';\n\nimport type { Renderer, BatchDrawCall } from '@pixi/core';\nimport { Texture, UniformGroup, State, Shader } from '@pixi/core';\nimport { BezierUtils, QuadraticUtils, ArcUtils } from './utils';\nimport { hex2rgb } from '@pixi/utils';\nimport { GraphicsGeometry } from './GraphicsGeometry';\nimport { FillStyle } from './styles/FillStyle';\nimport { LineStyle } from './styles/LineStyle';\nimport { BLEND_MODES } from '@pixi/constants';\nimport { Container } from '@pixi/display';\n\nimport type { IShape, IPointData } from '@pixi/math';\nimport type { IDestroyOptions } from '@pixi/display';\nimport { LINE_JOIN, LINE_CAP } from './const';\n\n/** Batch element computed from Graphics geometry */\nexport interface IGraphicsBatchElement\n{\n    vertexData: Float32Array;\n    blendMode: BLEND_MODES;\n    indices: Uint16Array | Uint32Array;\n    uvs: Float32Array;\n    alpha: number;\n    worldAlpha: number;\n    _batchRGB: number[];\n    _tintRGB: number;\n    _texture: Texture;\n}\n\nexport interface IFillStyleOptions\n{\n    color?: number;\n    alpha?: number;\n    texture?: Texture;\n    matrix?: Matrix;\n}\n\nexport interface ILineStyleOptions extends IFillStyleOptions\n{\n    width?: number;\n    alignment?: number;\n    native?: boolean;\n    cap?: LINE_CAP;\n    join?: LINE_JOIN;\n    miterLimit?: number;\n}\n\nconst temp = new Float32Array(3);\n\n// a default shaders map used by graphics..\nconst DEFAULT_SHADERS: {[key: string]: Shader} = {};\n\nexport interface Graphics extends GlobalMixins.Graphics, Container {}\n\n/**\n * The Graphics class is primarily used to render primitive shapes such as lines, circles and\n * rectangles to the display, and to color and fill them.  However, you can also use a Graphics\n * object to build a list of primitives to use as a mask, or as a complex hitArea.\n *\n * Please note that due to legacy naming conventions, the behavior of some functions in this class\n * can be confusing.  Each call to `drawRect()`, `drawPolygon()`, etc. actually stores that primitive\n * in the Geometry class's GraphicsGeometry object for later use in rendering or hit testing - the\n * functions do not directly draw anything to the screen.  Similarly, the `clear()` function doesn't\n * change the screen, it simply resets the list of primitives, which can be useful if you want to\n * rebuild the contents of an existing Graphics object.\n *\n * Once a GraphicsGeometry list is built, you can re-use it in other Geometry objects as\n * an optimization, by passing it into a new Geometry object's constructor.  Because of this\n * ability, it's important to call `destroy()` on Geometry objects once you are done with them, to\n * properly dereference each GraphicsGeometry and prevent memory leaks.\n * @memberof PIXI\n */\nexport class Graphics extends Container\n{\n    /**\n     * New rendering behavior for rounded rectangles: circular arcs instead of quadratic bezier curves.\n     * In the next major release, we'll enable this by default.\n     */\n    public static nextRoundedRectBehavior = false;\n\n    /**\n     * Temporary point to use for containsPoint.\n     * @private\n     */\n    static _TEMP_POINT = new Point();\n\n    /**\n     * Represents the vertex and fragment shaders that processes the geometry and runs on the GPU.\n     * Can be shared between multiple Graphics objects.\n     */\n    public shader: Shader = null;\n\n    /** Renderer plugin for batching */\n    public pluginName = 'batch';\n\n    /**\n     * Current path\n     * @readonly\n     */\n    public currentPath: Polygon = null;\n\n    /** A collections of batches! These can be drawn by the renderer batch system. */\n    protected batches: Array<IGraphicsBatchElement> = [];\n\n    /** Update dirty for limiting calculating tints for batches. */\n    protected batchTint = -1;\n\n    /** Update dirty for limiting calculating batches.*/\n    protected batchDirty = -1;\n\n    /** Copy of the object vertex data. */\n    protected vertexData: Float32Array = null;\n\n    /** Current fill style. */\n    protected _fillStyle: FillStyle = new FillStyle();\n\n    /** Current line style. */\n    protected _lineStyle: LineStyle = new LineStyle();\n\n    /** Current shape transform matrix. */\n    protected _matrix: Matrix = null;\n\n    /** Current hole mode is enabled. */\n    protected _holeMode = false;\n    protected _transformID: number;\n    protected _tint: number;\n\n    /**\n     * Represents the WebGL state the Graphics required to render, excludes shader and geometry. E.g.,\n     * blend mode, culling, depth testing, direction of rendering triangles, backface, etc.\n     */\n    private state: State = State.for2d();\n    private _geometry: GraphicsGeometry;\n\n    /**\n     * Includes vertex positions, face indices, normals, colors, UVs, and\n     * custom attributes within buffers, reducing the cost of passing all\n     * this data to the GPU. Can be shared between multiple Mesh or Graphics objects.\n     * @readonly\n     */\n    public get geometry(): GraphicsGeometry\n    {\n        return this._geometry;\n    }\n\n    /**\n     * @param geometry - Geometry to use, if omitted will create a new GraphicsGeometry instance.\n     */\n    constructor(geometry: GraphicsGeometry = null)\n    {\n        super();\n\n        this._geometry = geometry || new GraphicsGeometry();\n        this._geometry.refCount++;\n\n        /**\n         * When cacheAsBitmap is set to true the graphics object will be rendered as if it was a sprite.\n         * This is useful if your graphics element does not change often, as it will speed up the rendering\n         * of the object in exchange for taking up texture memory. It is also useful if you need the graphics\n         * object to be anti-aliased, because it will be rendered using canvas. This is not recommended if\n         * you are constantly redrawing the graphics element.\n         * @name cacheAsBitmap\n         * @member {boolean}\n         * @memberof PIXI.Graphics#\n         * @default false\n         */\n\n        this._transformID = -1;\n\n        // Set default\n        this.tint = 0xFFFFFF;\n        this.blendMode = BLEND_MODES.NORMAL;\n    }\n\n    /**\n     * Creates a new Graphics object with the same values as this one.\n     * Note that only the geometry of the object is cloned, not its transform (position,scale,etc)\n     * @returns - A clone of the graphics object\n     */\n    public clone(): Graphics\n    {\n        this.finishPoly();\n\n        return new Graphics(this._geometry);\n    }\n\n    /**\n     * The blend mode to be applied to the graphic shape. Apply a value of\n     * `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.  Note that, since each\n     * primitive in the GraphicsGeometry list is rendered sequentially, modes\n     * such as `PIXI.BLEND_MODES.ADD` and `PIXI.BLEND_MODES.MULTIPLY` will\n     * be applied per-primitive.\n     * @default PIXI.BLEND_MODES.NORMAL\n     */\n    public set blendMode(value: BLEND_MODES)\n    {\n        this.state.blendMode = value;\n    }\n\n    public get blendMode(): BLEND_MODES\n    {\n        return this.state.blendMode;\n    }\n\n    /**\n     * The tint applied to each graphic shape. This is a hex value. A value of\n     * 0xFFFFFF will remove any tint effect.\n     * @default 0xFFFFFF\n     */\n    public get tint(): number\n    {\n        return this._tint;\n    }\n\n    public set tint(value: number)\n    {\n        this._tint = value;\n    }\n\n    /**\n     * The current fill style.\n     * @readonly\n     */\n    public get fill(): FillStyle\n    {\n        return this._fillStyle;\n    }\n\n    /**\n     * The current line style.\n     * @readonly\n     */\n    public get line(): LineStyle\n    {\n        return this._lineStyle;\n    }\n\n    /**\n     * Specifies the line style used for subsequent calls to Graphics methods such as the lineTo()\n     * method or the drawCircle() method.\n     * @param [width=0] - width of the line to draw, will update the objects stored style\n     * @param [color=0x0] - color of the line to draw, will update the objects stored style\n     * @param [alpha=1] - alpha of the line to draw, will update the objects stored style\n     * @param [alignment=0.5] - alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outer).\n     *        WebGL only.\n     * @param [native=false] - If true the lines will be draw using LINES instead of TRIANGLE_STRIP\n     * @returns - This Graphics object. Good for chaining method calls\n     */\n    public lineStyle(width: number, color?: number, alpha?: number, alignment?: number, native?: boolean): this;\n\n    /**\n     * Specifies the line style used for subsequent calls to Graphics methods such as the lineTo()\n     * method or the drawCircle() method.\n     * @param options - Line style options\n     * @param {number} [options.width=0] - width of the line to draw, will update the objects stored style\n     * @param {number} [options.color=0x0] - color of the line to draw, will update the objects stored style\n     * @param {number} [options.alpha=1] - alpha of the line to draw, will update the objects stored style\n     * @param {number} [options.alignment=0.5] - alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outer).\n     *        WebGL only.\n     * @param {boolean} [options.native=false] - If true the lines will be draw using LINES instead of TRIANGLE_STRIP\n     * @param {PIXI.LINE_CAP}[options.cap=PIXI.LINE_CAP.BUTT] - line cap style\n     * @param {PIXI.LINE_JOIN}[options.join=PIXI.LINE_JOIN.MITER] - line join style\n     * @param {number}[options.miterLimit=10] - miter limit ratio\n     * @returns {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    public lineStyle(options?: ILineStyleOptions): this;\n\n    public lineStyle(options: ILineStyleOptions | number = null,\n        color = 0x0, alpha = 1, alignment = 0.5, native = false): this\n    {\n        // Support non-object params: (width, color, alpha, alignment, native)\n        if (typeof options === 'number')\n        {\n            options = { width: options, color, alpha, alignment, native } as ILineStyleOptions;\n        }\n\n        return this.lineTextureStyle(options);\n    }\n\n    /**\n     * Like line style but support texture for line fill.\n     * @param [options] - Collection of options for setting line style.\n     * @param {number} [options.width=0] - width of the line to draw, will update the objects stored style\n     * @param {PIXI.Texture} [options.texture=PIXI.Texture.WHITE] - Texture to use\n     * @param {number} [options.color=0x0] - color of the line to draw, will update the objects stored style.\n     *  Default 0xFFFFFF if texture present.\n     * @param {number} [options.alpha=1] - alpha of the line to draw, will update the objects stored style\n     * @param {PIXI.Matrix} [options.matrix=null] - Texture matrix to transform texture\n     * @param {number} [options.alignment=0.5] - alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outer).\n     *        WebGL only.\n     * @param {boolean} [options.native=false] - If true the lines will be draw using LINES instead of TRIANGLE_STRIP\n     * @param {PIXI.LINE_CAP}[options.cap=PIXI.LINE_CAP.BUTT] - line cap style\n     * @param {PIXI.LINE_JOIN}[options.join=PIXI.LINE_JOIN.MITER] - line join style\n     * @param {number}[options.miterLimit=10] - miter limit ratio\n     * @returns {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    public lineTextureStyle(options?: ILineStyleOptions): this\n    {\n        // Apply defaults\n        options = Object.assign({\n            width: 0,\n            texture: Texture.WHITE,\n            color: (options && options.texture) ? 0xFFFFFF : 0x0,\n            alpha: 1,\n            matrix: null,\n            alignment: 0.5,\n            native: false,\n            cap: LINE_CAP.BUTT,\n            join: LINE_JOIN.MITER,\n            miterLimit: 10,\n        }, options);\n\n        if (this.currentPath)\n        {\n            this.startPoly();\n        }\n\n        const visible = options.width > 0 && options.alpha > 0;\n\n        if (!visible)\n        {\n            this._lineStyle.reset();\n        }\n        else\n        {\n            if (options.matrix)\n            {\n                options.matrix = options.matrix.clone();\n                options.matrix.invert();\n            }\n\n            Object.assign(this._lineStyle, { visible }, options);\n        }\n\n        return this;\n    }\n\n    /**\n     * Start a polygon object internally.\n     * @protected\n     */\n    protected startPoly(): void\n    {\n        if (this.currentPath)\n        {\n            const points = this.currentPath.points;\n            const len = this.currentPath.points.length;\n\n            if (len > 2)\n            {\n                this.drawShape(this.currentPath);\n                this.currentPath = new Polygon();\n                this.currentPath.closeStroke = false;\n                this.currentPath.points.push(points[len - 2], points[len - 1]);\n            }\n        }\n        else\n        {\n            this.currentPath = new Polygon();\n            this.currentPath.closeStroke = false;\n        }\n    }\n\n    /**\n     * Finish the polygon object.\n     * @protected\n     */\n    finishPoly(): void\n    {\n        if (this.currentPath)\n        {\n            if (this.currentPath.points.length > 2)\n            {\n                this.drawShape(this.currentPath);\n                this.currentPath = null;\n            }\n            else\n            {\n                this.currentPath.points.length = 0;\n            }\n        }\n    }\n\n    /**\n     * Moves the current drawing position to x, y.\n     * @param x - the X coordinate to move to\n     * @param y - the Y coordinate to move to\n     * @returns - This Graphics object. Good for chaining method calls\n     */\n    public moveTo(x: number, y: number): this\n    {\n        this.startPoly();\n        this.currentPath.points[0] = x;\n        this.currentPath.points[1] = y;\n\n        return this;\n    }\n\n    /**\n     * Draws a line using the current line style from the current drawing position to (x, y);\n     * The current drawing position is then set to (x, y).\n     * @param x - the X coordinate to draw to\n     * @param y - the Y coordinate to draw to\n     * @returns - This Graphics object. Good for chaining method calls\n     */\n    public lineTo(x: number, y: number): this\n    {\n        if (!this.currentPath)\n        {\n            this.moveTo(0, 0);\n        }\n\n        // remove duplicates..\n        const points = this.currentPath.points;\n        const fromX = points[points.length - 2];\n        const fromY = points[points.length - 1];\n\n        if (fromX !== x || fromY !== y)\n        {\n            points.push(x, y);\n        }\n\n        return this;\n    }\n\n    /**\n     * Initialize the curve\n     * @param x\n     * @param y\n     */\n    protected _initCurve(x = 0, y = 0): void\n    {\n        if (this.currentPath)\n        {\n            if (this.currentPath.points.length === 0)\n            {\n                this.currentPath.points = [x, y];\n            }\n        }\n        else\n        {\n            this.moveTo(x, y);\n        }\n    }\n\n    /**\n     * Calculate the points for a quadratic bezier curve and then draws it.\n     * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c\n     * @param cpX - Control point x\n     * @param cpY - Control point y\n     * @param toX - Destination point x\n     * @param toY - Destination point y\n     * @returns - This Graphics object. Good for chaining method calls\n     */\n    public quadraticCurveTo(cpX: number, cpY: number, toX: number, toY: number): this\n    {\n        this._initCurve();\n\n        const points = this.currentPath.points;\n\n        if (points.length === 0)\n        {\n            this.moveTo(0, 0);\n        }\n\n        QuadraticUtils.curveTo(cpX, cpY, toX, toY, points);\n\n        return this;\n    }\n\n    /**\n     * Calculate the points for a bezier curve and then draws it.\n     * @param cpX - Control point x\n     * @param cpY - Control point y\n     * @param cpX2 - Second Control point x\n     * @param cpY2 - Second Control point y\n     * @param toX - Destination point x\n     * @param toY - Destination point y\n     * @returns This Graphics object. Good for chaining method calls\n     */\n    public bezierCurveTo(cpX: number, cpY: number, cpX2: number, cpY2: number, toX: number, toY: number): this\n    {\n        this._initCurve();\n\n        BezierUtils.curveTo(cpX, cpY, cpX2, cpY2, toX, toY, this.currentPath.points);\n\n        return this;\n    }\n\n    /**\n     * The arcTo() method creates an arc/curve between two tangents on the canvas.\n     *\n     * \"borrowed\" from https://code.google.com/p/fxcanvas/ - thanks google!\n     * @param x1 - The x-coordinate of the first tangent point of the arc\n     * @param y1 - The y-coordinate of the first tangent point of the arc\n     * @param x2 - The x-coordinate of the end of the arc\n     * @param y2 - The y-coordinate of the end of the arc\n     * @param radius - The radius of the arc\n     * @returns - This Graphics object. Good for chaining method calls\n     */\n    public arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): this\n    {\n        this._initCurve(x1, y1);\n\n        const points = this.currentPath.points;\n\n        const result = ArcUtils.curveTo(x1, y1, x2, y2, radius, points);\n\n        if (result)\n        {\n            const { cx, cy, radius, startAngle, endAngle, anticlockwise } = result;\n\n            this.arc(cx, cy, radius, startAngle, endAngle, anticlockwise);\n        }\n\n        return this;\n    }\n\n    /**\n     * The arc method creates an arc/curve (used to create circles, or parts of circles).\n     * @param cx - The x-coordinate of the center of the circle\n     * @param cy - The y-coordinate of the center of the circle\n     * @param radius - The radius of the circle\n     * @param startAngle - The starting angle, in radians (0 is at the 3 o'clock position\n     *  of the arc's circle)\n     * @param endAngle - The ending angle, in radians\n     * @param anticlockwise - Specifies whether the drawing should be\n     *  counter-clockwise or clockwise. False is default, and indicates clockwise, while true\n     *  indicates counter-clockwise.\n     * @returns - This Graphics object. Good for chaining method calls\n     */\n    public arc(cx: number, cy: number, radius: number, startAngle: number, endAngle: number, anticlockwise = false): this\n    {\n        if (startAngle === endAngle)\n        {\n            return this;\n        }\n\n        if (!anticlockwise && endAngle <= startAngle)\n        {\n            endAngle += PI_2;\n        }\n        else if (anticlockwise && startAngle <= endAngle)\n        {\n            startAngle += PI_2;\n        }\n\n        const sweep = endAngle - startAngle;\n\n        if (sweep === 0)\n        {\n            return this;\n        }\n\n        const startX = cx + (Math.cos(startAngle) * radius);\n        const startY = cy + (Math.sin(startAngle) * radius);\n        const eps = this._geometry.closePointEps;\n\n        // If the currentPath exists, take its points. Otherwise call `moveTo` to start a path.\n        let points = this.currentPath ? this.currentPath.points : null;\n\n        if (points)\n        {\n            // TODO: make a better fix.\n\n            // We check how far our start is from the last existing point\n            const xDiff = Math.abs(points[points.length - 2] - startX);\n            const yDiff = Math.abs(points[points.length - 1] - startY);\n\n            if (xDiff < eps && yDiff < eps)\n            {\n                // If the point is very close, we don't add it, since this would lead to artifacts\n                // during tessellation due to floating point imprecision.\n            }\n            else\n            {\n                points.push(startX, startY);\n            }\n        }\n        else\n        {\n            this.moveTo(startX, startY);\n            points = this.currentPath.points;\n        }\n\n        ArcUtils.arc(startX, startY, cx, cy, radius, startAngle, endAngle, anticlockwise, points);\n\n        return this;\n    }\n\n    /**\n     * Specifies a simple one-color fill that subsequent calls to other Graphics methods\n     * (such as lineTo() or drawCircle()) use when drawing.\n     * @param color - the color of the fill\n     * @param alpha - the alpha of the fill\n     * @returns - This Graphics object. Good for chaining method calls\n     */\n    public beginFill(color = 0, alpha = 1): this\n    {\n        return this.beginTextureFill({ texture: Texture.WHITE, color, alpha });\n    }\n\n    /**\n     * Begin the texture fill\n     * @param options - Object object.\n     * @param {PIXI.Texture} [options.texture=PIXI.Texture.WHITE] - Texture to fill\n     * @param {number} [options.color=0xffffff] - Background to fill behind texture\n     * @param {number} [options.alpha=1] - Alpha of fill\n     * @param {PIXI.Matrix} [options.matrix=null] - Transform matrix\n     * @returns {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    beginTextureFill(options?: IFillStyleOptions): this\n    {\n        // Apply defaults\n        options = Object.assign({\n            texture: Texture.WHITE,\n            color: 0xFFFFFF,\n            alpha: 1,\n            matrix: null,\n        }, options) as IFillStyleOptions;\n\n        if (this.currentPath)\n        {\n            this.startPoly();\n        }\n\n        const visible = options.alpha > 0;\n\n        if (!visible)\n        {\n            this._fillStyle.reset();\n        }\n        else\n        {\n            if (options.matrix)\n            {\n                options.matrix = options.matrix.clone();\n                options.matrix.invert();\n            }\n\n            Object.assign(this._fillStyle, { visible }, options);\n        }\n\n        return this;\n    }\n\n    /**\n     * Applies a fill to the lines and shapes that were added since the last call to the beginFill() method.\n     * @returns - This Graphics object. Good for chaining method calls\n     */\n    public endFill(): this\n    {\n        this.finishPoly();\n\n        this._fillStyle.reset();\n\n        return this;\n    }\n\n    /**\n     * Draws a rectangle shape.\n     * @param x - The X coord of the top-left of the rectangle\n     * @param y - The Y coord of the top-left of the rectangle\n     * @param width - The width of the rectangle\n     * @param height - The height of the rectangle\n     * @returns - This Graphics object. Good for chaining method calls\n     */\n    public drawRect(x: number, y: number, width: number, height: number): this\n    {\n        return this.drawShape(new Rectangle(x, y, width, height));\n    }\n\n    /**\n     * Draw a rectangle shape with rounded/beveled corners.\n     * @param x - The X coord of the top-left of the rectangle\n     * @param y - The Y coord of the top-left of the rectangle\n     * @param width - The width of the rectangle\n     * @param height - The height of the rectangle\n     * @param radius - Radius of the rectangle corners\n     * @returns - This Graphics object. Good for chaining method calls\n     */\n    public drawRoundedRect(x: number, y: number, width: number, height: number, radius: number): this\n    {\n        return this.drawShape(new RoundedRectangle(x, y, width, height, radius));\n    }\n\n    /**\n     * Draws a circle.\n     * @param x - The X coordinate of the center of the circle\n     * @param y - The Y coordinate of the center of the circle\n     * @param radius - The radius of the circle\n     * @returns - This Graphics object. Good for chaining method calls\n     */\n    public drawCircle(x: number, y: number, radius: number): this\n    {\n        return this.drawShape(new Circle(x, y, radius));\n    }\n\n    /**\n     * Draws an ellipse.\n     * @param x - The X coordinate of the center of the ellipse\n     * @param y - The Y coordinate of the center of the ellipse\n     * @param width - The half width of the ellipse\n     * @param height - The half height of the ellipse\n     * @returns - This Graphics object. Good for chaining method calls\n     */\n    public drawEllipse(x: number, y: number, width: number, height: number): this\n    {\n        return this.drawShape(new Ellipse(x, y, width, height));\n    }\n\n    public drawPolygon(...path: Array<number> | Array<IPointData>): this;\n    public drawPolygon(path: Array<number> | Array<IPointData> | Polygon): this;\n\n    /**\n     * Draws a polygon using the given path.\n     * @param {number[]|PIXI.IPointData[]|PIXI.Polygon} path - The path data used to construct the polygon.\n     * @returns - This Graphics object. Good for chaining method calls\n     */\n    public drawPolygon(...path: any[]): this\n    {\n        let points: Array<number> | Array<IPointData>;\n        let closeStroke = true;// !!this._fillStyle;\n\n        const poly = path[0] as Polygon;\n\n        // check if data has points..\n        if (poly.points)\n        {\n            closeStroke = poly.closeStroke;\n            points = poly.points;\n        }\n        else\n        if (Array.isArray(path[0]))\n        {\n            points = path[0];\n        }\n        else\n        {\n            points = path;\n        }\n\n        const shape = new Polygon(points);\n\n        shape.closeStroke = closeStroke;\n\n        this.drawShape(shape);\n\n        return this;\n    }\n\n    /**\n     * Draw any shape.\n     * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - Shape to draw\n     * @returns - This Graphics object. Good for chaining method calls\n     */\n    public drawShape(shape: IShape): this\n    {\n        if (!this._holeMode)\n        {\n            this._geometry.drawShape(\n                shape,\n                this._fillStyle.clone(),\n                this._lineStyle.clone(),\n                this._matrix\n            );\n        }\n        else\n        {\n            this._geometry.drawHole(shape, this._matrix);\n        }\n\n        return this;\n    }\n\n    /**\n     * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.\n     * @returns - This Graphics object. Good for chaining method calls\n     */\n    public clear(): this\n    {\n        this._geometry.clear();\n        this._lineStyle.reset();\n        this._fillStyle.reset();\n\n        this._boundsID++;\n        this._matrix = null;\n        this._holeMode = false;\n        this.currentPath = null;\n\n        return this;\n    }\n\n    /**\n     * True if graphics consists of one rectangle, and thus, can be drawn like a Sprite and\n     * masked with gl.scissor.\n     * @returns - True if only 1 rect.\n     */\n    public isFastRect(): boolean\n    {\n        const data = this._geometry.graphicsData;\n\n        return data.length === 1\n            && data[0].shape.type === SHAPES.RECT\n            && !data[0].matrix\n            && !data[0].holes.length\n            && !(data[0].lineStyle.visible && data[0].lineStyle.width);\n    }\n\n    /**\n     * Renders the object using the WebGL renderer\n     * @param renderer - The renderer\n     */\n    protected _render(renderer: Renderer): void\n    {\n        this.finishPoly();\n\n        const geometry = this._geometry;\n        // batch part..\n        // batch it!\n\n        geometry.updateBatches();\n\n        if (geometry.batchable)\n        {\n            if (this.batchDirty !== geometry.batchDirty)\n            {\n                this._populateBatches();\n            }\n\n            this._renderBatched(renderer);\n        }\n        else\n        {\n            // no batching...\n            renderer.batch.flush();\n\n            this._renderDirect(renderer);\n        }\n    }\n\n    /** Populating batches for rendering. */\n    protected _populateBatches(): void\n    {\n        const geometry = this._geometry;\n        const blendMode = this.blendMode;\n        const len = geometry.batches.length;\n\n        this.batchTint = -1;\n        this._transformID = -1;\n        this.batchDirty = geometry.batchDirty;\n        this.batches.length = len;\n\n        this.vertexData = new Float32Array(geometry.points);\n\n        for (let i = 0; i < len; i++)\n        {\n            const gI = geometry.batches[i];\n            const color = gI.style.color;\n            const vertexData = new Float32Array(this.vertexData.buffer,\n                gI.attribStart * 4 * 2,\n                gI.attribSize * 2);\n\n            const uvs = new Float32Array(geometry.uvsFloat32.buffer,\n                gI.attribStart * 4 * 2,\n                gI.attribSize * 2);\n\n            const indices = new Uint16Array(geometry.indicesUint16.buffer,\n                gI.start * 2,\n                gI.size);\n\n            const batch = {\n                vertexData,\n                blendMode,\n                indices,\n                uvs,\n                _batchRGB: hex2rgb(color) as Array<number>,\n                _tintRGB: color,\n                _texture: gI.style.texture,\n                alpha: gI.style.alpha,\n                worldAlpha: 1 };\n\n            this.batches[i] = batch;\n        }\n    }\n\n    /**\n     * Renders the batches using the BathedRenderer plugin\n     * @param renderer - The renderer\n     */\n    protected _renderBatched(renderer: Renderer): void\n    {\n        if (!this.batches.length)\n        {\n            return;\n        }\n\n        renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);\n\n        this.calculateVertices();\n        this.calculateTints();\n\n        for (let i = 0, l = this.batches.length; i < l; i++)\n        {\n            const batch = this.batches[i];\n\n            batch.worldAlpha = this.worldAlpha * batch.alpha;\n\n            renderer.plugins[this.pluginName].render(batch);\n        }\n    }\n\n    /**\n     * Renders the graphics direct\n     * @param renderer - The renderer\n     */\n    protected _renderDirect(renderer: Renderer): void\n    {\n        const shader = this._resolveDirectShader(renderer);\n\n        const geometry = this._geometry;\n        const tint = this.tint;\n        const worldAlpha = this.worldAlpha;\n        const uniforms = shader.uniforms;\n        const drawCalls = geometry.drawCalls;\n\n        // lets set the transfomr\n        uniforms.translationMatrix = this.transform.worldTransform;\n\n        // and then lets set the tint..\n        uniforms.tint[0] = (((tint >> 16) & 0xFF) / 255) * worldAlpha;\n        uniforms.tint[1] = (((tint >> 8) & 0xFF) / 255) * worldAlpha;\n        uniforms.tint[2] = ((tint & 0xFF) / 255) * worldAlpha;\n        uniforms.tint[3] = worldAlpha;\n\n        // the first draw call, we can set the uniforms of the shader directly here.\n\n        // this means that we can tack advantage of the sync function of pixi!\n        // bind and sync uniforms..\n        // there is a way to optimise this..\n        renderer.shader.bind(shader);\n        renderer.geometry.bind(geometry, shader);\n\n        // set state..\n        renderer.state.set(this.state);\n\n        // then render the rest of them...\n        for (let i = 0, l = drawCalls.length; i < l; i++)\n        {\n            this._renderDrawCallDirect(renderer, geometry.drawCalls[i]);\n        }\n    }\n\n    /**\n     * Renders specific DrawCall\n     * @param renderer\n     * @param drawCall\n     */\n    protected _renderDrawCallDirect(renderer: Renderer, drawCall: BatchDrawCall): void\n    {\n        const { texArray, type, size, start } = drawCall;\n        const groupTextureCount = texArray.count;\n\n        for (let j = 0; j < groupTextureCount; j++)\n        {\n            renderer.texture.bind(texArray.elements[j], j);\n        }\n\n        renderer.geometry.draw(type, size, start);\n    }\n\n    /**\n     * Resolves shader for direct rendering\n     * @param renderer - The renderer\n     */\n    protected _resolveDirectShader(renderer: Renderer): Shader\n    {\n        let shader = this.shader;\n\n        const pluginName = this.pluginName;\n\n        if (!shader)\n        {\n            // if there is no shader here, we can use the default shader.\n            // and that only gets created if we actually need it..\n            // but may be more than one plugins for graphics\n            if (!DEFAULT_SHADERS[pluginName])\n            {\n                const { MAX_TEXTURES } = renderer.plugins[pluginName];\n                const sampleValues = new Int32Array(MAX_TEXTURES);\n\n                for (let i = 0; i < MAX_TEXTURES; i++)\n                {\n                    sampleValues[i] = i;\n                }\n\n                const uniforms = {\n                    tint: new Float32Array([1, 1, 1, 1]),\n                    translationMatrix: new Matrix(),\n                    default: UniformGroup.from({ uSamplers: sampleValues }, true),\n                };\n\n                const program = renderer.plugins[pluginName]._shader.program;\n\n                DEFAULT_SHADERS[pluginName] = new Shader(program, uniforms);\n            }\n\n            shader = DEFAULT_SHADERS[pluginName];\n        }\n\n        return shader;\n    }\n\n    /** Retrieves the bounds of the graphic shape as a rectangle object. */\n    protected _calculateBounds(): void\n    {\n        this.finishPoly();\n\n        const geometry = this._geometry;\n\n        // skipping when graphics is empty, like a container\n        if (!geometry.graphicsData.length)\n        {\n            return;\n        }\n\n        const { minX, minY, maxX, maxY } = geometry.bounds;\n\n        this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);\n    }\n\n    /**\n     * Tests if a point is inside this graphics object\n     * @param point - the point to test\n     * @returns - the result of the test\n     */\n    public containsPoint(point: IPointData): boolean\n    {\n        this.worldTransform.applyInverse(point, Graphics._TEMP_POINT);\n\n        return this._geometry.containsPoint(Graphics._TEMP_POINT);\n    }\n\n    /** Recalculate the tint by applying tint to batches using Graphics tint. */\n    protected calculateTints(): void\n    {\n        if (this.batchTint !== this.tint)\n        {\n            this.batchTint = this.tint;\n\n            const tintRGB = hex2rgb(this.tint, temp);\n\n            for (let i = 0; i < this.batches.length; i++)\n            {\n                const batch = this.batches[i];\n\n                const batchTint = batch._batchRGB;\n\n                const r = (tintRGB[0] * batchTint[0]) * 255;\n                const g = (tintRGB[1] * batchTint[1]) * 255;\n                const b = (tintRGB[2] * batchTint[2]) * 255;\n\n                // TODO Ivan, can this be done in one go?\n                const color = (r << 16) + (g << 8) + (b | 0);\n\n                batch._tintRGB = (color >> 16)\n                        + (color & 0xff00)\n                        + ((color & 0xff) << 16);\n            }\n        }\n    }\n\n    /** If there's a transform update or a change to the shape of the geometry, recalculate the vertices. */\n    protected calculateVertices(): void\n    {\n        const wtID = this.transform._worldID;\n\n        if (this._transformID === wtID)\n        {\n            return;\n        }\n\n        this._transformID = wtID;\n\n        const wt = this.transform.worldTransform;\n        const a = wt.a;\n        const b = wt.b;\n        const c = wt.c;\n        const d = wt.d;\n        const tx = wt.tx;\n        const ty = wt.ty;\n\n        const data = this._geometry.points;// batch.vertexDataOriginal;\n        const vertexData = this.vertexData;\n\n        let count = 0;\n\n        for (let i = 0; i < data.length; i += 2)\n        {\n            const x = data[i];\n            const y = data[i + 1];\n\n            vertexData[count++] = (a * x) + (c * y) + tx;\n            vertexData[count++] = (d * y) + (b * x) + ty;\n        }\n    }\n\n    /**\n     * Closes the current path.\n     * @returns - Returns itself.\n     */\n    public closePath(): this\n    {\n        const currentPath = this.currentPath;\n\n        if (currentPath)\n        {\n            // we don't need to add extra point in the end because buildLine will take care of that\n            currentPath.closeStroke = true;\n            // ensure that the polygon is completed, and is available for hit detection\n            // (even if the graphics is not rendered yet)\n            this.finishPoly();\n        }\n\n        return this;\n    }\n\n    /**\n     * Apply a matrix to the positional data.\n     * @param matrix - Matrix to use for transform current shape.\n     * @returns - Returns itself.\n     */\n    public setMatrix(matrix: Matrix): this\n    {\n        this._matrix = matrix;\n\n        return this;\n    }\n\n    /**\n     * Begin adding holes to the last draw shape\n     * IMPORTANT: holes must be fully inside a shape to work\n     * Also weirdness ensues if holes overlap!\n     * Ellipses, Circles, Rectangles and Rounded Rectangles cannot be holes or host for holes in CanvasRenderer,\n     * please use `moveTo` `lineTo`, `quadraticCurveTo` if you rely on pixi-legacy bundle.\n     * @returns - Returns itself.\n     */\n    public beginHole(): this\n    {\n        this.finishPoly();\n        this._holeMode = true;\n\n        return this;\n    }\n\n    /**\n     * End adding holes to the last draw shape.\n     * @returns - Returns itself.\n     */\n    public endHole(): this\n    {\n        this.finishPoly();\n        this._holeMode = false;\n\n        return this;\n    }\n\n    /**\n     * Destroys the Graphics object.\n     * @param options - Options parameter. A boolean will act as if all\n     *  options have been set to that value\n     * @param {boolean} [options.children=false] - if set to true, all the children will have\n     *  their destroy method called as well. 'options' will be passed on to those calls.\n     * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true\n     *  Should it destroy the texture of the child sprite\n     * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true\n     *  Should it destroy the base texture of the child sprite\n     */\n    public destroy(options?: IDestroyOptions | boolean): void\n    {\n        this._geometry.refCount--;\n        if (this._geometry.refCount === 0)\n        {\n            this._geometry.dispose();\n        }\n\n        this._matrix = null;\n        this.currentPath = null;\n        this._lineStyle.destroy();\n        this._lineStyle = null;\n        this._fillStyle.destroy();\n        this._fillStyle = null;\n        this._geometry = null;\n        this.shader = null;\n        this.vertexData = null;\n        this.batches.length = 0;\n        this.batches = null;\n\n        super.destroy(options);\n    }\n}\n","export * from './const';\nexport * from './styles/FillStyle';\nexport * from './Graphics';\nexport * from './GraphicsData';\nexport * from './GraphicsGeometry';\nexport * from './styles/LineStyle';\n\nimport {\n    buildPoly,\n    buildCircle,\n    buildRectangle,\n    buildRoundedRectangle,\n    buildLine,\n    ArcUtils,\n    BezierUtils,\n    QuadraticUtils,\n    BatchPart,\n    FILL_COMMANDS,\n    BATCH_POOL,\n    DRAW_CALL_POOL\n} from './utils';\nimport type { BatchDrawCall } from '@pixi/core/';\nimport type { IShapeBuildCommand } from './utils/IShapeBuildCommand';\nimport type { SHAPES } from '@pixi/math';\n\nexport const graphicsUtils = {\n    buildPoly: buildPoly as IShapeBuildCommand,\n    buildCircle: buildCircle as IShapeBuildCommand,\n    buildRectangle: buildRectangle as IShapeBuildCommand,\n    buildRoundedRectangle: buildRoundedRectangle as IShapeBuildCommand,\n    buildLine,\n    ArcUtils,\n    BezierUtils,\n    QuadraticUtils,\n    BatchPart,\n    FILL_COMMANDS: FILL_COMMANDS as Record<SHAPES, IShapeBuildCommand>,\n    BATCH_POOL: BATCH_POOL as Array<BatchPart>,\n    DRAW_CALL_POOL: DRAW_CALL_POOL as Array<BatchDrawCall>\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}