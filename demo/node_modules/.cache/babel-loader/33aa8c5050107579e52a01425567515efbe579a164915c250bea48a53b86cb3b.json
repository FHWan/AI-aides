{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/web.url-search-params.delete.js\";\nimport \"core-js/modules/web.url-search-params.has.js\";\nimport \"core-js/modules/web.url-search-params.size.js\";\n/*!\n * @pixi/loaders - v6.5.10\n * Compiled Thu, 06 Jul 2023 15:25:11 UTC\n *\n * @pixi/loaders is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nimport { extensions, ExtensionType, Texture } from '@pixi/core';\nimport { deprecation } from '@pixi/utils';\n\n/* jshint -W097 */\n/**\n * @memberof PIXI\n */\nvar SignalBinding = /** @class */function () {\n  /**\n   * SignalBinding constructor.\n   * @constructs SignalBinding\n   * @param {Function} fn - Event handler to be called.\n   * @param {boolean} [once=false] - Should this listener be removed after dispatch\n   * @param {object} [thisArg] - The context of the callback function.\n   * @api private\n   */\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n  function SignalBinding(fn, once, thisArg) {\n    if (once === void 0) {\n      once = false;\n    }\n    this._fn = fn;\n    this._once = once;\n    this._thisArg = thisArg;\n    this._next = this._prev = this._owner = null;\n  }\n  SignalBinding.prototype.detach = function () {\n    if (this._owner === null) {\n      return false;\n    }\n    this._owner.detach(this);\n    return true;\n  };\n  return SignalBinding;\n}();\n/**\n * @param self\n * @param node\n * @private\n */\nfunction _addSignalBinding(self, node) {\n  if (!self._head) {\n    self._head = node;\n    self._tail = node;\n  } else {\n    self._tail._next = node;\n    node._prev = self._tail;\n    self._tail = node;\n  }\n  node._owner = self;\n  return node;\n}\n/**\n * @memberof PIXI\n */\nvar Signal = /** @class */function () {\n  /**\n   * MiniSignal constructor.\n   * @example\n   * let mySignal = new Signal();\n   * let binding = mySignal.add(onSignal);\n   * mySignal.dispatch('foo', 'bar');\n   * mySignal.detach(binding);\n   */\n  function Signal() {\n    this._head = this._tail = undefined;\n  }\n  /**\n   * Return an array of attached SignalBinding.\n   * @param {boolean} [exists=false] - We only need to know if there are handlers.\n   * @returns {PIXI.SignalBinding[] | boolean} Array of attached SignalBinding or Boolean if called with exists = true\n   * @api public\n   */\n  Signal.prototype.handlers = function (exists) {\n    if (exists === void 0) {\n      exists = false;\n    }\n    var node = this._head;\n    if (exists) {\n      return !!node;\n    }\n    var ee = [];\n    while (node) {\n      ee.push(node);\n      node = node._next;\n    }\n    return ee;\n  };\n  /**\n   * Return true if node is a SignalBinding attached to this MiniSignal\n   * @param {PIXI.SignalBinding} node - Node to check.\n   * @returns {boolean} True if node is attache to mini-signal\n   */\n  Signal.prototype.has = function (node) {\n    if (!(node instanceof SignalBinding)) {\n      throw new Error('MiniSignal#has(): First arg must be a SignalBinding object.');\n    }\n    return node._owner === this;\n  };\n  /**\n   * Dispaches a signal to all registered listeners.\n   * @param {...any} args\n   * @returns {boolean} Indication if we've emitted an event.\n   */\n  Signal.prototype.dispatch = function () {\n    var arguments$1 = arguments;\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments$1[_i];\n    }\n    var node = this._head;\n    if (!node) {\n      return false;\n    }\n    while (node) {\n      if (node._once) {\n        this.detach(node);\n      }\n      node._fn.apply(node._thisArg, args);\n      node = node._next;\n    }\n    return true;\n  };\n  /**\n   * Register a new listener.\n   * @param {Function} fn - Callback function.\n   * @param {object} [thisArg] - The context of the callback function.\n   * @returns {PIXI.SignalBinding} The SignalBinding node that was added.\n   */\n  Signal.prototype.add = function (fn, thisArg) {\n    if (thisArg === void 0) {\n      thisArg = null;\n    }\n    if (typeof fn !== 'function') {\n      throw new Error('MiniSignal#add(): First arg must be a Function.');\n    }\n    return _addSignalBinding(this, new SignalBinding(fn, false, thisArg));\n  };\n  /**\n   * Register a new listener that will be executed only once.\n   * @param {Function} fn - Callback function.\n   * @param {object} [thisArg] - The context of the callback function.\n   * @returns {PIXI.SignalBinding} The SignalBinding node that was added.\n   */\n  Signal.prototype.once = function (fn, thisArg) {\n    if (thisArg === void 0) {\n      thisArg = null;\n    }\n    if (typeof fn !== 'function') {\n      throw new Error('MiniSignal#once(): First arg must be a Function.');\n    }\n    return _addSignalBinding(this, new SignalBinding(fn, true, thisArg));\n  };\n  /**\n   * Remove binding object.\n   * @param {PIXI.SignalBinding} node - The binding node that will be removed.\n   * @returns {Signal} The instance on which this method was called.\n    @api public */\n  Signal.prototype.detach = function (node) {\n    if (!(node instanceof SignalBinding)) {\n      throw new Error('MiniSignal#detach(): First arg must be a SignalBinding object.');\n    }\n    if (node._owner !== this) {\n      return this;\n    } // todo: or error?\n    if (node._prev) {\n      node._prev._next = node._next;\n    }\n    if (node._next) {\n      node._next._prev = node._prev;\n    }\n    if (node === this._head) {\n      // first node\n      this._head = node._next;\n      if (node._next === null) {\n        this._tail = null;\n      }\n    } else if (node === this._tail) {\n      // last node\n      this._tail = node._prev;\n      this._tail._next = null;\n    }\n    node._owner = null;\n    return this;\n  };\n  /**\n   * Detach all listeners.\n   * @returns {Signal} The instance on which this method was called.\n   */\n  Signal.prototype.detachAll = function () {\n    var node = this._head;\n    if (!node) {\n      return this;\n    }\n    this._head = this._tail = null;\n    while (node) {\n      node._owner = null;\n      node = node._next;\n    }\n    return this;\n  };\n  return Signal;\n}();\n\n/**\n * function from npm package `parseUri`, converted to TS to avoid leftpad incident\n * @param {string} str\n * @param [opts] - options\n * @param {boolean} [opts.strictMode] - type of parser\n */\nfunction parseUri(str, opts) {\n  opts = opts || {};\n  var o = {\n    // eslint-disable-next-line max-len\n    key: ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'],\n    q: {\n      name: 'queryKey',\n      parser: /(?:^|&)([^&=]*)=?([^&]*)/g\n    },\n    parser: {\n      // eslint-disable-next-line max-len\n      strict: /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?))?((((?:[^?#\\/]*\\/)*)([^?#]*))(?:\\?([^#]*))?(?:#(.*))?)/,\n      // eslint-disable-next-line max-len\n      loose: /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/\n    }\n  };\n  var m = o.parser[opts.strictMode ? 'strict' : 'loose'].exec(str);\n  var uri = {};\n  var i = 14;\n  while (i--) {\n    uri[o.key[i]] = m[i] || '';\n  }\n  uri[o.q.name] = {};\n  uri[o.key[12]].replace(o.q.parser, function (_t0, t1, t2) {\n    if (t1) {\n      uri[o.q.name][t1] = t2;\n    }\n  });\n  return uri;\n}\n\n// tests if CORS is supported in XHR, if not we need to use XDR\nvar useXdr;\nvar tempAnchor = null;\n// some status constants\nvar STATUS_NONE = 0;\nvar STATUS_OK = 200;\nvar STATUS_EMPTY = 204;\nvar STATUS_IE_BUG_EMPTY = 1223;\nvar STATUS_TYPE_OK = 2;\n// noop\nfunction _noop$1() {}\n/**\n * Quick helper to set a value on one of the extension maps. Ensures there is no\n * dot at the start of the extension.\n * @ignore\n * @param map - The map to set on.\n * @param extname - The extension (or key) to set.\n * @param val - The value to set.\n */\nfunction setExtMap(map, extname, val) {\n  if (extname && extname.indexOf('.') === 0) {\n    extname = extname.substring(1);\n  }\n  if (!extname) {\n    return;\n  }\n  map[extname] = val;\n}\n/**\n * Quick helper to get string xhr type.\n * @ignore\n * @param xhr - The request to check.\n * @returns The type.\n */\nfunction reqType(xhr) {\n  return xhr.toString().replace('object ', '');\n}\n/**\n * Manages the state and loading of a resource and all child resources.\n *\n * Can be extended in `GlobalMixins.LoaderResource`.\n * @memberof PIXI\n */\nvar LoaderResource = /** @class */function () {\n  /**\n   * @param {string} name - The name of the resource to load.\n   * @param {string|string[]} url - The url for this resource, for audio/video loads you can pass\n   *      an array of sources.\n   * @param {object} [options] - The options for the load.\n   * @param {string|boolean} [options.crossOrigin] - Is this request cross-origin? Default is to\n   *      determine automatically.\n   * @param {number} [options.timeout=0] - A timeout in milliseconds for the load. If the load takes\n   *      longer than this time it is cancelled and the load is considered a failure. If this value is\n   *      set to `0` then there is no explicit timeout.\n   * @param {PIXI.LoaderResource.LOAD_TYPE} [options.loadType=LOAD_TYPE.XHR] - How should this resource\n   *      be loaded?\n   * @param {PIXI.LoaderResource.XHR_RESPONSE_TYPE} [options.xhrType=XHR_RESPONSE_TYPE.DEFAULT] - How\n   *      should the data being loaded be interpreted when using XHR?\n   * @param {PIXI.LoaderResource.IMetadata} [options.metadata] - Extra configuration for middleware\n   *      and the Resource object.\n   */\n  function LoaderResource(name, url, options) {\n    /**\n     * The `dequeue` method that will be used a storage place for the async queue dequeue method\n     * used privately by the loader.\n     * @private\n     * @member {Function}\n     */\n    this._dequeue = _noop$1;\n    /**\n     * Used a storage place for the on load binding used privately by the loader.\n     * @private\n     * @member {Function}\n     */\n    this._onLoadBinding = null;\n    /**\n     * The timer for element loads to check if they timeout.\n     * @private\n     */\n    this._elementTimer = 0;\n    /**\n     * The `complete` function bound to this resource's context.\n     * @private\n     * @type {Function}\n     */\n    this._boundComplete = null;\n    /**\n     * The `_onError` function bound to this resource's context.\n     * @private\n     * @type {Function}\n     */\n    this._boundOnError = null;\n    /**\n     * The `_onProgress` function bound to this resource's context.\n     * @private\n     * @type {Function}\n     */\n    this._boundOnProgress = null;\n    /**\n     * The `_onTimeout` function bound to this resource's context.\n     * @private\n     * @type {Function}\n     */\n    this._boundOnTimeout = null;\n    this._boundXhrOnError = null;\n    this._boundXhrOnTimeout = null;\n    this._boundXhrOnAbort = null;\n    this._boundXhrOnLoad = null;\n    if (typeof name !== 'string' || typeof url !== 'string') {\n      throw new Error('Both name and url are required for constructing a resource.');\n    }\n    options = options || {};\n    this._flags = 0;\n    // set data url flag, needs to be set early for some _determineX checks to work.\n    this._setFlag(LoaderResource.STATUS_FLAGS.DATA_URL, url.indexOf('data:') === 0);\n    this.name = name;\n    this.url = url;\n    this.extension = this._getExtension();\n    this.data = null;\n    this.crossOrigin = options.crossOrigin === true ? 'anonymous' : options.crossOrigin;\n    this.timeout = options.timeout || 0;\n    this.loadType = options.loadType || this._determineLoadType();\n    // The type used to load the resource via XHR. If unset, determined automatically.\n    this.xhrType = options.xhrType;\n    // Extra info for middleware, and controlling specifics about how the resource loads.\n    // Note that if you pass in a `loadElement`, the Resource class takes ownership of it.\n    // Meaning it will modify it as it sees fit.\n    this.metadata = options.metadata || {};\n    // The error that occurred while loading (if any).\n    this.error = null;\n    // The XHR object that was used to load this resource. This is only set\n    // when `loadType` is `LoaderResource.LOAD_TYPE.XHR`.\n    this.xhr = null;\n    // The child resources this resource owns.\n    this.children = [];\n    // The resource type.\n    this.type = LoaderResource.TYPE.UNKNOWN;\n    // The progress chunk owned by this resource.\n    this.progressChunk = 0;\n    // The `dequeue` method that will be used a storage place for the async queue dequeue method\n    // used privately by the loader.\n    this._dequeue = _noop$1;\n    // Used a storage place for the on load binding used privately by the loader.\n    this._onLoadBinding = null;\n    // The timer for element loads to check if they timeout.\n    this._elementTimer = 0;\n    this._boundComplete = this.complete.bind(this);\n    this._boundOnError = this._onError.bind(this);\n    this._boundOnProgress = this._onProgress.bind(this);\n    this._boundOnTimeout = this._onTimeout.bind(this);\n    // xhr callbacks\n    this._boundXhrOnError = this._xhrOnError.bind(this);\n    this._boundXhrOnTimeout = this._xhrOnTimeout.bind(this);\n    this._boundXhrOnAbort = this._xhrOnAbort.bind(this);\n    this._boundXhrOnLoad = this._xhrOnLoad.bind(this);\n    // Dispatched when the resource beings to load.\n    this.onStart = new Signal();\n    // Dispatched each time progress of this resource load updates.\n    // Not all resources types and loader systems can support this event\n    // so sometimes it may not be available. If the resource\n    // is being loaded on a modern browser, using XHR, and the remote server\n    // properly sets Content-Length headers, then this will be available.\n    this.onProgress = new Signal();\n    // Dispatched once this resource has loaded, if there was an error it will\n    // be in the `error` property.\n    this.onComplete = new Signal();\n    // Dispatched after this resource has had all the *after* middleware run on it.\n    this.onAfterMiddleware = new Signal();\n  }\n  /**\n   * Sets the load type to be used for a specific extension.\n   * @static\n   * @param {string} extname - The extension to set the type for, e.g. \"png\" or \"fnt\"\n   * @param {PIXI.LoaderResource.LOAD_TYPE} loadType - The load type to set it to.\n   */\n  LoaderResource.setExtensionLoadType = function (extname, loadType) {\n    setExtMap(LoaderResource._loadTypeMap, extname, loadType);\n  };\n  /**\n   * Sets the load type to be used for a specific extension.\n   * @static\n   * @param {string} extname - The extension to set the type for, e.g. \"png\" or \"fnt\"\n   * @param {PIXI.LoaderResource.XHR_RESPONSE_TYPE} xhrType - The xhr type to set it to.\n   */\n  LoaderResource.setExtensionXhrType = function (extname, xhrType) {\n    setExtMap(LoaderResource._xhrTypeMap, extname, xhrType);\n  };\n  Object.defineProperty(LoaderResource.prototype, \"isDataUrl\", {\n    /**\n     * When the resource starts to load.\n     * @memberof PIXI.LoaderResource\n     * @callback OnStartSignal\n     * @param {PIXI.Resource} resource - The resource that the event happened on.\n     */\n    /**\n     * When the resource reports loading progress.\n     * @memberof PIXI.LoaderResource\n     * @callback OnProgressSignal\n     * @param {PIXI.Resource} resource - The resource that the event happened on.\n     * @param {number} percentage - The progress of the load in the range [0, 1].\n     */\n    /**\n     * When the resource finishes loading.\n     * @memberof PIXI.LoaderResource\n     * @callback OnCompleteSignal\n     * @param {PIXI.Resource} resource - The resource that the event happened on.\n     */\n    /**\n     * @memberof PIXI.LoaderResource\n     * @typedef {object} IMetadata\n     * @property {HTMLImageElement|HTMLAudioElement|HTMLVideoElement} [loadElement=null] - The\n     *      element to use for loading, instead of creating one.\n     * @property {boolean} [skipSource=false] - Skips adding source(s) to the load element. This\n     *      is useful if you want to pass in a `loadElement` that you already added load sources to.\n     * @property {string|string[]} [mimeType] - The mime type to use for the source element\n     *      of a video/audio elment. If the urls are an array, you can pass this as an array as well\n     *      where each index is the mime type to use for the corresponding url index.\n     */\n    /**\n     * Stores whether or not this url is a data url.\n     * @readonly\n     * @member {boolean}\n     */\n    get: function () {\n      return this._hasFlag(LoaderResource.STATUS_FLAGS.DATA_URL);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(LoaderResource.prototype, \"isComplete\", {\n    /**\n     * Describes if this resource has finished loading. Is true when the resource has completely\n     * loaded.\n     * @readonly\n     * @member {boolean}\n     */\n    get: function () {\n      return this._hasFlag(LoaderResource.STATUS_FLAGS.COMPLETE);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(LoaderResource.prototype, \"isLoading\", {\n    /**\n     * Describes if this resource is currently loading. Is true when the resource starts loading,\n     * and is false again when complete.\n     * @readonly\n     * @member {boolean}\n     */\n    get: function () {\n      return this._hasFlag(LoaderResource.STATUS_FLAGS.LOADING);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /** Marks the resource as complete. */\n  LoaderResource.prototype.complete = function () {\n    this._clearEvents();\n    this._finish();\n  };\n  /**\n   * Aborts the loading of this resource, with an optional message.\n   * @param {string} message - The message to use for the error\n   */\n  LoaderResource.prototype.abort = function (message) {\n    // abort can be called multiple times, ignore subsequent calls.\n    if (this.error) {\n      return;\n    }\n    // store error\n    this.error = new Error(message);\n    // clear events before calling aborts\n    this._clearEvents();\n    // abort the actual loading\n    if (this.xhr) {\n      this.xhr.abort();\n    } else if (this.xdr) {\n      this.xdr.abort();\n    } else if (this.data) {\n      // single source\n      if (this.data.src) {\n        this.data.src = LoaderResource.EMPTY_GIF;\n      }\n      // multi-source\n      else {\n        while (this.data.firstChild) {\n          this.data.removeChild(this.data.firstChild);\n        }\n      }\n    }\n    // done now.\n    this._finish();\n  };\n  /**\n   * Kicks off loading of this resource. This method is asynchronous.\n   * @param {PIXI.LoaderResource.OnCompleteSignal} [cb] - Optional callback to call once the resource is loaded.\n   */\n  LoaderResource.prototype.load = function (cb) {\n    var _this = this;\n    if (this.isLoading) {\n      return;\n    }\n    if (this.isComplete) {\n      if (cb) {\n        setTimeout(function () {\n          return cb(_this);\n        }, 1);\n      }\n      return;\n    } else if (cb) {\n      this.onComplete.once(cb);\n    }\n    this._setFlag(LoaderResource.STATUS_FLAGS.LOADING, true);\n    this.onStart.dispatch(this);\n    // if unset, determine the value\n    if (this.crossOrigin === false || typeof this.crossOrigin !== 'string') {\n      this.crossOrigin = this._determineCrossOrigin(this.url);\n    }\n    switch (this.loadType) {\n      case LoaderResource.LOAD_TYPE.IMAGE:\n        this.type = LoaderResource.TYPE.IMAGE;\n        this._loadElement('image');\n        break;\n      case LoaderResource.LOAD_TYPE.AUDIO:\n        this.type = LoaderResource.TYPE.AUDIO;\n        this._loadSourceElement('audio');\n        break;\n      case LoaderResource.LOAD_TYPE.VIDEO:\n        this.type = LoaderResource.TYPE.VIDEO;\n        this._loadSourceElement('video');\n        break;\n      case LoaderResource.LOAD_TYPE.XHR:\n      /* falls through */\n      default:\n        if (typeof useXdr === 'undefined') {\n          useXdr = !!(globalThis.XDomainRequest && !('withCredentials' in new XMLHttpRequest()));\n        }\n        if (useXdr && this.crossOrigin) {\n          this._loadXdr();\n        } else {\n          this._loadXhr();\n        }\n        break;\n    }\n  };\n  /**\n   * Checks if the flag is set.\n   * @param flag - The flag to check.\n   * @returns True if the flag is set.\n   */\n  LoaderResource.prototype._hasFlag = function (flag) {\n    return (this._flags & flag) !== 0;\n  };\n  /**\n   * (Un)Sets the flag.\n   * @param flag - The flag to (un)set.\n   * @param value - Whether to set or (un)set the flag.\n   */\n  LoaderResource.prototype._setFlag = function (flag, value) {\n    this._flags = value ? this._flags | flag : this._flags & ~flag;\n  };\n  /** Clears all the events from the underlying loading source. */\n  LoaderResource.prototype._clearEvents = function () {\n    clearTimeout(this._elementTimer);\n    if (this.data && this.data.removeEventListener) {\n      this.data.removeEventListener('error', this._boundOnError, false);\n      this.data.removeEventListener('load', this._boundComplete, false);\n      this.data.removeEventListener('progress', this._boundOnProgress, false);\n      this.data.removeEventListener('canplaythrough', this._boundComplete, false);\n    }\n    if (this.xhr) {\n      if (this.xhr.removeEventListener) {\n        this.xhr.removeEventListener('error', this._boundXhrOnError, false);\n        this.xhr.removeEventListener('timeout', this._boundXhrOnTimeout, false);\n        this.xhr.removeEventListener('abort', this._boundXhrOnAbort, false);\n        this.xhr.removeEventListener('progress', this._boundOnProgress, false);\n        this.xhr.removeEventListener('load', this._boundXhrOnLoad, false);\n      } else {\n        this.xhr.onerror = null;\n        this.xhr.ontimeout = null;\n        this.xhr.onprogress = null;\n        this.xhr.onload = null;\n      }\n    }\n  };\n  /** Finalizes the load. */\n  LoaderResource.prototype._finish = function () {\n    if (this.isComplete) {\n      throw new Error('Complete called again for an already completed resource.');\n    }\n    this._setFlag(LoaderResource.STATUS_FLAGS.COMPLETE, true);\n    this._setFlag(LoaderResource.STATUS_FLAGS.LOADING, false);\n    this.onComplete.dispatch(this);\n  };\n  /**\n   * Loads this resources using an element that has a single source,\n   * like an HTMLImageElement.\n   * @private\n   * @param type - The type of element to use.\n   */\n  LoaderResource.prototype._loadElement = function (type) {\n    if (this.metadata.loadElement) {\n      this.data = this.metadata.loadElement;\n    } else if (type === 'image' && typeof globalThis.Image !== 'undefined') {\n      this.data = new Image();\n    } else {\n      this.data = document.createElement(type);\n    }\n    if (this.crossOrigin) {\n      this.data.crossOrigin = this.crossOrigin;\n    }\n    if (!this.metadata.skipSource) {\n      this.data.src = this.url;\n    }\n    this.data.addEventListener('error', this._boundOnError, false);\n    this.data.addEventListener('load', this._boundComplete, false);\n    this.data.addEventListener('progress', this._boundOnProgress, false);\n    if (this.timeout) {\n      this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout);\n    }\n  };\n  /**\n   * Loads this resources using an element that has multiple sources,\n   * like an HTMLAudioElement or HTMLVideoElement.\n   * @param type - The type of element to use.\n   */\n  LoaderResource.prototype._loadSourceElement = function (type) {\n    if (this.metadata.loadElement) {\n      this.data = this.metadata.loadElement;\n    } else if (type === 'audio' && typeof globalThis.Audio !== 'undefined') {\n      this.data = new Audio();\n    } else {\n      this.data = document.createElement(type);\n    }\n    if (this.data === null) {\n      this.abort(\"Unsupported element: \" + type);\n      return;\n    }\n    if (this.crossOrigin) {\n      this.data.crossOrigin = this.crossOrigin;\n    }\n    if (!this.metadata.skipSource) {\n      // support for CocoonJS Canvas+ runtime, lacks document.createElement('source')\n      if (navigator.isCocoonJS) {\n        this.data.src = Array.isArray(this.url) ? this.url[0] : this.url;\n      } else if (Array.isArray(this.url)) {\n        var mimeTypes = this.metadata.mimeType;\n        for (var i = 0; i < this.url.length; ++i) {\n          this.data.appendChild(this._createSource(type, this.url[i], Array.isArray(mimeTypes) ? mimeTypes[i] : mimeTypes));\n        }\n      } else {\n        var mimeTypes = this.metadata.mimeType;\n        this.data.appendChild(this._createSource(type, this.url, Array.isArray(mimeTypes) ? mimeTypes[0] : mimeTypes));\n      }\n    }\n    this.data.addEventListener('error', this._boundOnError, false);\n    this.data.addEventListener('load', this._boundComplete, false);\n    this.data.addEventListener('progress', this._boundOnProgress, false);\n    this.data.addEventListener('canplaythrough', this._boundComplete, false);\n    this.data.load();\n    if (this.timeout) {\n      this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout);\n    }\n  };\n  /** Loads this resources using an XMLHttpRequest. */\n  LoaderResource.prototype._loadXhr = function () {\n    // if unset, determine the value\n    if (typeof this.xhrType !== 'string') {\n      this.xhrType = this._determineXhrType();\n    }\n    var xhr = this.xhr = new XMLHttpRequest();\n    // send credentials when crossOrigin with credentials requested\n    if (this.crossOrigin === 'use-credentials') {\n      xhr.withCredentials = true;\n    }\n    // set the request type and url\n    xhr.open('GET', this.url, true);\n    xhr.timeout = this.timeout;\n    // load json as text and parse it ourselves. We do this because some browsers\n    // *cough* safari *cough* can't deal with it.\n    if (this.xhrType === LoaderResource.XHR_RESPONSE_TYPE.JSON || this.xhrType === LoaderResource.XHR_RESPONSE_TYPE.DOCUMENT) {\n      xhr.responseType = LoaderResource.XHR_RESPONSE_TYPE.TEXT;\n    } else {\n      xhr.responseType = this.xhrType;\n    }\n    xhr.addEventListener('error', this._boundXhrOnError, false);\n    xhr.addEventListener('timeout', this._boundXhrOnTimeout, false);\n    xhr.addEventListener('abort', this._boundXhrOnAbort, false);\n    xhr.addEventListener('progress', this._boundOnProgress, false);\n    xhr.addEventListener('load', this._boundXhrOnLoad, false);\n    xhr.send();\n  };\n  /** Loads this resources using an XDomainRequest. This is here because we need to support IE9 (gross). */\n  LoaderResource.prototype._loadXdr = function () {\n    // if unset, determine the value\n    if (typeof this.xhrType !== 'string') {\n      this.xhrType = this._determineXhrType();\n    }\n    var xdr = this.xhr = new globalThis.XDomainRequest(); // eslint-disable-line no-undef\n    // XDomainRequest has a few quirks. Occasionally it will abort requests\n    // A way to avoid this is to make sure ALL callbacks are set even if not used\n    // More info here: http://stackoverflow.com/questions/15786966/xdomainrequest-aborts-post-on-ie-9\n    xdr.timeout = this.timeout || 5000; // XDR needs a timeout value or it breaks in IE9\n    xdr.onerror = this._boundXhrOnError;\n    xdr.ontimeout = this._boundXhrOnTimeout;\n    xdr.onprogress = this._boundOnProgress;\n    xdr.onload = this._boundXhrOnLoad;\n    xdr.open('GET', this.url, true);\n    // Note: The xdr.send() call is wrapped in a timeout to prevent an\n    // issue with the interface where some requests are lost if multiple\n    // XDomainRequests are being sent at the same time.\n    // Some info here: https://github.com/photonstorm/phaser/issues/1248\n    setTimeout(function () {\n      return xdr.send();\n    }, 1);\n  };\n  /**\n   * Creates a source used in loading via an element.\n   * @param type - The element type (video or audio).\n   * @param url - The source URL to load from.\n   * @param [mime] - The mime type of the video\n   * @returns The source element.\n   */\n  LoaderResource.prototype._createSource = function (type, url, mime) {\n    if (!mime) {\n      mime = type + \"/\" + this._getExtension(url);\n    }\n    var source = document.createElement('source');\n    source.src = url;\n    source.type = mime;\n    return source;\n  };\n  /**\n   * Called if a load errors out.\n   * @param event - The error event from the element that emits it.\n   */\n  LoaderResource.prototype._onError = function (event) {\n    this.abort(\"Failed to load element using: \" + event.target.nodeName);\n  };\n  /**\n   * Called if a load progress event fires for an element or xhr/xdr.\n   * @param event - Progress event.\n   */\n  LoaderResource.prototype._onProgress = function (event) {\n    if (event && event.lengthComputable) {\n      this.onProgress.dispatch(this, event.loaded / event.total);\n    }\n  };\n  /** Called if a timeout event fires for an element. */\n  LoaderResource.prototype._onTimeout = function () {\n    this.abort(\"Load timed out.\");\n  };\n  /** Called if an error event fires for xhr/xdr. */\n  LoaderResource.prototype._xhrOnError = function () {\n    var xhr = this.xhr;\n    this.abort(reqType(xhr) + \" Request failed. Status: \" + xhr.status + \", text: \\\"\" + xhr.statusText + \"\\\"\");\n  };\n  /** Called if an error event fires for xhr/xdr. */\n  LoaderResource.prototype._xhrOnTimeout = function () {\n    var xhr = this.xhr;\n    this.abort(reqType(xhr) + \" Request timed out.\");\n  };\n  /** Called if an abort event fires for xhr/xdr. */\n  LoaderResource.prototype._xhrOnAbort = function () {\n    var xhr = this.xhr;\n    this.abort(reqType(xhr) + \" Request was aborted by the user.\");\n  };\n  /** Called when data successfully loads from an xhr/xdr request. */\n  LoaderResource.prototype._xhrOnLoad = function () {\n    var xhr = this.xhr;\n    var text = '';\n    var status = typeof xhr.status === 'undefined' ? STATUS_OK : xhr.status; // XDR has no `.status`, assume 200.\n    // responseText is accessible only if responseType is '' or 'text' and on older browsers\n    if (xhr.responseType === '' || xhr.responseType === 'text' || typeof xhr.responseType === 'undefined') {\n      text = xhr.responseText;\n    }\n    // status can be 0 when using the `file://` protocol so we also check if a response is set.\n    // If it has a response, we assume 200; otherwise a 0 status code with no contents is an aborted request.\n    if (status === STATUS_NONE && (text.length > 0 || xhr.responseType === LoaderResource.XHR_RESPONSE_TYPE.BUFFER)) {\n      status = STATUS_OK;\n    }\n    // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request\n    else if (status === STATUS_IE_BUG_EMPTY) {\n      status = STATUS_EMPTY;\n    }\n    var statusType = status / 100 | 0;\n    if (statusType === STATUS_TYPE_OK) {\n      // if text, just return it\n      if (this.xhrType === LoaderResource.XHR_RESPONSE_TYPE.TEXT) {\n        this.data = text;\n        this.type = LoaderResource.TYPE.TEXT;\n      }\n      // if json, parse into json object\n      else if (this.xhrType === LoaderResource.XHR_RESPONSE_TYPE.JSON) {\n        try {\n          this.data = JSON.parse(text);\n          this.type = LoaderResource.TYPE.JSON;\n        } catch (e) {\n          this.abort(\"Error trying to parse loaded json: \" + e);\n          return;\n        }\n      }\n      // if xml, parse into an xml document or div element\n      else if (this.xhrType === LoaderResource.XHR_RESPONSE_TYPE.DOCUMENT) {\n        try {\n          if (globalThis.DOMParser) {\n            var domparser = new DOMParser();\n            this.data = domparser.parseFromString(text, 'text/xml');\n          } else {\n            var div = document.createElement('div');\n            div.innerHTML = text;\n            this.data = div;\n          }\n          this.type = LoaderResource.TYPE.XML;\n        } catch (e$1) {\n          this.abort(\"Error trying to parse loaded xml: \" + e$1);\n          return;\n        }\n      }\n      // other types just return the response\n      else {\n        this.data = xhr.response || text;\n      }\n    } else {\n      this.abort(\"[\" + xhr.status + \"] \" + xhr.statusText + \": \" + xhr.responseURL);\n      return;\n    }\n    this.complete();\n  };\n  /**\n   * Sets the `crossOrigin` property for this resource based on if the url\n   * for this resource is cross-origin. If crossOrigin was manually set, this\n   * function does nothing.\n   * @private\n   * @param url - The url to test.\n   * @param [loc=globalThis.location] - The location object to test against.\n   * @returns The crossOrigin value to use (or empty string for none).\n   */\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n  LoaderResource.prototype._determineCrossOrigin = function (url, loc) {\n    // data: and javascript: urls are considered same-origin\n    if (url.indexOf('data:') === 0) {\n      return '';\n    }\n    // A sandboxed iframe without the 'allow-same-origin' attribute will have a special\n    // origin designed not to match globalThis.location.origin, and will always require\n    // crossOrigin requests regardless of whether the location matches.\n    if (globalThis.origin !== globalThis.location.origin) {\n      return 'anonymous';\n    }\n    // default is globalThis.location\n    loc = loc || globalThis.location;\n    if (!tempAnchor) {\n      tempAnchor = document.createElement('a');\n    }\n    // let the browser determine the full href for the url of this resource and then\n    // parse with the node url lib, we can't use the properties of the anchor element\n    // because they don't work in IE9 :(\n    tempAnchor.href = url;\n    var parsedUrl = parseUri(tempAnchor.href, {\n      strictMode: true\n    });\n    var samePort = !parsedUrl.port && loc.port === '' || parsedUrl.port === loc.port;\n    var protocol = parsedUrl.protocol ? parsedUrl.protocol + \":\" : '';\n    // if cross origin\n    if (parsedUrl.host !== loc.hostname || !samePort || protocol !== loc.protocol) {\n      return 'anonymous';\n    }\n    return '';\n  };\n  /**\n   * Determines the responseType of an XHR request based on the extension of the\n   * resource being loaded.\n   * @private\n   * @returns {PIXI.LoaderResource.XHR_RESPONSE_TYPE} The responseType to use.\n   */\n  LoaderResource.prototype._determineXhrType = function () {\n    return LoaderResource._xhrTypeMap[this.extension] || LoaderResource.XHR_RESPONSE_TYPE.TEXT;\n  };\n  /**\n   * Determines the loadType of a resource based on the extension of the\n   * resource being loaded.\n   * @private\n   * @returns {PIXI.LoaderResource.LOAD_TYPE} The loadType to use.\n   */\n  LoaderResource.prototype._determineLoadType = function () {\n    return LoaderResource._loadTypeMap[this.extension] || LoaderResource.LOAD_TYPE.XHR;\n  };\n  /**\n   * Extracts the extension (sans '.') of the file being loaded by the resource.\n   * @param [url] - url to parse, `this.url` by default.\n   * @returns The extension.\n   */\n  LoaderResource.prototype._getExtension = function (url) {\n    if (url === void 0) {\n      url = this.url;\n    }\n    var ext = '';\n    if (this.isDataUrl) {\n      var slashIndex = url.indexOf('/');\n      ext = url.substring(slashIndex + 1, url.indexOf(';', slashIndex));\n    } else {\n      var queryStart = url.indexOf('?');\n      var hashStart = url.indexOf('#');\n      var index = Math.min(queryStart > -1 ? queryStart : url.length, hashStart > -1 ? hashStart : url.length);\n      url = url.substring(0, index);\n      ext = url.substring(url.lastIndexOf('.') + 1);\n    }\n    return ext.toLowerCase();\n  };\n  /**\n   * Determines the mime type of an XHR request based on the responseType of\n   * resource being loaded.\n   * @param type - The type to get a mime type for.\n   * @private\n   * @returns The mime type to use.\n   */\n  LoaderResource.prototype._getMimeFromXhrType = function (type) {\n    switch (type) {\n      case LoaderResource.XHR_RESPONSE_TYPE.BUFFER:\n        return 'application/octet-binary';\n      case LoaderResource.XHR_RESPONSE_TYPE.BLOB:\n        return 'application/blob';\n      case LoaderResource.XHR_RESPONSE_TYPE.DOCUMENT:\n        return 'application/xml';\n      case LoaderResource.XHR_RESPONSE_TYPE.JSON:\n        return 'application/json';\n      case LoaderResource.XHR_RESPONSE_TYPE.DEFAULT:\n      case LoaderResource.XHR_RESPONSE_TYPE.TEXT:\n      /* falls through */\n      default:\n        return 'text/plain';\n    }\n  };\n  return LoaderResource;\n}();\n// eslint-disable-next-line @typescript-eslint/no-namespace\n(function (LoaderResource) {\n  (function (STATUS_FLAGS) {\n    /** None */\n    STATUS_FLAGS[STATUS_FLAGS[\"NONE\"] = 0] = \"NONE\";\n    /** Data URL */\n    STATUS_FLAGS[STATUS_FLAGS[\"DATA_URL\"] = 1] = \"DATA_URL\";\n    /** Complete */\n    STATUS_FLAGS[STATUS_FLAGS[\"COMPLETE\"] = 2] = \"COMPLETE\";\n    /** Loading */\n    STATUS_FLAGS[STATUS_FLAGS[\"LOADING\"] = 4] = \"LOADING\";\n  })(LoaderResource.STATUS_FLAGS || (LoaderResource.STATUS_FLAGS = {}));\n  (function (TYPE) {\n    /** Unknown */\n    TYPE[TYPE[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n    /** JSON */\n    TYPE[TYPE[\"JSON\"] = 1] = \"JSON\";\n    /** XML */\n    TYPE[TYPE[\"XML\"] = 2] = \"XML\";\n    /** Image */\n    TYPE[TYPE[\"IMAGE\"] = 3] = \"IMAGE\";\n    /** Audio */\n    TYPE[TYPE[\"AUDIO\"] = 4] = \"AUDIO\";\n    /** Video */\n    TYPE[TYPE[\"VIDEO\"] = 5] = \"VIDEO\";\n    /** Plain text */\n    TYPE[TYPE[\"TEXT\"] = 6] = \"TEXT\";\n  })(LoaderResource.TYPE || (LoaderResource.TYPE = {}));\n  (function (LOAD_TYPE) {\n    /** Uses XMLHttpRequest to load the resource. */\n    LOAD_TYPE[LOAD_TYPE[\"XHR\"] = 1] = \"XHR\";\n    /** Uses an `Image` object to load the resource. */\n    LOAD_TYPE[LOAD_TYPE[\"IMAGE\"] = 2] = \"IMAGE\";\n    /** Uses an `Audio` object to load the resource. */\n    LOAD_TYPE[LOAD_TYPE[\"AUDIO\"] = 3] = \"AUDIO\";\n    /** Uses a `Video` object to load the resource. */\n    LOAD_TYPE[LOAD_TYPE[\"VIDEO\"] = 4] = \"VIDEO\";\n  })(LoaderResource.LOAD_TYPE || (LoaderResource.LOAD_TYPE = {}));\n  (function (XHR_RESPONSE_TYPE) {\n    /** string */\n    XHR_RESPONSE_TYPE[\"DEFAULT\"] = \"text\";\n    /** ArrayBuffer */\n    XHR_RESPONSE_TYPE[\"BUFFER\"] = \"arraybuffer\";\n    /** Blob */\n    XHR_RESPONSE_TYPE[\"BLOB\"] = \"blob\";\n    /** Document */\n    XHR_RESPONSE_TYPE[\"DOCUMENT\"] = \"document\";\n    /** Object */\n    XHR_RESPONSE_TYPE[\"JSON\"] = \"json\";\n    /** String */\n    XHR_RESPONSE_TYPE[\"TEXT\"] = \"text\";\n  })(LoaderResource.XHR_RESPONSE_TYPE || (LoaderResource.XHR_RESPONSE_TYPE = {}));\n  LoaderResource._loadTypeMap = {\n    // images\n    gif: LoaderResource.LOAD_TYPE.IMAGE,\n    png: LoaderResource.LOAD_TYPE.IMAGE,\n    bmp: LoaderResource.LOAD_TYPE.IMAGE,\n    jpg: LoaderResource.LOAD_TYPE.IMAGE,\n    jpeg: LoaderResource.LOAD_TYPE.IMAGE,\n    tif: LoaderResource.LOAD_TYPE.IMAGE,\n    tiff: LoaderResource.LOAD_TYPE.IMAGE,\n    webp: LoaderResource.LOAD_TYPE.IMAGE,\n    tga: LoaderResource.LOAD_TYPE.IMAGE,\n    avif: LoaderResource.LOAD_TYPE.IMAGE,\n    svg: LoaderResource.LOAD_TYPE.IMAGE,\n    'svg+xml': LoaderResource.LOAD_TYPE.IMAGE,\n    // audio\n    mp3: LoaderResource.LOAD_TYPE.AUDIO,\n    ogg: LoaderResource.LOAD_TYPE.AUDIO,\n    wav: LoaderResource.LOAD_TYPE.AUDIO,\n    // videos\n    mp4: LoaderResource.LOAD_TYPE.VIDEO,\n    webm: LoaderResource.LOAD_TYPE.VIDEO\n  };\n  LoaderResource._xhrTypeMap = {\n    // xml\n    xhtml: LoaderResource.XHR_RESPONSE_TYPE.DOCUMENT,\n    html: LoaderResource.XHR_RESPONSE_TYPE.DOCUMENT,\n    htm: LoaderResource.XHR_RESPONSE_TYPE.DOCUMENT,\n    xml: LoaderResource.XHR_RESPONSE_TYPE.DOCUMENT,\n    tmx: LoaderResource.XHR_RESPONSE_TYPE.DOCUMENT,\n    svg: LoaderResource.XHR_RESPONSE_TYPE.DOCUMENT,\n    // This was added to handle Tiled Tileset XML, but .tsx is also a TypeScript React Component.\n    // Since it is way less likely for people to be loading TypeScript files instead of Tiled files,\n    // this should probably be fine.\n    tsx: LoaderResource.XHR_RESPONSE_TYPE.DOCUMENT,\n    // images\n    gif: LoaderResource.XHR_RESPONSE_TYPE.BLOB,\n    png: LoaderResource.XHR_RESPONSE_TYPE.BLOB,\n    bmp: LoaderResource.XHR_RESPONSE_TYPE.BLOB,\n    jpg: LoaderResource.XHR_RESPONSE_TYPE.BLOB,\n    jpeg: LoaderResource.XHR_RESPONSE_TYPE.BLOB,\n    tif: LoaderResource.XHR_RESPONSE_TYPE.BLOB,\n    tiff: LoaderResource.XHR_RESPONSE_TYPE.BLOB,\n    webp: LoaderResource.XHR_RESPONSE_TYPE.BLOB,\n    tga: LoaderResource.XHR_RESPONSE_TYPE.BLOB,\n    avif: LoaderResource.XHR_RESPONSE_TYPE.BLOB,\n    // json\n    json: LoaderResource.XHR_RESPONSE_TYPE.JSON,\n    // text\n    text: LoaderResource.XHR_RESPONSE_TYPE.TEXT,\n    txt: LoaderResource.XHR_RESPONSE_TYPE.TEXT,\n    // fonts\n    ttf: LoaderResource.XHR_RESPONSE_TYPE.BUFFER,\n    otf: LoaderResource.XHR_RESPONSE_TYPE.BUFFER\n  };\n  // We can't set the `src` attribute to empty string, so on abort we set it to this 1px transparent gif\n  LoaderResource.EMPTY_GIF = 'data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==';\n})(LoaderResource || (LoaderResource = {}));\n\n/**\n * Smaller version of the async library constructs.\n * @ignore\n */\nfunction _noop() {}\n/**\n * Ensures a function is only called once.\n * @ignore\n * @param {Function} fn - The function to wrap.\n * @returns {Function} The wrapping function.\n */\nfunction onlyOnce(fn) {\n  return function onceWrapper() {\n    var arguments$1 = arguments;\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments$1[_i];\n    }\n    if (fn === null) {\n      throw new Error('Callback was already called.');\n    }\n    var callFn = fn;\n    fn = null;\n    callFn.apply(this, args);\n  };\n}\n/**\n * @private\n * @memberof PIXI\n */\nvar AsyncQueueItem = /** @class */function () {\n  /**\n   * @param data\n   * @param callback\n   * @private\n   */\n  function AsyncQueueItem(data, callback) {\n    this.data = data;\n    this.callback = callback;\n  }\n  return AsyncQueueItem;\n}();\n/**\n * @private\n * @memberof PIXI\n */\nvar AsyncQueue = /** @class */function () {\n  /**\n   * @param worker\n   * @param concurrency\n   * @private\n   */\n  function AsyncQueue(worker, concurrency) {\n    var _this = this;\n    if (concurrency === void 0) {\n      concurrency = 1;\n    }\n    this.workers = 0;\n    this.saturated = _noop;\n    this.unsaturated = _noop;\n    this.empty = _noop;\n    this.drain = _noop;\n    this.error = _noop;\n    this.started = false;\n    this.paused = false;\n    this._tasks = [];\n    this._insert = function (data, insertAtFront, callback) {\n      if (callback && typeof callback !== 'function') {\n        throw new Error('task callback must be a function');\n      }\n      _this.started = true;\n      // eslint-disable-next-line no-eq-null,eqeqeq\n      if (data == null && _this.idle()) {\n        // call drain immediately if there are no tasks\n        setTimeout(function () {\n          return _this.drain();\n        }, 1);\n        return;\n      }\n      var item = new AsyncQueueItem(data, typeof callback === 'function' ? callback : _noop);\n      if (insertAtFront) {\n        _this._tasks.unshift(item);\n      } else {\n        _this._tasks.push(item);\n      }\n      setTimeout(_this.process, 1);\n    };\n    this.process = function () {\n      while (!_this.paused && _this.workers < _this.concurrency && _this._tasks.length) {\n        var task = _this._tasks.shift();\n        if (_this._tasks.length === 0) {\n          _this.empty();\n        }\n        _this.workers += 1;\n        if (_this.workers === _this.concurrency) {\n          _this.saturated();\n        }\n        _this._worker(task.data, onlyOnce(_this._next(task)));\n      }\n    };\n    this._worker = worker;\n    if (concurrency === 0) {\n      throw new Error('Concurrency must not be zero');\n    }\n    this.concurrency = concurrency;\n    this.buffer = concurrency / 4.0;\n  }\n  /**\n   * @param task\n   * @private\n   */\n  AsyncQueue.prototype._next = function (task) {\n    var _this = this;\n    return function () {\n      var arguments$1 = arguments;\n      var args = [];\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments$1[_i];\n      }\n      _this.workers -= 1;\n      task.callback.apply(task, args);\n      // eslint-disable-next-line no-eq-null,eqeqeq\n      if (args[0] != null) {\n        _this.error(args[0], task.data);\n      }\n      if (_this.workers <= _this.concurrency - _this.buffer) {\n        _this.unsaturated();\n      }\n      if (_this.idle()) {\n        _this.drain();\n      }\n      _this.process();\n    };\n  };\n  // That was in object\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n  AsyncQueue.prototype.push = function (data, callback) {\n    this._insert(data, false, callback);\n  };\n  AsyncQueue.prototype.kill = function () {\n    this.workers = 0;\n    this.drain = _noop;\n    this.started = false;\n    this._tasks = [];\n  };\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n  AsyncQueue.prototype.unshift = function (data, callback) {\n    this._insert(data, true, callback);\n  };\n  AsyncQueue.prototype.length = function () {\n    return this._tasks.length;\n  };\n  AsyncQueue.prototype.running = function () {\n    return this.workers;\n  };\n  AsyncQueue.prototype.idle = function () {\n    return this._tasks.length + this.workers === 0;\n  };\n  AsyncQueue.prototype.pause = function () {\n    if (this.paused === true) {\n      return;\n    }\n    this.paused = true;\n  };\n  AsyncQueue.prototype.resume = function () {\n    if (this.paused === false) {\n      return;\n    }\n    this.paused = false;\n    // Need to call this.process once per concurrent\n    // worker to preserve full concurrency after pause\n    for (var w = 1; w <= this.concurrency; w++) {\n      this.process();\n    }\n  };\n  /**\n   * Iterates an array in series.\n   * @param {Array.<*>} array - Array to iterate.\n   * @param {Function} iterator - Function to call for each element.\n   * @param {Function} callback - Function to call when done, or on error.\n   * @param {boolean} [deferNext=false] - Break synchronous each loop by calling next with a setTimeout of 1.\n   */\n  AsyncQueue.eachSeries = function (array, iterator, callback, deferNext) {\n    var i = 0;\n    var len = array.length;\n    function next(err) {\n      if (err || i === len) {\n        if (callback) {\n          callback(err);\n        }\n        return;\n      }\n      if (deferNext) {\n        setTimeout(function () {\n          iterator(array[i++], next);\n        }, 1);\n      } else {\n        iterator(array[i++], next);\n      }\n    }\n    next();\n  };\n  /**\n   * Async queue implementation,\n   * @param {Function} worker - The worker function to call for each task.\n   * @param {number} concurrency - How many workers to run in parrallel.\n   * @returns {*} The async queue object.\n   */\n  AsyncQueue.queue = function (worker, concurrency) {\n    return new AsyncQueue(worker, concurrency);\n  };\n  return AsyncQueue;\n}();\n\n// some constants\nvar MAX_PROGRESS = 100;\nvar rgxExtractUrlHash = /(#[\\w-]+)?$/;\n/**\n * The new loader, forked from Resource Loader by Chad Engler: https://github.com/englercj/resource-loader\n *\n * ```js\n * const loader = PIXI.Loader.shared; // PixiJS exposes a premade instance for you to use.\n * // or\n * const loader = new PIXI.Loader(); // You can also create your own if you want\n *\n * const sprites = {};\n *\n * // Chainable `add` to enqueue a resource\n * loader.add('bunny', 'data/bunny.png')\n *       .add('spaceship', 'assets/spritesheet.json');\n * loader.add('scoreFont', 'assets/score.fnt');\n *\n * // Chainable `pre` to add a middleware that runs for each resource, *before* loading that resource.\n * // This is useful to implement custom caching modules (using filesystem, indexeddb, memory, etc).\n * loader.pre(cachingMiddleware);\n *\n * // Chainable `use` to add a middleware that runs for each resource, *after* loading that resource.\n * // This is useful to implement custom parsing modules (like spritesheet parsers, spine parser, etc).\n * loader.use(parsingMiddleware);\n *\n * // The `load` method loads the queue of resources, and calls the passed in callback called once all\n * // resources have loaded.\n * loader.load((loader, resources) => {\n *     // resources is an object where the key is the name of the resource loaded and the value is the resource object.\n *     // They have a couple default properties:\n *     // - `url`: The URL that the resource was loaded from\n *     // - `error`: The error that happened when trying to load (if any)\n *     // - `data`: The raw data that was loaded\n *     // also may contain other properties based on the middleware that runs.\n *     sprites.bunny = new PIXI.TilingSprite(resources.bunny.texture);\n *     sprites.spaceship = new PIXI.TilingSprite(resources.spaceship.texture);\n *     sprites.scoreFont = new PIXI.TilingSprite(resources.scoreFont.texture);\n * });\n *\n * // throughout the process multiple signals can be dispatched.\n * loader.onProgress.add(() => {}); // called once per loaded/errored file\n * loader.onError.add(() => {}); // called once per errored file\n * loader.onLoad.add(() => {}); // called once per loaded file\n * loader.onComplete.add(() => {}); // called once when the queued resources all load.\n * ```\n * @memberof PIXI\n */\nvar Loader = /** @class */function () {\n  /**\n   * @param baseUrl - The base url for all resources loaded by this loader.\n   * @param concurrency - The number of resources to load concurrently.\n   */\n  function Loader(baseUrl, concurrency) {\n    var _this = this;\n    if (baseUrl === void 0) {\n      baseUrl = '';\n    }\n    if (concurrency === void 0) {\n      concurrency = 10;\n    }\n    /** The progress percent of the loader going through the queue. */\n    this.progress = 0;\n    /** Loading state of the loader, true if it is currently loading resources. */\n    this.loading = false;\n    /**\n     * A querystring to append to every URL added to the loader.\n     *\n     * This should be a valid query string *without* the question-mark (`?`). The loader will\n     * also *not* escape values for you. Make sure to escape your parameters with\n     * [`encodeURIComponent`](https://mdn.io/encodeURIComponent) before assigning this property.\n     * @example\n     * const loader = new Loader();\n     *\n     * loader.defaultQueryString = 'user=me&password=secret';\n     *\n     * // This will request 'image.png?user=me&password=secret'\n     * loader.add('image.png').load();\n     *\n     * loader.reset();\n     *\n     * // This will request 'image.png?v=1&user=me&password=secret'\n     * loader.add('iamge.png?v=1').load();\n     */\n    this.defaultQueryString = '';\n    /** The middleware to run before loading each resource. */\n    this._beforeMiddleware = [];\n    /** The middleware to run after loading each resource. */\n    this._afterMiddleware = [];\n    /** The tracks the resources we are currently completing parsing for. */\n    this._resourcesParsing = [];\n    /**\n     * The `_loadResource` function bound with this object context.\n     * @param r - The resource to load\n     * @param d - The dequeue function\n     */\n    this._boundLoadResource = function (r, d) {\n      return _this._loadResource(r, d);\n    };\n    /** All the resources for this loader keyed by name. */\n    this.resources = {};\n    this.baseUrl = baseUrl;\n    this._beforeMiddleware = [];\n    this._afterMiddleware = [];\n    this._resourcesParsing = [];\n    this._boundLoadResource = function (r, d) {\n      return _this._loadResource(r, d);\n    };\n    this._queue = AsyncQueue.queue(this._boundLoadResource, concurrency);\n    this._queue.pause();\n    this.resources = {};\n    this.onProgress = new Signal();\n    this.onError = new Signal();\n    this.onLoad = new Signal();\n    this.onStart = new Signal();\n    this.onComplete = new Signal();\n    for (var i = 0; i < Loader._plugins.length; ++i) {\n      var plugin = Loader._plugins[i];\n      var pre = plugin.pre,\n        use = plugin.use;\n      if (pre) {\n        this.pre(pre);\n      }\n      if (use) {\n        this.use(use);\n      }\n    }\n    this._protected = false;\n  }\n  /**\n   * Same as add, params have strict order\n   * @private\n   * @param name - The name of the resource to load.\n   * @param url - The url for this resource, relative to the baseUrl of this loader.\n   * @param options - The options for the load.\n   * @param callback - Function to call when this specific resource completes loading.\n   * @returns The loader itself.\n   */\n  Loader.prototype._add = function (name, url, options, callback) {\n    // if loading already you can only add resources that have a parent.\n    if (this.loading && (!options || !options.parentResource)) {\n      throw new Error('Cannot add resources while the loader is running.');\n    }\n    // check if resource already exists.\n    if (this.resources[name]) {\n      throw new Error(\"Resource named \\\"\" + name + \"\\\" already exists.\");\n    }\n    // add base url if this isn't an absolute url\n    url = this._prepareUrl(url);\n    // create the store the resource\n    this.resources[name] = new LoaderResource(name, url, options);\n    if (typeof callback === 'function') {\n      this.resources[name].onAfterMiddleware.once(callback);\n    }\n    // if actively loading, make sure to adjust progress chunks for that parent and its children\n    if (this.loading) {\n      var parent = options.parentResource;\n      var incompleteChildren = [];\n      for (var i = 0; i < parent.children.length; ++i) {\n        if (!parent.children[i].isComplete) {\n          incompleteChildren.push(parent.children[i]);\n        }\n      }\n      var fullChunk = parent.progressChunk * (incompleteChildren.length + 1); // +1 for parent\n      var eachChunk = fullChunk / (incompleteChildren.length + 2); // +2 for parent & new child\n      parent.children.push(this.resources[name]);\n      parent.progressChunk = eachChunk;\n      for (var i = 0; i < incompleteChildren.length; ++i) {\n        incompleteChildren[i].progressChunk = eachChunk;\n      }\n      this.resources[name].progressChunk = eachChunk;\n    }\n    // add the resource to the queue\n    this._queue.push(this.resources[name]);\n    return this;\n  };\n  /* eslint-enable require-jsdoc,valid-jsdoc */\n  /**\n   * Sets up a middleware function that will run *before* the\n   * resource is loaded.\n   * @param fn - The middleware function to register.\n   * @returns The loader itself.\n   */\n  Loader.prototype.pre = function (fn) {\n    this._beforeMiddleware.push(fn);\n    return this;\n  };\n  /**\n   * Sets up a middleware function that will run *after* the\n   * resource is loaded.\n   * @param fn - The middleware function to register.\n   * @returns The loader itself.\n   */\n  Loader.prototype.use = function (fn) {\n    this._afterMiddleware.push(fn);\n    return this;\n  };\n  /**\n   * Resets the queue of the loader to prepare for a new load.\n   * @returns The loader itself.\n   */\n  Loader.prototype.reset = function () {\n    this.progress = 0;\n    this.loading = false;\n    this._queue.kill();\n    this._queue.pause();\n    // abort all resource loads\n    for (var k in this.resources) {\n      var res = this.resources[k];\n      if (res._onLoadBinding) {\n        res._onLoadBinding.detach();\n      }\n      if (res.isLoading) {\n        res.abort('loader reset');\n      }\n    }\n    this.resources = {};\n    return this;\n  };\n  /**\n   * Starts loading the queued resources.\n   * @param cb - Optional callback that will be bound to the `complete` event.\n   * @returns The loader itself.\n   */\n  Loader.prototype.load = function (cb) {\n    deprecation('6.5.0', '@pixi/loaders is being replaced with @pixi/assets in the next major release.');\n    // register complete callback if they pass one\n    if (typeof cb === 'function') {\n      this.onComplete.once(cb);\n    }\n    // if the queue has already started we are done here\n    if (this.loading) {\n      return this;\n    }\n    if (this._queue.idle()) {\n      this._onStart();\n      this._onComplete();\n    } else {\n      // distribute progress chunks\n      var numTasks = this._queue._tasks.length;\n      var chunk = MAX_PROGRESS / numTasks;\n      for (var i = 0; i < this._queue._tasks.length; ++i) {\n        this._queue._tasks[i].data.progressChunk = chunk;\n      }\n      // notify we are starting\n      this._onStart();\n      // start loading\n      this._queue.resume();\n    }\n    return this;\n  };\n  Object.defineProperty(Loader.prototype, \"concurrency\", {\n    /**\n     * The number of resources to load concurrently.\n     * @default 10\n     */\n    get: function () {\n      return this._queue.concurrency;\n    },\n    set: function (concurrency) {\n      this._queue.concurrency = concurrency;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Prepares a url for usage based on the configuration of this object\n   * @param url - The url to prepare.\n   * @returns The prepared url.\n   */\n  Loader.prototype._prepareUrl = function (url) {\n    var parsedUrl = parseUri(url, {\n      strictMode: true\n    });\n    var result;\n    // absolute url, just use it as is.\n    if (parsedUrl.protocol || !parsedUrl.path || url.indexOf('//') === 0) {\n      result = url;\n    }\n    // if baseUrl doesn't end in slash and url doesn't start with slash, then add a slash inbetween\n    else if (this.baseUrl.length && this.baseUrl.lastIndexOf('/') !== this.baseUrl.length - 1 && url.charAt(0) !== '/') {\n      result = this.baseUrl + \"/\" + url;\n    } else {\n      result = this.baseUrl + url;\n    }\n    // if we need to add a default querystring, there is a bit more work\n    if (this.defaultQueryString) {\n      var hash = rgxExtractUrlHash.exec(result)[0];\n      result = result.slice(0, result.length - hash.length);\n      if (result.indexOf('?') !== -1) {\n        result += \"&\" + this.defaultQueryString;\n      } else {\n        result += \"?\" + this.defaultQueryString;\n      }\n      result += hash;\n    }\n    return result;\n  };\n  /**\n   * Loads a single resource.\n   * @param resource - The resource to load.\n   * @param dequeue - The function to call when we need to dequeue this item.\n   */\n  Loader.prototype._loadResource = function (resource, dequeue) {\n    var _this = this;\n    resource._dequeue = dequeue;\n    // run before middleware\n    AsyncQueue.eachSeries(this._beforeMiddleware, function (fn, next) {\n      fn.call(_this, resource, function () {\n        // if the before middleware marks the resource as complete,\n        // break and don't process any more before middleware\n        next(resource.isComplete ? {} : null);\n      });\n    }, function () {\n      if (resource.isComplete) {\n        _this._onLoad(resource);\n      } else {\n        resource._onLoadBinding = resource.onComplete.once(_this._onLoad, _this);\n        resource.load();\n      }\n    }, true);\n  };\n  /** Called once loading has started. */\n  Loader.prototype._onStart = function () {\n    this.progress = 0;\n    this.loading = true;\n    this.onStart.dispatch(this);\n  };\n  /** Called once each resource has loaded. */\n  Loader.prototype._onComplete = function () {\n    this.progress = MAX_PROGRESS;\n    this.loading = false;\n    this.onComplete.dispatch(this, this.resources);\n  };\n  /**\n   * Called each time a resources is loaded.\n   * @param resource - The resource that was loaded\n   */\n  Loader.prototype._onLoad = function (resource) {\n    var _this = this;\n    resource._onLoadBinding = null;\n    // remove this resource from the async queue, and add it to our list of resources that are being parsed\n    this._resourcesParsing.push(resource);\n    resource._dequeue();\n    // run all the after middleware for this resource\n    AsyncQueue.eachSeries(this._afterMiddleware, function (fn, next) {\n      fn.call(_this, resource, next);\n    }, function () {\n      resource.onAfterMiddleware.dispatch(resource);\n      _this.progress = Math.min(MAX_PROGRESS, _this.progress + resource.progressChunk);\n      _this.onProgress.dispatch(_this, resource);\n      if (resource.error) {\n        _this.onError.dispatch(resource.error, _this, resource);\n      } else {\n        _this.onLoad.dispatch(_this, resource);\n      }\n      _this._resourcesParsing.splice(_this._resourcesParsing.indexOf(resource), 1);\n      // do completion check\n      if (_this._queue.idle() && _this._resourcesParsing.length === 0) {\n        _this._onComplete();\n      }\n    }, true);\n  };\n  /** Destroy the loader, removes references. */\n  Loader.prototype.destroy = function () {\n    if (!this._protected) {\n      this.reset();\n    }\n  };\n  Object.defineProperty(Loader, \"shared\", {\n    /** A premade instance of the loader that can be used to load resources. */\n    get: function () {\n      var shared = Loader._shared;\n      if (!shared) {\n        shared = new Loader();\n        shared._protected = true;\n        Loader._shared = shared;\n      }\n      return shared;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Use the {@link PIXI.extensions.add} API to register plugins.\n   * @deprecated since 6.5.0\n   * @param plugin - The plugin to add\n   * @returns Reference to PIXI.Loader for chaining\n   */\n  Loader.registerPlugin = function (plugin) {\n    deprecation('6.5.0', 'Loader.registerPlugin() is deprecated, use extensions.add() instead.');\n    extensions.add({\n      type: ExtensionType.Loader,\n      ref: plugin\n    });\n    return Loader;\n  };\n  Loader._plugins = [];\n  return Loader;\n}();\nextensions.handleByList(ExtensionType.Loader, Loader._plugins);\nLoader.prototype.add = function add(name, url, options, callback) {\n  // special case of an array of objects or urls\n  if (Array.isArray(name)) {\n    for (var i = 0; i < name.length; ++i) {\n      this.add(name[i]);\n    }\n    return this;\n  }\n  // if an object is passed instead of params\n  if (typeof name === 'object') {\n    options = name;\n    callback = url || options.callback || options.onComplete;\n    url = options.url;\n    name = options.name || options.key || options.url;\n  }\n  // case where no name is passed shift all args over by one.\n  if (typeof url !== 'string') {\n    callback = options;\n    options = url;\n    url = name;\n  }\n  // now that we shifted make sure we have a proper url.\n  if (typeof url !== 'string') {\n    throw new Error('No url passed to add resource to loader.');\n  }\n  // options are optional so people might pass a function and no options\n  if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n  return this._add(name, url, options, callback);\n};\n\n/**\n * Application plugin for supporting loader option. Installing the LoaderPlugin\n * is not necessary if using **pixi.js** or **pixi.js-legacy**.\n * @example\n * import {AppLoaderPlugin} from '@pixi/loaders';\n * import {extensions} from '@pixi/core';\n * extensions.add(AppLoaderPlugin);\n * @memberof PIXI\n */\nvar AppLoaderPlugin = /** @class */function () {\n  function AppLoaderPlugin() {}\n  /**\n   * Called on application constructor\n   * @param options\n   * @private\n   */\n  AppLoaderPlugin.init = function (options) {\n    options = Object.assign({\n      sharedLoader: false\n    }, options);\n    this.loader = options.sharedLoader ? Loader.shared : new Loader();\n  };\n  /**\n   * Called when application destroyed\n   * @private\n   */\n  AppLoaderPlugin.destroy = function () {\n    if (this.loader) {\n      this.loader.destroy();\n      this.loader = null;\n    }\n  };\n  /** @ignore */\n  AppLoaderPlugin.extension = ExtensionType.Application;\n  return AppLoaderPlugin;\n}();\n\n/**\n * Loader plugin for handling Texture resources.\n * @memberof PIXI\n */\nvar TextureLoader = /** @class */function () {\n  function TextureLoader() {}\n  /** Handle SVG elements a text, render with SVGResource. */\n  TextureLoader.add = function () {\n    LoaderResource.setExtensionLoadType('svg', LoaderResource.LOAD_TYPE.XHR);\n    LoaderResource.setExtensionXhrType('svg', LoaderResource.XHR_RESPONSE_TYPE.TEXT);\n  };\n  /**\n   * Called after a resource is loaded.\n   * @see PIXI.Loader.loaderMiddleware\n   * @param resource\n   * @param {Function} next\n   */\n  TextureLoader.use = function (resource, next) {\n    // create a new texture if the data is an Image object\n    if (resource.data && (resource.type === LoaderResource.TYPE.IMAGE || resource.extension === 'svg')) {\n      var data = resource.data,\n        url = resource.url,\n        name = resource.name,\n        metadata = resource.metadata;\n      Texture.fromLoader(data, url, name, metadata).then(function (texture) {\n        resource.texture = texture;\n        next();\n      })\n      // TODO: handle errors in Texture.fromLoader\n      // so we can pass them to the Loader\n      .catch(next);\n    } else {\n      next();\n    }\n  };\n  /** @ignore */\n  TextureLoader.extension = ExtensionType.Loader;\n  return TextureLoader;\n}();\nvar _keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n/**\n * Encodes binary into base64.\n * @function encodeBinary\n * @param {string} input - The input data to encode.\n * @returns {string} The encoded base64 string\n */\nfunction encodeBinary(input) {\n  var output = '';\n  var inx = 0;\n  while (inx < input.length) {\n    // Fill byte buffer array\n    var bytebuffer = [0, 0, 0];\n    var encodedCharIndexes = [0, 0, 0, 0];\n    for (var jnx = 0; jnx < bytebuffer.length; ++jnx) {\n      if (inx < input.length) {\n        // throw away high-order byte, as documented at:\n        // https://developer.mozilla.org/En/Using_XMLHttpRequest#Handling_binary_data\n        bytebuffer[jnx] = input.charCodeAt(inx++) & 0xff;\n      } else {\n        bytebuffer[jnx] = 0;\n      }\n    }\n    // Get each encoded character, 6 bits at a time\n    // index 1: first 6 bits\n    encodedCharIndexes[0] = bytebuffer[0] >> 2;\n    // index 2: second 6 bits (2 least significant bits from input byte 1 + 4 most significant bits from byte 2)\n    encodedCharIndexes[1] = (bytebuffer[0] & 0x3) << 4 | bytebuffer[1] >> 4;\n    // index 3: third 6 bits (4 least significant bits from input byte 2 + 2 most significant bits from byte 3)\n    encodedCharIndexes[2] = (bytebuffer[1] & 0x0f) << 2 | bytebuffer[2] >> 6;\n    // index 3: forth 6 bits (6 least significant bits from input byte 3)\n    encodedCharIndexes[3] = bytebuffer[2] & 0x3f;\n    // Determine whether padding happened, and adjust accordingly\n    var paddingBytes = inx - (input.length - 1);\n    switch (paddingBytes) {\n      case 2:\n        // Set last 2 characters to padding char\n        encodedCharIndexes[3] = 64;\n        encodedCharIndexes[2] = 64;\n        break;\n      case 1:\n        // Set last character to padding char\n        encodedCharIndexes[3] = 64;\n        break;\n    }\n    // Now we will grab each appropriate character out of our keystring\n    // based on our index array and append it to the output string\n    for (var jnx = 0; jnx < encodedCharIndexes.length; ++jnx) {\n      output += _keyStr.charAt(encodedCharIndexes[jnx]);\n    }\n  }\n  return output;\n}\n\n/**\n * A middleware for transforming XHR loaded Blobs into more useful objects\n * @ignore\n * @function parsing\n * @example\n * import { Loader, middleware } from 'resource-loader';\n * const loader = new Loader();\n * loader.use(middleware.parsing);\n * @param resource - Current Resource\n * @param next - Callback when complete\n */\nfunction parsing(resource, next) {\n  if (!resource.data) {\n    next();\n    return;\n  }\n  // if this was an XHR load of a blob\n  if (resource.xhr && resource.xhrType === LoaderResource.XHR_RESPONSE_TYPE.BLOB) {\n    // if there is no blob support we probably got a binary string back\n    if (!self.Blob || typeof resource.data === 'string') {\n      var type = resource.xhr.getResponseHeader('content-type');\n      // this is an image, convert the binary string into a data url\n      if (type && type.indexOf('image') === 0) {\n        resource.data = new Image();\n        resource.data.src = \"data:\" + type + \";base64,\" + encodeBinary(resource.xhr.responseText);\n        resource.type = LoaderResource.TYPE.IMAGE;\n        // wait until the image loads and then callback\n        resource.data.onload = function () {\n          resource.data.onload = null;\n          next();\n        };\n        // next will be called on load\n        return;\n      }\n    }\n    // if content type says this is an image, then we should transform the blob into an Image object\n    else if (resource.data.type.indexOf('image') === 0) {\n      var Url_1 = globalThis.URL || globalThis.webkitURL;\n      var src_1 = Url_1.createObjectURL(resource.data);\n      resource.blob = resource.data;\n      resource.data = new Image();\n      resource.data.src = src_1;\n      resource.type = LoaderResource.TYPE.IMAGE;\n      // cleanup the no longer used blob after the image loads\n      // TODO: Is this correct? Will the image be invalid after revoking?\n      resource.data.onload = function () {\n        Url_1.revokeObjectURL(src_1);\n        resource.data.onload = null;\n        next();\n      };\n      // next will be called on load.\n      return;\n    }\n  }\n  next();\n}\n\n/**\n * Parse any blob into more usable objects (e.g. Image).\n * @memberof PIXI\n */\nvar ParsingLoader = /** @class */function () {\n  function ParsingLoader() {}\n  /** @ignore */\n  ParsingLoader.extension = ExtensionType.Loader;\n  ParsingLoader.use = parsing;\n  return ParsingLoader;\n}();\nextensions.add(TextureLoader, ParsingLoader);\nexport { AppLoaderPlugin, Loader, LoaderResource, TextureLoader };","map":{"version":3,"names":["SignalBinding","fn","once","thisArg","_fn","_once","_thisArg","_next","_prev","_owner","prototype","detach","_addSignalBinding","self","node","_head","_tail","Signal","undefined","handlers","exists","ee","push","has","Error","dispatch","args","_i","arguments","length","arguments$1","apply","add","detachAll","parseUri","str","opts","o","key","q","name","parser","strict","loose","m","strictMode","exec","uri","i","replace","_t0","t1","t2","useXdr","tempAnchor","STATUS_NONE","STATUS_OK","STATUS_EMPTY","STATUS_IE_BUG_EMPTY","STATUS_TYPE_OK","_noop$1","_noop","setExtMap","map","extname","val","indexOf","substring","reqType","xhr","toString","LoaderResource","url","options","_dequeue","_onLoadBinding","_elementTimer","_boundComplete","_boundOnError","_boundOnProgress","_boundOnTimeout","_boundXhrOnError","_boundXhrOnTimeout","_boundXhrOnAbort","_boundXhrOnLoad","_flags","_setFlag","STATUS_FLAGS","DATA_URL","extension","_getExtension","data","crossOrigin","timeout","loadType","_determineLoadType","xhrType","metadata","error","children","type","TYPE","UNKNOWN","progressChunk","complete","bind","_onError","_onProgress","_onTimeout","_xhrOnError","_xhrOnTimeout","_xhrOnAbort","_xhrOnLoad","onStart","onProgress","onComplete","onAfterMiddleware","setExtensionLoadType","_loadTypeMap","setExtensionXhrType","_xhrTypeMap","Object","defineProperty","get","_hasFlag","COMPLETE","LOADING","_clearEvents","_finish","abort","message","xdr","src","EMPTY_GIF","firstChild","removeChild","load","cb","_this","isLoading","isComplete","setTimeout","_determineCrossOrigin","LOAD_TYPE","IMAGE","_loadElement","AUDIO","_loadSourceElement","VIDEO","XHR","globalThis","XDomainRequest","XMLHttpRequest","_loadXdr","_loadXhr","flag","value","clearTimeout","removeEventListener","onerror","ontimeout","onprogress","onload","loadElement","Image","document","createElement","skipSource","addEventListener","Audio","navigator","isCocoonJS","Array","isArray","mimeTypes","mimeType","appendChild","_createSource","_determineXhrType","withCredentials","open","XHR_RESPONSE_TYPE","JSON","DOCUMENT","responseType","TEXT","send","mime","source","event","target","nodeName","lengthComputable","loaded","total","status","statusText","text","responseText","BUFFER","statusType","parse","e","DOMParser","domparser","parseFromString","div","innerHTML","XML","e$1","response","responseURL","loc","origin","location","href","parsedUrl","samePort","port","protocol","host","hostname","ext","isDataUrl","slashIndex","queryStart","hashStart","index","Math","min","lastIndexOf","toLowerCase","_getMimeFromXhrType","BLOB","DEFAULT","gif","png","bmp","jpg","jpeg","tif","tiff","webp","tga","avif","svg","mp3","ogg","wav","mp4","webm","xhtml","html","htm","xml","tmx","tsx","json","txt","ttf","otf","onlyOnce","onceWrapper","callFn","AsyncQueueItem","callback","AsyncQueue","worker","concurrency","workers","saturated","unsaturated","empty","drain","started","paused","_tasks","_insert","insertAtFront","idle","item","unshift","process","task","shift","_worker","buffer","kill","running","pause","resume","w","eachSeries","array","iterator","deferNext","len","next","err","queue","MAX_PROGRESS","rgxExtractUrlHash","Loader","baseUrl","progress","loading","defaultQueryString","_beforeMiddleware","_afterMiddleware","_resourcesParsing","_boundLoadResource","r","d","_loadResource","resources","_queue","onError","onLoad","_plugins","plugin","pre","use","_protected","_add","parentResource","_prepareUrl","parent","incompleteChildren","fullChunk","eachChunk","reset","k","res","deprecation","_onStart","_onComplete","numTasks","chunk","set","result","path","charAt","hash","slice","resource","dequeue","call","_onLoad","splice","destroy","shared","_shared","registerPlugin","extensions","ExtensionType","ref","handleByList","AppLoaderPlugin","init","assign","sharedLoader","loader","Application","TextureLoader","Texture","fromLoader","then","texture","catch","_keyStr","encodeBinary","input","output","inx","bytebuffer","encodedCharIndexes","jnx","charCodeAt","paddingBytes","parsing","Blob","getResponseHeader","Url_1","URL","webkitURL","src_1","createObjectURL","blob","revokeObjectURL","ParsingLoader"],"sources":["../../src/base/Signal.ts","../../src/base/parseUri.ts","../../src/LoaderResource.ts","../../src/base/AsyncQueue.ts","../../src/Loader.ts","../../src/AppLoaderPlugin.ts","../../src/TextureLoader.ts","../../src/base/encodeBinary.ts","../../src/middleware/parsing.ts","../../src/ParsingLoader.ts","../../src/index.ts"],"sourcesContent":["/* jshint -W097 */\n\n/**\n * @memberof PIXI\n */\nexport class SignalBinding<CbType>\n{\n    _fn: any;\n    _once: boolean;\n    _next: SignalBinding<CbType>;\n    _prev: SignalBinding<CbType>;\n    _owner: Signal<CbType>;\n    _thisArg: any;\n\n    /**\n     * SignalBinding constructor.\n     * @constructs SignalBinding\n     * @param {Function} fn - Event handler to be called.\n     * @param {boolean} [once=false] - Should this listener be removed after dispatch\n     * @param {object} [thisArg] - The context of the callback function.\n     * @api private\n     */\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n    constructor(fn: CbType, once = false, thisArg: any)\n    {\n        this._fn = fn;\n        this._once = once;\n        this._thisArg = thisArg;\n        this._next = this._prev = this._owner = null;\n    }\n\n    detach(): boolean\n    {\n        if (this._owner === null) return false;\n        this._owner.detach(this);\n\n        return true;\n    }\n}\n\n/**\n * @param self\n * @param node\n * @private\n */\nfunction _addSignalBinding<CbType>(self: Signal<CbType>, node: SignalBinding<CbType>)\n{\n    if (!self._head)\n    {\n        self._head = node;\n        self._tail = node;\n    }\n    else\n    {\n        self._tail._next = node;\n        node._prev = self._tail;\n        self._tail = node;\n    }\n\n    node._owner = self;\n\n    return node;\n}\n\n/**\n * @memberof PIXI\n */\nexport class Signal<CbType = (...args: any) => void>\n{\n    _head: SignalBinding<CbType>;\n    _tail: SignalBinding<CbType>;\n\n    /**\n     * MiniSignal constructor.\n     * @example\n     * let mySignal = new Signal();\n     * let binding = mySignal.add(onSignal);\n     * mySignal.dispatch('foo', 'bar');\n     * mySignal.detach(binding);\n     */\n    constructor()\n    {\n        this._head = this._tail = undefined;\n    }\n\n    /**\n     * Return an array of attached SignalBinding.\n     * @param {boolean} [exists=false] - We only need to know if there are handlers.\n     * @returns {PIXI.SignalBinding[] | boolean} Array of attached SignalBinding or Boolean if called with exists = true\n     * @api public\n     */\n    handlers(exists = false): Array<SignalBinding<CbType>> | boolean\n    {\n        let node = this._head;\n\n        if (exists) return !!node;\n\n        const ee = [];\n\n        while (node)\n        {\n            ee.push(node);\n            node = node._next;\n        }\n\n        return ee;\n    }\n\n    /**\n     * Return true if node is a SignalBinding attached to this MiniSignal\n     * @param {PIXI.SignalBinding} node - Node to check.\n     * @returns {boolean} True if node is attache to mini-signal\n     */\n    has(node: SignalBinding<CbType>): boolean\n    {\n        if (!(node instanceof SignalBinding))\n        {\n            throw new Error('MiniSignal#has(): First arg must be a SignalBinding object.');\n        }\n\n        return node._owner === this;\n    }\n\n    /**\n     * Dispaches a signal to all registered listeners.\n     * @param {...any} args\n     * @returns {boolean} Indication if we've emitted an event.\n     */\n    dispatch(...args: any[]): boolean\n    {\n        let node = this._head;\n\n        if (!node) return false;\n\n        while (node)\n        {\n            if (node._once) this.detach(node);\n            node._fn.apply(node._thisArg, args);\n            node = node._next;\n        }\n\n        return true;\n    }\n\n    /**\n     * Register a new listener.\n     * @param {Function} fn - Callback function.\n     * @param {object} [thisArg] - The context of the callback function.\n     * @returns {PIXI.SignalBinding} The SignalBinding node that was added.\n     */\n    add(fn: CbType, thisArg: any = null): SignalBinding<CbType>\n    {\n        if (typeof fn !== 'function')\n        {\n            throw new Error('MiniSignal#add(): First arg must be a Function.');\n        }\n\n        return _addSignalBinding<CbType>(this, new SignalBinding<CbType>(fn, false, thisArg));\n    }\n\n    /**\n     * Register a new listener that will be executed only once.\n     * @param {Function} fn - Callback function.\n     * @param {object} [thisArg] - The context of the callback function.\n     * @returns {PIXI.SignalBinding} The SignalBinding node that was added.\n     */\n    once(fn: CbType, thisArg: any = null): SignalBinding<CbType>\n    {\n        if (typeof fn !== 'function')\n        {\n            throw new Error('MiniSignal#once(): First arg must be a Function.');\n        }\n\n        return _addSignalBinding<CbType>(this, new SignalBinding<CbType>(fn, true, thisArg));\n    }\n\n    /**\n     * Remove binding object.\n     * @param {PIXI.SignalBinding} node - The binding node that will be removed.\n     * @returns {Signal} The instance on which this method was called.\n      @api public */\n    detach(node: SignalBinding<CbType>): this\n    {\n        if (!(node instanceof SignalBinding))\n        {\n            throw new Error('MiniSignal#detach(): First arg must be a SignalBinding object.');\n        }\n        if (node._owner !== this) return this; // todo: or error?\n\n        if (node._prev) node._prev._next = node._next;\n        if (node._next) node._next._prev = node._prev;\n\n        if (node === this._head)\n        { // first node\n            this._head = node._next;\n            if (node._next === null)\n            {\n                this._tail = null;\n            }\n        }\n        else if (node === this._tail)\n        { // last node\n            this._tail = node._prev;\n            this._tail._next = null;\n        }\n\n        node._owner = null;\n\n        return this;\n    }\n\n    /**\n     * Detach all listeners.\n     * @returns {Signal} The instance on which this method was called.\n     */\n    detachAll(): this\n    {\n        let node = this._head;\n\n        if (!node) return this;\n\n        this._head = this._tail = null;\n\n        while (node)\n        {\n            node._owner = null;\n            node = node._next;\n        }\n\n        return this;\n    }\n}\n","/**\n * function from npm package `parseUri`, converted to TS to avoid leftpad incident\n * @param {string} str\n * @param [opts] - options\n * @param {boolean} [opts.strictMode] - type of parser\n */\nexport function parseUri(str: string, opts: { strictMode?: boolean }): any\n{\n    opts = opts || {};\n\n    const o = {\n        // eslint-disable-next-line max-len\n        key: ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'],\n        q: {\n            name: 'queryKey',\n            parser: /(?:^|&)([^&=]*)=?([^&]*)/g\n        },\n        parser: {\n            // eslint-disable-next-line max-len\n            strict: /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?))?((((?:[^?#\\/]*\\/)*)([^?#]*))(?:\\?([^#]*))?(?:#(.*))?)/,\n            // eslint-disable-next-line max-len\n            loose: /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/\n        }\n    };\n\n    const m = o.parser[opts.strictMode ? 'strict' : 'loose'].exec(str);\n    const uri: any = {};\n    let i = 14;\n\n    while (i--) uri[o.key[i]] = m[i] || '';\n\n    uri[o.q.name] = {};\n    uri[o.key[12]].replace(o.q.parser, (_t0: any, t1: any, t2: any) =>\n    {\n        if (t1) uri[o.q.name][t1] = t2;\n    });\n\n    return uri;\n}\n","import type { Dict } from '@pixi/utils';\nimport { Signal } from './base/Signal';\nimport { parseUri } from './base/parseUri';\nimport type { IBaseTextureOptions, Texture } from '@pixi/core';\n\n// tests if CORS is supported in XHR, if not we need to use XDR\nlet useXdr: boolean;\nlet tempAnchor: any = null;\n\n// some status constants\nconst STATUS_NONE = 0;\nconst STATUS_OK = 200;\nconst STATUS_EMPTY = 204;\nconst STATUS_IE_BUG_EMPTY = 1223;\nconst STATUS_TYPE_OK = 2;\n\n// noop\nfunction _noop(): void { /* empty */ }\n\n/**\n * Quick helper to set a value on one of the extension maps. Ensures there is no\n * dot at the start of the extension.\n * @ignore\n * @param map - The map to set on.\n * @param extname - The extension (or key) to set.\n * @param val - The value to set.\n */\nfunction setExtMap(map: Dict<any>, extname: string, val: number)\n{\n    if (extname && extname.indexOf('.') === 0)\n    {\n        extname = extname.substring(1);\n    }\n\n    if (!extname)\n    {\n        return;\n    }\n\n    map[extname] = val;\n}\n\n/**\n * Quick helper to get string xhr type.\n * @ignore\n * @param xhr - The request to check.\n * @returns The type.\n */\nfunction reqType(xhr: XMLHttpRequest)\n{\n    return xhr.toString().replace('object ', '');\n}\n\n/**\n * Metadata for loader resource. It is very messy way to pass options for loader middlewares\n *\n * Can be extended in `GlobalMixins.IResourceMetadata`\n * @memberof PIXI\n */\nexport interface IResourceMetadata extends GlobalMixins.IResourceMetadata, IBaseTextureOptions\n{\n    /** The element to use for loading, instead of creating one. */\n    loadElement?: HTMLImageElement | HTMLAudioElement | HTMLVideoElement;\n    /**\n     * Skips adding source(s) to the load element. This\n     * is useful if you want to pass in a `loadElement` that you already added load sources to.\n     */\n    skipSource?: boolean;\n    /**\n     * The mime type to use for the source element\n     * of a video/audio elment. If the urls are an array, you can pass this as an array as well\n     * where each index is the mime type to use for the corresponding url index.\n     */\n    mimeType?: string | string[];\n\n    /**\n     * Used by BitmapFonts, Spritesheet and CompressedTextures as the options to used for\n     * metadata when loading the child image.\n     */\n    imageMetadata?: IResourceMetadata;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface LoaderResource extends GlobalMixins.LoaderResource, GlobalMixins.ILoaderResource {}\n\n/**\n * Manages the state and loading of a resource and all child resources.\n *\n * Can be extended in `GlobalMixins.LoaderResource`.\n * @memberof PIXI\n */\nclass LoaderResource\n{\n    /**\n     * Texture reference for loading images and other textures.\n     * @type {PIXI.Texture}\n     */\n    texture?: Texture;\n\n    /** used by parsing middleware */\n    blob?: Blob;\n\n    /**\n     * The name of this resource.\n     * @readonly\n     * @type {string}\n     */\n    readonly name: string;\n    /**\n     * The url used to load this resource.\n     * @readonly\n     * @type {string}\n     */\n    readonly url: string;\n    /**\n     * The extension used to load this resource.\n     * @readonly\n     * @type {string}\n     */\n    readonly extension: string;\n    /** The data that was loaded by the resource. */\n    data: any;\n    /** Is this request cross-origin? If unset, determined automatically. */\n    crossOrigin: string | boolean;\n    /**\n     * A timeout in milliseconds for the load. If the load takes longer than this time\n     * it is cancelled and the load is considered a failure. If this value is set to `0`\n     * then there is no explicit timeout.\n     * @type {number}\n     */\n    timeout: number;\n    /**\n     * The method of loading to use for this resource.\n     * @type {PIXI.LoaderResource.LOAD_TYPE}\n     */\n    loadType: LoaderResource.LOAD_TYPE;\n    /**\n     * The type used to load the resource via XHR. If unset, determined automatically.\n     * @member {string}\n     */\n    xhrType: string;\n\n    /**\n     * Extra info for middleware, and controlling specifics about how the resource loads.\n     *\n     * Note that if you pass in a `loadElement`, the Resource class takes ownership of it.\n     * Meaning it will modify it as it sees fit.\n     * @type {PIXI.IResourceMetadata}\n     */\n    metadata: IResourceMetadata;\n    /**\n     * The error that occurred while loading (if any).\n     * @readonly\n     * @member {Error}\n     */\n    error: Error;\n    /**\n     * The XHR object that was used to load this resource. This is only set\n     * when `loadType` is `LoaderResource.LOAD_TYPE.XHR`.\n     * @readonly\n     */\n    xhr: XMLHttpRequest;\n\n    private xdr: any;\n    /**\n     * The child resources this resource owns.\n     * @type {PIXI.LoaderResource[]}\n     */\n    readonly children: LoaderResource[];\n    /**\n     * The resource type.\n     * @readonly\n     * @type {PIXI.LoaderResource.TYPE}\n     */\n    type: LoaderResource.TYPE;\n    /**\n     * The progress chunk owned by this resource.\n     * @readonly\n     * @member {number}\n     */\n    progressChunk: number;\n    /**\n     * Dispatched when the resource beings to load.\n     *\n     * The callback looks like {@link LoaderResource.OnStartSignal}.\n     * @type {PIXI.Signal}\n     */\n    onStart: Signal<LoaderResource.OnStartSignal>;\n    /**\n     * Dispatched each time progress of this resource load updates.\n     * Not all resources types and loader systems can support this event\n     * so sometimes it may not be available. If the resource\n     * is being loaded on a modern browser, using XHR, and the remote server\n     * properly sets Content-Length headers, then this will be available.\n     *\n     * The callback looks like {@link LoaderResource.OnProgressSignal}.\n     * @type {PIXI.Signal}\n     */\n    onProgress: Signal<LoaderResource.OnProgressSignal>;\n    /**\n     * Dispatched once this resource has loaded, if there was an error it will\n     * be in the `error` property.\n     *\n     * The callback looks like {@link LoaderResource.OnCompleteSignal}.\n     * @type {PIXI.Signal}\n     */\n    onComplete: Signal<LoaderResource.OnCompleteSignal>;\n    /**\n     * Dispatched after this resource has had all the *after* middleware run on it.\n     *\n     * The callback looks like {@link LoaderResource.OnCompleteSignal}.\n     * @type {PIXI.Signal}\n     */\n    onAfterMiddleware: Signal<LoaderResource.OnCompleteSignal>;\n\n    /**\n     * The state flags of this resource.\n     * @private\n     * @member {number}\n     */\n    private _flags: number;\n\n    /**\n     * The `dequeue` method that will be used a storage place for the async queue dequeue method\n     * used privately by the loader.\n     * @private\n     * @member {Function}\n     */\n    _dequeue: any = _noop;\n\n    /**\n     * Used a storage place for the on load binding used privately by the loader.\n     * @private\n     * @member {Function}\n     */\n    _onLoadBinding: any = null;\n\n    /**\n     * The timer for element loads to check if they timeout.\n     * @private\n     */\n    private _elementTimer = 0;\n\n    /**\n     * The `complete` function bound to this resource's context.\n     * @private\n     * @type {Function}\n     */\n    private _boundComplete: any = null;\n\n    /**\n     * The `_onError` function bound to this resource's context.\n     * @private\n     * @type {Function}\n     */\n    private _boundOnError: any = null;\n\n    /**\n     * The `_onProgress` function bound to this resource's context.\n     * @private\n     * @type {Function}\n     */\n    private _boundOnProgress: any = null;\n\n    /**\n     * The `_onTimeout` function bound to this resource's context.\n     * @private\n     * @type {Function}\n     */\n    private _boundOnTimeout: any = null;\n\n    private _boundXhrOnError: any = null;\n    private _boundXhrOnTimeout: any = null;\n    private _boundXhrOnAbort: any = null;\n    private _boundXhrOnLoad: any = null;\n\n    /**\n     * Sets the load type to be used for a specific extension.\n     * @static\n     * @param {string} extname - The extension to set the type for, e.g. \"png\" or \"fnt\"\n     * @param {PIXI.LoaderResource.LOAD_TYPE} loadType - The load type to set it to.\n     */\n    static setExtensionLoadType(extname: string, loadType: LoaderResource.LOAD_TYPE): void\n    {\n        setExtMap(LoaderResource._loadTypeMap, extname, loadType);\n    }\n    /**\n     * Sets the load type to be used for a specific extension.\n     * @static\n     * @param {string} extname - The extension to set the type for, e.g. \"png\" or \"fnt\"\n     * @param {PIXI.LoaderResource.XHR_RESPONSE_TYPE} xhrType - The xhr type to set it to.\n     */\n    static setExtensionXhrType(extname: string, xhrType: LoaderResource.XHR_RESPONSE_TYPE): void\n    {\n        setExtMap(LoaderResource._xhrTypeMap, extname, xhrType as any);\n    }\n\n    /**\n     * @param {string} name - The name of the resource to load.\n     * @param {string|string[]} url - The url for this resource, for audio/video loads you can pass\n     *      an array of sources.\n     * @param {object} [options] - The options for the load.\n     * @param {string|boolean} [options.crossOrigin] - Is this request cross-origin? Default is to\n     *      determine automatically.\n     * @param {number} [options.timeout=0] - A timeout in milliseconds for the load. If the load takes\n     *      longer than this time it is cancelled and the load is considered a failure. If this value is\n     *      set to `0` then there is no explicit timeout.\n     * @param {PIXI.LoaderResource.LOAD_TYPE} [options.loadType=LOAD_TYPE.XHR] - How should this resource\n     *      be loaded?\n     * @param {PIXI.LoaderResource.XHR_RESPONSE_TYPE} [options.xhrType=XHR_RESPONSE_TYPE.DEFAULT] - How\n     *      should the data being loaded be interpreted when using XHR?\n     * @param {PIXI.LoaderResource.IMetadata} [options.metadata] - Extra configuration for middleware\n     *      and the Resource object.\n     */\n    constructor(name: string, url: string | string[], options?: {\n        crossOrigin?: string | boolean;\n        timeout?: number;\n        loadType?: LoaderResource.LOAD_TYPE;\n        xhrType?: LoaderResource.XHR_RESPONSE_TYPE;\n        metadata?: IResourceMetadata;\n    })\n    {\n        if (typeof name !== 'string' || typeof url !== 'string')\n        {\n            throw new Error('Both name and url are required for constructing a resource.');\n        }\n\n        options = options || {};\n\n        this._flags = 0;\n\n        // set data url flag, needs to be set early for some _determineX checks to work.\n        this._setFlag(LoaderResource.STATUS_FLAGS.DATA_URL, url.indexOf('data:') === 0);\n\n        this.name = name;\n\n        this.url = url;\n\n        this.extension = this._getExtension();\n\n        this.data = null;\n\n        this.crossOrigin = options.crossOrigin === true ? 'anonymous' : options.crossOrigin;\n\n        this.timeout = options.timeout || 0;\n\n        this.loadType = options.loadType || this._determineLoadType();\n\n        // The type used to load the resource via XHR. If unset, determined automatically.\n        this.xhrType = options.xhrType;\n\n        // Extra info for middleware, and controlling specifics about how the resource loads.\n        // Note that if you pass in a `loadElement`, the Resource class takes ownership of it.\n        // Meaning it will modify it as it sees fit.\n        this.metadata = options.metadata || {};\n\n        // The error that occurred while loading (if any).\n        this.error = null;\n\n        // The XHR object that was used to load this resource. This is only set\n        // when `loadType` is `LoaderResource.LOAD_TYPE.XHR`.\n        this.xhr = null;\n\n        // The child resources this resource owns.\n        this.children = [];\n\n        // The resource type.\n        this.type = LoaderResource.TYPE.UNKNOWN;\n\n        // The progress chunk owned by this resource.\n        this.progressChunk = 0;\n\n        // The `dequeue` method that will be used a storage place for the async queue dequeue method\n        // used privately by the loader.\n        this._dequeue = _noop;\n\n        // Used a storage place for the on load binding used privately by the loader.\n        this._onLoadBinding = null;\n\n        // The timer for element loads to check if they timeout.\n        this._elementTimer = 0;\n\n        this._boundComplete = this.complete.bind(this);\n        this._boundOnError = this._onError.bind(this);\n        this._boundOnProgress = this._onProgress.bind(this);\n        this._boundOnTimeout = this._onTimeout.bind(this);\n\n        // xhr callbacks\n        this._boundXhrOnError = this._xhrOnError.bind(this);\n        this._boundXhrOnTimeout = this._xhrOnTimeout.bind(this);\n        this._boundXhrOnAbort = this._xhrOnAbort.bind(this);\n        this._boundXhrOnLoad = this._xhrOnLoad.bind(this);\n\n        // Dispatched when the resource beings to load.\n        this.onStart = new Signal();\n\n        // Dispatched each time progress of this resource load updates.\n        // Not all resources types and loader systems can support this event\n        // so sometimes it may not be available. If the resource\n        // is being loaded on a modern browser, using XHR, and the remote server\n        // properly sets Content-Length headers, then this will be available.\n        this.onProgress = new Signal();\n\n        // Dispatched once this resource has loaded, if there was an error it will\n        // be in the `error` property.\n        this.onComplete = new Signal();\n\n        // Dispatched after this resource has had all the *after* middleware run on it.\n        this.onAfterMiddleware = new Signal();\n    }\n\n    /**\n     * When the resource starts to load.\n     * @memberof PIXI.LoaderResource\n     * @callback OnStartSignal\n     * @param {PIXI.Resource} resource - The resource that the event happened on.\n     */\n\n    /**\n     * When the resource reports loading progress.\n     * @memberof PIXI.LoaderResource\n     * @callback OnProgressSignal\n     * @param {PIXI.Resource} resource - The resource that the event happened on.\n     * @param {number} percentage - The progress of the load in the range [0, 1].\n     */\n\n    /**\n     * When the resource finishes loading.\n     * @memberof PIXI.LoaderResource\n     * @callback OnCompleteSignal\n     * @param {PIXI.Resource} resource - The resource that the event happened on.\n     */\n\n    /**\n     * @memberof PIXI.LoaderResource\n     * @typedef {object} IMetadata\n     * @property {HTMLImageElement|HTMLAudioElement|HTMLVideoElement} [loadElement=null] - The\n     *      element to use for loading, instead of creating one.\n     * @property {boolean} [skipSource=false] - Skips adding source(s) to the load element. This\n     *      is useful if you want to pass in a `loadElement` that you already added load sources to.\n     * @property {string|string[]} [mimeType] - The mime type to use for the source element\n     *      of a video/audio elment. If the urls are an array, you can pass this as an array as well\n     *      where each index is the mime type to use for the corresponding url index.\n     */\n\n    /**\n     * Stores whether or not this url is a data url.\n     * @readonly\n     * @member {boolean}\n     */\n    get isDataUrl(): boolean\n    {\n        return this._hasFlag(LoaderResource.STATUS_FLAGS.DATA_URL);\n    }\n\n    /**\n     * Describes if this resource has finished loading. Is true when the resource has completely\n     * loaded.\n     * @readonly\n     * @member {boolean}\n     */\n    get isComplete(): boolean\n    {\n        return this._hasFlag(LoaderResource.STATUS_FLAGS.COMPLETE);\n    }\n\n    /**\n     * Describes if this resource is currently loading. Is true when the resource starts loading,\n     * and is false again when complete.\n     * @readonly\n     * @member {boolean}\n     */\n    get isLoading(): boolean\n    {\n        return this._hasFlag(LoaderResource.STATUS_FLAGS.LOADING);\n    }\n\n    /** Marks the resource as complete. */\n    complete(): void\n    {\n        this._clearEvents();\n        this._finish();\n    }\n\n    /**\n     * Aborts the loading of this resource, with an optional message.\n     * @param {string} message - The message to use for the error\n     */\n    abort(message: string): void\n    {\n        // abort can be called multiple times, ignore subsequent calls.\n        if (this.error)\n        {\n            return;\n        }\n\n        // store error\n        this.error = new Error(message);\n\n        // clear events before calling aborts\n        this._clearEvents();\n\n        // abort the actual loading\n        if (this.xhr)\n        {\n            this.xhr.abort();\n        }\n        else if (this.xdr)\n        {\n            this.xdr.abort();\n        }\n        else if (this.data)\n        {\n            // single source\n            if (this.data.src)\n            {\n                this.data.src = LoaderResource.EMPTY_GIF;\n            }\n            // multi-source\n            else\n            {\n                while (this.data.firstChild)\n                {\n                    this.data.removeChild(this.data.firstChild);\n                }\n            }\n        }\n\n        // done now.\n        this._finish();\n    }\n\n    /**\n     * Kicks off loading of this resource. This method is asynchronous.\n     * @param {PIXI.LoaderResource.OnCompleteSignal} [cb] - Optional callback to call once the resource is loaded.\n     */\n    load(cb?: LoaderResource.OnCompleteSignal): void\n    {\n        if (this.isLoading)\n        {\n            return;\n        }\n\n        if (this.isComplete)\n        {\n            if (cb)\n            {\n                setTimeout(() => cb(this), 1);\n            }\n\n            return;\n        }\n        else if (cb)\n        {\n            this.onComplete.once(cb);\n        }\n\n        this._setFlag(LoaderResource.STATUS_FLAGS.LOADING, true);\n\n        this.onStart.dispatch(this);\n\n        // if unset, determine the value\n        if (this.crossOrigin === false || typeof this.crossOrigin !== 'string')\n        {\n            this.crossOrigin = this._determineCrossOrigin(this.url);\n        }\n\n        switch (this.loadType)\n        {\n            case LoaderResource.LOAD_TYPE.IMAGE:\n                this.type = LoaderResource.TYPE.IMAGE;\n                this._loadElement('image');\n                break;\n\n            case LoaderResource.LOAD_TYPE.AUDIO:\n                this.type = LoaderResource.TYPE.AUDIO;\n                this._loadSourceElement('audio');\n                break;\n\n            case LoaderResource.LOAD_TYPE.VIDEO:\n                this.type = LoaderResource.TYPE.VIDEO;\n                this._loadSourceElement('video');\n                break;\n\n            case LoaderResource.LOAD_TYPE.XHR:\n            /* falls through */\n            default:\n                if (typeof useXdr === 'undefined')\n                {\n                    useXdr = !!((globalThis as any).XDomainRequest && !('withCredentials' in (new XMLHttpRequest())));\n                }\n                if (useXdr && this.crossOrigin)\n                {\n                    this._loadXdr();\n                }\n                else\n                {\n                    this._loadXhr();\n                }\n                break;\n        }\n    }\n\n    /**\n     * Checks if the flag is set.\n     * @param flag - The flag to check.\n     * @returns True if the flag is set.\n     */\n    private _hasFlag(flag: number): boolean\n    {\n        return (this._flags & flag) !== 0;\n    }\n\n    /**\n     * (Un)Sets the flag.\n     * @param flag - The flag to (un)set.\n     * @param value - Whether to set or (un)set the flag.\n     */\n    private _setFlag(flag: number, value: boolean): void\n    {\n        this._flags = value ? (this._flags | flag) : (this._flags & ~flag);\n    }\n\n    /** Clears all the events from the underlying loading source. */\n    private _clearEvents(): void\n    {\n        clearTimeout(this._elementTimer);\n\n        if (this.data && this.data.removeEventListener)\n        {\n            this.data.removeEventListener('error', this._boundOnError, false);\n            this.data.removeEventListener('load', this._boundComplete, false);\n            this.data.removeEventListener('progress', this._boundOnProgress, false);\n            this.data.removeEventListener('canplaythrough', this._boundComplete, false);\n        }\n\n        if (this.xhr)\n        {\n            if (this.xhr.removeEventListener)\n            {\n                this.xhr.removeEventListener('error', this._boundXhrOnError, false);\n                this.xhr.removeEventListener('timeout', this._boundXhrOnTimeout, false);\n                this.xhr.removeEventListener('abort', this._boundXhrOnAbort, false);\n                this.xhr.removeEventListener('progress', this._boundOnProgress, false);\n                this.xhr.removeEventListener('load', this._boundXhrOnLoad, false);\n            }\n            else\n            {\n                this.xhr.onerror = null;\n                this.xhr.ontimeout = null;\n                this.xhr.onprogress = null;\n                this.xhr.onload = null;\n            }\n        }\n    }\n\n    /** Finalizes the load. */\n    private _finish(): void\n    {\n        if (this.isComplete)\n        {\n            throw new Error('Complete called again for an already completed resource.');\n        }\n\n        this._setFlag(LoaderResource.STATUS_FLAGS.COMPLETE, true);\n        this._setFlag(LoaderResource.STATUS_FLAGS.LOADING, false);\n\n        this.onComplete.dispatch(this);\n    }\n\n    /**\n     * Loads this resources using an element that has a single source,\n     * like an HTMLImageElement.\n     * @private\n     * @param type - The type of element to use.\n     */\n    _loadElement(type: string): void\n    {\n        if (this.metadata.loadElement)\n        {\n            this.data = this.metadata.loadElement;\n        }\n        else if (type === 'image' && typeof globalThis.Image !== 'undefined')\n        {\n            this.data = new Image();\n        }\n        else\n        {\n            this.data = document.createElement(type);\n        }\n\n        if (this.crossOrigin)\n        {\n            this.data.crossOrigin = this.crossOrigin;\n        }\n\n        if (!this.metadata.skipSource)\n        {\n            this.data.src = this.url;\n        }\n\n        this.data.addEventListener('error', this._boundOnError, false);\n        this.data.addEventListener('load', this._boundComplete, false);\n        this.data.addEventListener('progress', this._boundOnProgress, false);\n\n        if (this.timeout)\n        {\n            this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout) as any;\n        }\n    }\n\n    /**\n     * Loads this resources using an element that has multiple sources,\n     * like an HTMLAudioElement or HTMLVideoElement.\n     * @param type - The type of element to use.\n     */\n    private _loadSourceElement(type: string): void\n    {\n        if (this.metadata.loadElement)\n        {\n            this.data = this.metadata.loadElement;\n        }\n        else if (type === 'audio' && typeof globalThis.Audio !== 'undefined')\n        {\n            this.data = new Audio();\n        }\n        else\n        {\n            this.data = document.createElement(type);\n        }\n\n        if (this.data === null)\n        {\n            this.abort(`Unsupported element: ${type}`);\n\n            return;\n        }\n\n        if (this.crossOrigin)\n        {\n            this.data.crossOrigin = this.crossOrigin;\n        }\n\n        if (!this.metadata.skipSource)\n        {\n            // support for CocoonJS Canvas+ runtime, lacks document.createElement('source')\n            if ((navigator as any).isCocoonJS)\n            {\n                this.data.src = Array.isArray(this.url) ? this.url[0] : this.url;\n            }\n            else if (Array.isArray(this.url))\n            {\n                const mimeTypes = this.metadata.mimeType;\n\n                for (let i = 0; i < this.url.length; ++i)\n                {\n                    this.data.appendChild(\n                        this._createSource(type, this.url[i], Array.isArray(mimeTypes) ? mimeTypes[i] : mimeTypes)\n                    );\n                }\n            }\n            else\n            {\n                const mimeTypes = this.metadata.mimeType;\n\n                this.data.appendChild(\n                    this._createSource(type, this.url, Array.isArray(mimeTypes) ? mimeTypes[0] : mimeTypes)\n                );\n            }\n        }\n\n        this.data.addEventListener('error', this._boundOnError, false);\n        this.data.addEventListener('load', this._boundComplete, false);\n        this.data.addEventListener('progress', this._boundOnProgress, false);\n        this.data.addEventListener('canplaythrough', this._boundComplete, false);\n\n        this.data.load();\n\n        if (this.timeout)\n        {\n            this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout) as any;\n        }\n    }\n\n    /** Loads this resources using an XMLHttpRequest. */\n    private _loadXhr(): void\n    {\n        // if unset, determine the value\n        if (typeof this.xhrType !== 'string')\n        {\n            this.xhrType = this._determineXhrType();\n        }\n\n        const xhr = this.xhr = new XMLHttpRequest();\n\n        // send credentials when crossOrigin with credentials requested\n        if (this.crossOrigin === 'use-credentials')\n        {\n            xhr.withCredentials = true;\n        }\n\n        // set the request type and url\n        xhr.open('GET', this.url, true);\n\n        xhr.timeout = this.timeout;\n\n        // load json as text and parse it ourselves. We do this because some browsers\n        // *cough* safari *cough* can't deal with it.\n        if (this.xhrType === LoaderResource.XHR_RESPONSE_TYPE.JSON\n            || this.xhrType === LoaderResource.XHR_RESPONSE_TYPE.DOCUMENT)\n        {\n            xhr.responseType = LoaderResource.XHR_RESPONSE_TYPE.TEXT;\n        }\n        else\n        {\n            xhr.responseType = this.xhrType as any;\n        }\n\n        xhr.addEventListener('error', this._boundXhrOnError, false);\n        xhr.addEventListener('timeout', this._boundXhrOnTimeout, false);\n        xhr.addEventListener('abort', this._boundXhrOnAbort, false);\n        xhr.addEventListener('progress', this._boundOnProgress, false);\n        xhr.addEventListener('load', this._boundXhrOnLoad, false);\n\n        xhr.send();\n    }\n\n    /** Loads this resources using an XDomainRequest. This is here because we need to support IE9 (gross). */\n    private _loadXdr(): void\n    {\n        // if unset, determine the value\n        if (typeof this.xhrType !== 'string')\n        {\n            this.xhrType = this._determineXhrType();\n        }\n\n        const xdr = this.xhr = new (globalThis as any).XDomainRequest(); // eslint-disable-line no-undef\n\n        // XDomainRequest has a few quirks. Occasionally it will abort requests\n        // A way to avoid this is to make sure ALL callbacks are set even if not used\n        // More info here: http://stackoverflow.com/questions/15786966/xdomainrequest-aborts-post-on-ie-9\n        xdr.timeout = this.timeout || 5000; // XDR needs a timeout value or it breaks in IE9\n\n        xdr.onerror = this._boundXhrOnError;\n        xdr.ontimeout = this._boundXhrOnTimeout;\n        xdr.onprogress = this._boundOnProgress;\n        xdr.onload = this._boundXhrOnLoad;\n\n        xdr.open('GET', this.url, true);\n\n        // Note: The xdr.send() call is wrapped in a timeout to prevent an\n        // issue with the interface where some requests are lost if multiple\n        // XDomainRequests are being sent at the same time.\n        // Some info here: https://github.com/photonstorm/phaser/issues/1248\n        setTimeout(() => xdr.send(), 1);\n    }\n\n    /**\n     * Creates a source used in loading via an element.\n     * @param type - The element type (video or audio).\n     * @param url - The source URL to load from.\n     * @param [mime] - The mime type of the video\n     * @returns The source element.\n     */\n    private _createSource(type: string, url: string, mime: string): HTMLSourceElement\n    {\n        if (!mime)\n        {\n            mime = `${type}/${this._getExtension(url)}`;\n        }\n\n        const source = document.createElement('source');\n\n        source.src = url;\n        source.type = mime;\n\n        return source;\n    }\n\n    /**\n     * Called if a load errors out.\n     * @param event - The error event from the element that emits it.\n     */\n    private _onError(event: Event): void\n    {\n        this.abort(`Failed to load element using: ${(event.target as any).nodeName}`);\n    }\n\n    /**\n     * Called if a load progress event fires for an element or xhr/xdr.\n     * @param event - Progress event.\n     */\n    private _onProgress(event: ProgressEvent): void\n    {\n        if (event && event.lengthComputable)\n        {\n            this.onProgress.dispatch(this, event.loaded / event.total);\n        }\n    }\n\n    /** Called if a timeout event fires for an element. */\n    private _onTimeout(): void\n    {\n        this.abort(`Load timed out.`);\n    }\n\n    /** Called if an error event fires for xhr/xdr. */\n    private _xhrOnError(): void\n    {\n        const xhr = this.xhr;\n\n        this.abort(`${reqType(xhr)} Request failed. Status: ${xhr.status}, text: \"${xhr.statusText}\"`);\n    }\n\n    /** Called if an error event fires for xhr/xdr. */\n    private _xhrOnTimeout(): void\n    {\n        const xhr = this.xhr;\n\n        this.abort(`${reqType(xhr)} Request timed out.`);\n    }\n\n    /** Called if an abort event fires for xhr/xdr. */\n    private _xhrOnAbort(): void\n    {\n        const xhr = this.xhr;\n\n        this.abort(`${reqType(xhr)} Request was aborted by the user.`);\n    }\n\n    /** Called when data successfully loads from an xhr/xdr request. */\n    private _xhrOnLoad(): void\n    {\n        const xhr = this.xhr;\n        let text = '';\n        let status = typeof xhr.status === 'undefined' ? STATUS_OK : xhr.status; // XDR has no `.status`, assume 200.\n\n        // responseText is accessible only if responseType is '' or 'text' and on older browsers\n        if (xhr.responseType === '' || xhr.responseType === 'text' || typeof xhr.responseType === 'undefined')\n        {\n            text = xhr.responseText;\n        }\n\n        // status can be 0 when using the `file://` protocol so we also check if a response is set.\n        // If it has a response, we assume 200; otherwise a 0 status code with no contents is an aborted request.\n        if (status === STATUS_NONE && (text.length > 0 || xhr.responseType === LoaderResource.XHR_RESPONSE_TYPE.BUFFER))\n        {\n            status = STATUS_OK;\n        }\n        // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request\n        else if (status === STATUS_IE_BUG_EMPTY)\n        {\n            status = STATUS_EMPTY;\n        }\n\n        const statusType = (status / 100) | 0;\n\n        if (statusType === STATUS_TYPE_OK)\n        {\n            // if text, just return it\n            if (this.xhrType === LoaderResource.XHR_RESPONSE_TYPE.TEXT)\n            {\n                this.data = text;\n                this.type = LoaderResource.TYPE.TEXT;\n            }\n            // if json, parse into json object\n            else if (this.xhrType === LoaderResource.XHR_RESPONSE_TYPE.JSON)\n            {\n                try\n                {\n                    this.data = JSON.parse(text);\n                    this.type = LoaderResource.TYPE.JSON;\n                }\n                catch (e)\n                {\n                    this.abort(`Error trying to parse loaded json: ${e}`);\n\n                    return;\n                }\n            }\n            // if xml, parse into an xml document or div element\n            else if (this.xhrType === LoaderResource.XHR_RESPONSE_TYPE.DOCUMENT)\n            {\n                try\n                {\n                    if (globalThis.DOMParser)\n                    {\n                        const domparser = new DOMParser();\n\n                        this.data = domparser.parseFromString(text, 'text/xml');\n                    }\n                    else\n                    {\n                        const div = document.createElement('div');\n\n                        div.innerHTML = text;\n\n                        this.data = div;\n                    }\n\n                    this.type = LoaderResource.TYPE.XML;\n                }\n                catch (e)\n                {\n                    this.abort(`Error trying to parse loaded xml: ${e}`);\n\n                    return;\n                }\n            }\n            // other types just return the response\n            else\n            {\n                this.data = xhr.response || text;\n            }\n        }\n        else\n        {\n            this.abort(`[${xhr.status}] ${xhr.statusText}: ${xhr.responseURL}`);\n\n            return;\n        }\n\n        this.complete();\n    }\n\n    /**\n     * Sets the `crossOrigin` property for this resource based on if the url\n     * for this resource is cross-origin. If crossOrigin was manually set, this\n     * function does nothing.\n     * @private\n     * @param url - The url to test.\n     * @param [loc=globalThis.location] - The location object to test against.\n     * @returns The crossOrigin value to use (or empty string for none).\n     */\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n    _determineCrossOrigin(url: string, loc?: any): string\n    {\n        // data: and javascript: urls are considered same-origin\n        if (url.indexOf('data:') === 0)\n        {\n            return '';\n        }\n\n        // A sandboxed iframe without the 'allow-same-origin' attribute will have a special\n        // origin designed not to match globalThis.location.origin, and will always require\n        // crossOrigin requests regardless of whether the location matches.\n        if (globalThis.origin !== globalThis.location.origin)\n        {\n            return 'anonymous';\n        }\n\n        // default is globalThis.location\n        loc = loc || globalThis.location;\n\n        if (!tempAnchor)\n        {\n            tempAnchor = document.createElement('a');\n        }\n\n        // let the browser determine the full href for the url of this resource and then\n        // parse with the node url lib, we can't use the properties of the anchor element\n        // because they don't work in IE9 :(\n        tempAnchor.href = url;\n        const parsedUrl = parseUri(tempAnchor.href, { strictMode: true });\n\n        const samePort = (!parsedUrl.port && loc.port === '') || (parsedUrl.port === loc.port);\n        const protocol = parsedUrl.protocol ? `${parsedUrl.protocol}:` : '';\n\n        // if cross origin\n        if (parsedUrl.host !== loc.hostname || !samePort || protocol !== loc.protocol)\n        {\n            return 'anonymous';\n        }\n\n        return '';\n    }\n\n    /**\n     * Determines the responseType of an XHR request based on the extension of the\n     * resource being loaded.\n     * @private\n     * @returns {PIXI.LoaderResource.XHR_RESPONSE_TYPE} The responseType to use.\n     */\n    private _determineXhrType(): LoaderResource.XHR_RESPONSE_TYPE\n    {\n        return LoaderResource._xhrTypeMap[this.extension] || LoaderResource.XHR_RESPONSE_TYPE.TEXT;\n    }\n\n    /**\n     * Determines the loadType of a resource based on the extension of the\n     * resource being loaded.\n     * @private\n     * @returns {PIXI.LoaderResource.LOAD_TYPE} The loadType to use.\n     */\n    private _determineLoadType(): LoaderResource.LOAD_TYPE\n    {\n        return LoaderResource._loadTypeMap[this.extension] || LoaderResource.LOAD_TYPE.XHR;\n    }\n\n    /**\n     * Extracts the extension (sans '.') of the file being loaded by the resource.\n     * @param [url] - url to parse, `this.url` by default.\n     * @returns The extension.\n     */\n    private _getExtension(url = this.url): string\n    {\n        let ext = '';\n\n        if (this.isDataUrl)\n        {\n            const slashIndex = url.indexOf('/');\n\n            ext = url.substring(slashIndex + 1, url.indexOf(';', slashIndex));\n        }\n        else\n        {\n            const queryStart = url.indexOf('?');\n            const hashStart = url.indexOf('#');\n            const index = Math.min(\n                queryStart > -1 ? queryStart : url.length,\n                hashStart > -1 ? hashStart : url.length\n            );\n\n            url = url.substring(0, index);\n            ext = url.substring(url.lastIndexOf('.') + 1);\n        }\n\n        return ext.toLowerCase();\n    }\n\n    /**\n     * Determines the mime type of an XHR request based on the responseType of\n     * resource being loaded.\n     * @param type - The type to get a mime type for.\n     * @private\n     * @returns The mime type to use.\n     */\n    _getMimeFromXhrType(type: LoaderResource.XHR_RESPONSE_TYPE): string\n    {\n        switch (type)\n        {\n            case LoaderResource.XHR_RESPONSE_TYPE.BUFFER:\n                return 'application/octet-binary';\n\n            case LoaderResource.XHR_RESPONSE_TYPE.BLOB:\n                return 'application/blob';\n\n            case LoaderResource.XHR_RESPONSE_TYPE.DOCUMENT:\n                return 'application/xml';\n\n            case LoaderResource.XHR_RESPONSE_TYPE.JSON:\n                return 'application/json';\n\n            case LoaderResource.XHR_RESPONSE_TYPE.DEFAULT:\n            case LoaderResource.XHR_RESPONSE_TYPE.TEXT:\n            /* falls through */\n            default:\n                return 'text/plain';\n        }\n    }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\nnamespace LoaderResource\n{\n    /**\n     * When the resource starts to load.\n     * @memberof PIXI.LoaderResource\n     * @callback OnStartSignal\n     * @param {PIXI.Resource} resource - The resource that the event happened on.\n     */\n    export type OnStartSignal = (resource: LoaderResource) => void;\n    /**\n     * When the resource reports loading progress.\n     * @memberof PIXI.LoaderResource\n     * @callback OnProgressSignal\n     * @param {PIXI.Resource} resource - The resource that the event happened on.\n     * @param {number} percentage - The progress of the load in the range [0, 1].\n     */\n    export type OnProgressSignal = (resource: LoaderResource, percentage: number) => void;\n    /**\n     * When the resource finishes loading.\n     * @memberof PIXI.LoaderResource\n     * @callback OnCompleteSignal\n     * @param {PIXI.Resource} resource - The resource that the event happened on.\n     */\n    export type OnCompleteSignal = (resource: LoaderResource) => void;\n\n    /**\n     * The types of resources a resource could represent.\n     * @static\n     * @readonly\n     * @enum {number}\n     * @memberof PIXI.LoaderResource\n     */\n    export enum STATUS_FLAGS\n    // eslint-disable-next-line @typescript-eslint/indent\n    {\n        /** None */\n        NONE = 0,\n        /** Data URL */\n        DATA_URL = (1 << 0),\n        /** Complete */\n        COMPLETE = (1 << 1),\n        /** Loading */\n        LOADING = (1 << 2),\n    }\n\n    /**\n     * The types of resources a resource could represent.\n     * @static\n     * @readonly\n     * @enum {number}\n     * @memberof PIXI.LoaderResource\n     */\n    export enum TYPE\n    // eslint-disable-next-line @typescript-eslint/indent\n    {\n        /** Unknown */\n        UNKNOWN = 0,\n        /** JSON */\n        JSON = 1,\n        /** XML */\n        XML = 2,\n        /** Image */\n        IMAGE = 3,\n        /** Audio */\n        AUDIO = 4,\n        /** Video */\n        VIDEO = 5,\n        /** Plain text */\n        TEXT = 6,\n    }\n\n    /**\n     * The types of loading a resource can use.\n     * @static\n     * @readonly\n     * @enum {number}\n     * @memberof PIXI.LoaderResource\n     */\n    export enum LOAD_TYPE\n    // eslint-disable-next-line @typescript-eslint/indent\n    {\n        /** Uses XMLHttpRequest to load the resource. */\n        XHR = 1,\n        /** Uses an `Image` object to load the resource. */\n        IMAGE = 2,\n        /** Uses an `Audio` object to load the resource. */\n        AUDIO = 3,\n        /** Uses a `Video` object to load the resource. */\n        VIDEO = 4,\n    }\n\n    /**\n     * The XHR ready states, used internally.\n     * @static\n     * @readonly\n     * @enum {string}\n     * @memberof PIXI.LoaderResource\n     */\n    export enum XHR_RESPONSE_TYPE\n    // eslint-disable-next-line @typescript-eslint/indent\n    {\n        /** string */\n        DEFAULT = 'text',\n        /** ArrayBuffer */\n        BUFFER = 'arraybuffer',\n        /** Blob */\n        BLOB = 'blob',\n        /** Document */\n        DOCUMENT = 'document',\n        /** Object */\n        JSON = 'json',\n        /** String */\n        TEXT = 'text',\n    }\n\n    export const _loadTypeMap: Dict<number> = {\n        // images\n        gif: LoaderResource.LOAD_TYPE.IMAGE,\n        png: LoaderResource.LOAD_TYPE.IMAGE,\n        bmp: LoaderResource.LOAD_TYPE.IMAGE,\n        jpg: LoaderResource.LOAD_TYPE.IMAGE,\n        jpeg: LoaderResource.LOAD_TYPE.IMAGE,\n        tif: LoaderResource.LOAD_TYPE.IMAGE,\n        tiff: LoaderResource.LOAD_TYPE.IMAGE,\n        webp: LoaderResource.LOAD_TYPE.IMAGE,\n        tga: LoaderResource.LOAD_TYPE.IMAGE,\n        avif: LoaderResource.LOAD_TYPE.IMAGE,\n        svg: LoaderResource.LOAD_TYPE.IMAGE,\n        'svg+xml': LoaderResource.LOAD_TYPE.IMAGE, // for SVG data urls\n\n        // audio\n        mp3: LoaderResource.LOAD_TYPE.AUDIO,\n        ogg: LoaderResource.LOAD_TYPE.AUDIO,\n        wav: LoaderResource.LOAD_TYPE.AUDIO,\n\n        // videos\n        mp4: LoaderResource.LOAD_TYPE.VIDEO,\n        webm: LoaderResource.LOAD_TYPE.VIDEO,\n    };\n\n    export const _xhrTypeMap: Dict<XHR_RESPONSE_TYPE> = {\n        // xml\n        xhtml: LoaderResource.XHR_RESPONSE_TYPE.DOCUMENT,\n        html: LoaderResource.XHR_RESPONSE_TYPE.DOCUMENT,\n        htm: LoaderResource.XHR_RESPONSE_TYPE.DOCUMENT,\n        xml: LoaderResource.XHR_RESPONSE_TYPE.DOCUMENT,\n        tmx: LoaderResource.XHR_RESPONSE_TYPE.DOCUMENT,\n        svg: LoaderResource.XHR_RESPONSE_TYPE.DOCUMENT,\n\n        // This was added to handle Tiled Tileset XML, but .tsx is also a TypeScript React Component.\n        // Since it is way less likely for people to be loading TypeScript files instead of Tiled files,\n        // this should probably be fine.\n        tsx: LoaderResource.XHR_RESPONSE_TYPE.DOCUMENT,\n\n        // images\n        gif: LoaderResource.XHR_RESPONSE_TYPE.BLOB,\n        png: LoaderResource.XHR_RESPONSE_TYPE.BLOB,\n        bmp: LoaderResource.XHR_RESPONSE_TYPE.BLOB,\n        jpg: LoaderResource.XHR_RESPONSE_TYPE.BLOB,\n        jpeg: LoaderResource.XHR_RESPONSE_TYPE.BLOB,\n        tif: LoaderResource.XHR_RESPONSE_TYPE.BLOB,\n        tiff: LoaderResource.XHR_RESPONSE_TYPE.BLOB,\n        webp: LoaderResource.XHR_RESPONSE_TYPE.BLOB,\n        tga: LoaderResource.XHR_RESPONSE_TYPE.BLOB,\n        avif: LoaderResource.XHR_RESPONSE_TYPE.BLOB,\n\n        // json\n        json: LoaderResource.XHR_RESPONSE_TYPE.JSON,\n\n        // text\n        text: LoaderResource.XHR_RESPONSE_TYPE.TEXT,\n        txt: LoaderResource.XHR_RESPONSE_TYPE.TEXT,\n\n        // fonts\n        ttf: LoaderResource.XHR_RESPONSE_TYPE.BUFFER,\n        otf: LoaderResource.XHR_RESPONSE_TYPE.BUFFER,\n    };\n\n    // We can't set the `src` attribute to empty string, so on abort we set it to this 1px transparent gif\n    export const EMPTY_GIF = 'data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==';\n}\n\nexport { LoaderResource };\n\n/** @deprecated - Use LoaderResource instead */\nexport type ILoaderResource = LoaderResource;\n","/**\n * Smaller version of the async library constructs.\n * @ignore\n */\nfunction _noop(): void\n{ /* empty */\n}\n\n/**\n * Ensures a function is only called once.\n * @ignore\n * @param {Function} fn - The function to wrap.\n * @returns {Function} The wrapping function.\n */\nfunction onlyOnce(fn: () => void): () => void\n{\n    return function onceWrapper(this: any, ...args: any)\n    {\n        if (fn === null)\n        {\n            throw new Error('Callback was already called.');\n        }\n\n        const callFn = fn;\n\n        fn = null;\n        callFn.apply(this, args);\n    };\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface IQueue\n{\n\n}\n\n/**\n * @private\n * @memberof PIXI\n */\nexport class AsyncQueueItem<TaskData>\n{\n    data: TaskData;\n    callback: (...args: any[]) => void;\n\n    /**\n     * @param data\n     * @param callback\n     * @private\n     */\n    constructor(data: TaskData, callback: (...args: any[]) => void)\n    {\n        this.data = data;\n        this.callback = callback;\n    }\n}\n\n/**\n * @private\n * @memberof PIXI\n */\nexport class AsyncQueue<TaskData>\n{\n    workers = 0;\n\n    concurrency: number;\n    buffer: number;\n\n    saturated: () => void = _noop;\n    unsaturated: () => void = _noop;\n    empty: () => void = _noop;\n    drain: () => void = _noop;\n    error: (err: Error, task: TaskData) => void = _noop;\n\n    started = false;\n    paused = false;\n\n    private _worker: (x: TaskData, next: () => void) => void;\n    _tasks: Array<AsyncQueueItem<TaskData>> = [];\n\n    /**\n     * @param worker\n     * @param concurrency\n     * @private\n     */\n    constructor(worker: (x: TaskData, next: () => void) => void, concurrency = 1)\n    {\n        this._worker = worker;\n\n        if (concurrency === 0)\n        {\n            throw new Error('Concurrency must not be zero');\n        }\n\n        this.concurrency = concurrency;\n        this.buffer = concurrency / 4.0;\n    }\n\n    private _insert = (data: any, insertAtFront: boolean, callback?: () => void) =>\n    {\n        if (callback && typeof callback !== 'function')\n        {\n            throw new Error('task callback must be a function');\n        }\n\n        this.started = true;\n\n        // eslint-disable-next-line no-eq-null,eqeqeq\n        if (data == null && this.idle())\n        {\n            // call drain immediately if there are no tasks\n            setTimeout(() => this.drain(), 1);\n\n            return;\n        }\n\n        const item = new AsyncQueueItem<TaskData>(\n            data,\n            typeof callback === 'function' ? callback : _noop\n        );\n\n        if (insertAtFront)\n        {\n            this._tasks.unshift(item);\n        }\n        else\n        {\n            this._tasks.push(item);\n        }\n\n        setTimeout(this.process, 1);\n    };\n\n    process = (): void =>\n    {\n        while (!this.paused && this.workers < this.concurrency && this._tasks.length)\n        {\n            const task = this._tasks.shift();\n\n            if (this._tasks.length === 0)\n            {\n                this.empty();\n            }\n\n            this.workers += 1;\n\n            if (this.workers === this.concurrency)\n            {\n                this.saturated();\n            }\n\n            this._worker(task.data, onlyOnce(this._next(task)));\n        }\n    };\n\n    /**\n     * @param task\n     * @private\n     */\n    _next(task: AsyncQueueItem<TaskData>): (...args: any) => void\n    {\n        return (...args: any) =>\n        {\n            this.workers -= 1;\n\n            task.callback(...args);\n\n            // eslint-disable-next-line no-eq-null,eqeqeq\n            if (args[0] != null)\n            {\n                this.error(args[0], task.data);\n            }\n\n            if (this.workers <= (this.concurrency - this.buffer))\n            {\n                this.unsaturated();\n            }\n\n            if (this.idle())\n            {\n                this.drain();\n            }\n\n            this.process();\n        };\n    }\n\n    // That was in object\n\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n    push(data: any, callback?: (...args: any[]) => void): void\n    {\n        this._insert(data, false, callback);\n    }\n\n    kill(): void\n    {\n        this.workers = 0;\n        this.drain = _noop;\n        this.started = false;\n        this._tasks = [];\n    }\n\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n    unshift(data: any, callback?: (...args: any[]) => void): void\n    {\n        this._insert(data, true, callback);\n    }\n\n    length(): number\n    {\n        return this._tasks.length;\n    }\n\n    running(): number\n    {\n        return this.workers;\n    }\n\n    idle(): boolean\n    {\n        return this._tasks.length + this.workers === 0;\n    }\n\n    pause(): void\n    {\n        if (this.paused === true)\n        {\n            return;\n        }\n\n        this.paused = true;\n    }\n\n    resume(): void\n    {\n        if (this.paused === false)\n        {\n            return;\n        }\n\n        this.paused = false;\n\n        // Need to call this.process once per concurrent\n        // worker to preserve full concurrency after pause\n        for (let w = 1; w <= this.concurrency; w++)\n        {\n            this.process();\n        }\n    }\n\n    /**\n     * Iterates an array in series.\n     * @param {Array.<*>} array - Array to iterate.\n     * @param {Function} iterator - Function to call for each element.\n     * @param {Function} callback - Function to call when done, or on error.\n     * @param {boolean} [deferNext=false] - Break synchronous each loop by calling next with a setTimeout of 1.\n     */\n    static eachSeries(array: Array<any>, iterator: (x: any, next: (err?: any) => void) => void,\n        callback?: (err?: any) => void, deferNext?: boolean): void\n    {\n        let i = 0;\n        const len = array.length;\n\n        function next(err?: any)\n        {\n            if (err || i === len)\n            {\n                if (callback)\n                {\n                    callback(err);\n                }\n\n                return;\n            }\n\n            if (deferNext)\n            {\n                setTimeout(() =>\n                {\n                    iterator(array[i++], next);\n                }, 1);\n            }\n            else\n            {\n                iterator(array[i++], next);\n            }\n        }\n\n        next();\n    }\n\n    /**\n     * Async queue implementation,\n     * @param {Function} worker - The worker function to call for each task.\n     * @param {number} concurrency - How many workers to run in parrallel.\n     * @returns {*} The async queue object.\n     */\n    static queue(worker: (x: any, next: (...args: any) => void) => void, concurrency?: number): AsyncQueue<any>\n    {\n        return new AsyncQueue<any>(worker, concurrency);\n    }\n}\n","import { Signal } from './base/Signal';\nimport { parseUri } from './base/parseUri';\nimport type { IResourceMetadata } from './LoaderResource';\nimport { LoaderResource } from './LoaderResource';\nimport { AsyncQueue } from './base/AsyncQueue';\nimport type { Dict } from '@pixi/utils';\nimport { deprecation } from '@pixi/utils';\nimport { extensions, ExtensionType } from '@pixi/core';\n\n// some constants\nconst MAX_PROGRESS = 100;\nconst rgxExtractUrlHash = /(#[\\w-]+)?$/;\n\nexport type ILoaderMiddleware = (resource: LoaderResource, next: (...args: any[]) => void) => void;\n\nexport interface ILoaderAdd\n{\n    (this: Loader, name: string, url: string, callback?: LoaderResource.OnCompleteSignal): Loader;\n    (this: Loader, name: string, url: string, options?: IAddOptions, callback?: LoaderResource.OnCompleteSignal): Loader;\n    (this: Loader, url: string, callback?: LoaderResource.OnCompleteSignal): Loader;\n    (this: Loader, url: string, options?: IAddOptions, callback?: LoaderResource.OnCompleteSignal): Loader;\n    (this: Loader, options: IAddOptions, callback?: LoaderResource.OnCompleteSignal): Loader;\n    (this: Loader, resources: (IAddOptions | string)[], callback?: LoaderResource.OnCompleteSignal): Loader;\n}\n\n/**\n * Options for a call to `.add()`.\n * @see Loader#add\n * @property {string} name - The name of the resource to load, if not passed the url is used.\n * @property {string} key - Alias for `name`.\n * @property {string} url - The url for this resource, relative to the baseUrl of this loader.\n * @property {string|boolean} crossOrigin - Is this request cross-origin? Default is to determine automatically.\n * @property {number} [timeout=0] - A timeout in milliseconds for the load. If the load takes longer\n *      than this time it is cancelled and the load is considered a failure. If this value is\n *      set to `0` then there is no explicit timeout.\n * @property {LoaderResource.LOAD_TYPE} [loadType=LoaderResource.LOAD_TYPE.XHR] - How should this resource be loaded?\n * @property {LoaderResource.XHR_RESPONSE_TYPE} [xhrType=LoaderResource.XHR_RESPONSE_TYPE.DEFAULT] - How should the data\n *      being loaded be interpreted when using XHR?\n * @property {LoaderResource.OnCompleteSignal} onComplete - Callback to add an an onComplete signal istener.\n * @property {LoaderResource.OnCompleteSignal} callback - Alias for `onComplete`.\n * @property {IResourceMetadata} metadata - Extra configuration for middleware and the Resource object.\n */\nexport interface IAddOptions\n{\n    name?: string;\n    key?: string;\n    url?: string;\n    crossOrigin?: string | boolean;\n    timeout?: number;\n    parentResource?: LoaderResource;\n    loadType?: LoaderResource.LOAD_TYPE;\n    xhrType?: LoaderResource.XHR_RESPONSE_TYPE;\n    onComplete?: LoaderResource.OnCompleteSignal;\n    callback?: LoaderResource.OnCompleteSignal;\n    metadata?: IResourceMetadata;\n}\n\n/**\n * The new loader, forked from Resource Loader by Chad Engler: https://github.com/englercj/resource-loader\n *\n * ```js\n * const loader = PIXI.Loader.shared; // PixiJS exposes a premade instance for you to use.\n * // or\n * const loader = new PIXI.Loader(); // You can also create your own if you want\n *\n * const sprites = {};\n *\n * // Chainable `add` to enqueue a resource\n * loader.add('bunny', 'data/bunny.png')\n *       .add('spaceship', 'assets/spritesheet.json');\n * loader.add('scoreFont', 'assets/score.fnt');\n *\n * // Chainable `pre` to add a middleware that runs for each resource, *before* loading that resource.\n * // This is useful to implement custom caching modules (using filesystem, indexeddb, memory, etc).\n * loader.pre(cachingMiddleware);\n *\n * // Chainable `use` to add a middleware that runs for each resource, *after* loading that resource.\n * // This is useful to implement custom parsing modules (like spritesheet parsers, spine parser, etc).\n * loader.use(parsingMiddleware);\n *\n * // The `load` method loads the queue of resources, and calls the passed in callback called once all\n * // resources have loaded.\n * loader.load((loader, resources) => {\n *     // resources is an object where the key is the name of the resource loaded and the value is the resource object.\n *     // They have a couple default properties:\n *     // - `url`: The URL that the resource was loaded from\n *     // - `error`: The error that happened when trying to load (if any)\n *     // - `data`: The raw data that was loaded\n *     // also may contain other properties based on the middleware that runs.\n *     sprites.bunny = new PIXI.TilingSprite(resources.bunny.texture);\n *     sprites.spaceship = new PIXI.TilingSprite(resources.spaceship.texture);\n *     sprites.scoreFont = new PIXI.TilingSprite(resources.scoreFont.texture);\n * });\n *\n * // throughout the process multiple signals can be dispatched.\n * loader.onProgress.add(() => {}); // called once per loaded/errored file\n * loader.onError.add(() => {}); // called once per errored file\n * loader.onLoad.add(() => {}); // called once per loaded file\n * loader.onComplete.add(() => {}); // called once when the queued resources all load.\n * ```\n * @memberof PIXI\n */\nclass Loader\n{\n    /** The base url for all resources loaded by this loader. */\n    baseUrl: string;\n\n    /** The progress percent of the loader going through the queue. */\n    progress = 0;\n\n    /** Loading state of the loader, true if it is currently loading resources. */\n    loading = false;\n\n    /**\n     * A querystring to append to every URL added to the loader.\n     *\n     * This should be a valid query string *without* the question-mark (`?`). The loader will\n     * also *not* escape values for you. Make sure to escape your parameters with\n     * [`encodeURIComponent`](https://mdn.io/encodeURIComponent) before assigning this property.\n     * @example\n     * const loader = new Loader();\n     *\n     * loader.defaultQueryString = 'user=me&password=secret';\n     *\n     * // This will request 'image.png?user=me&password=secret'\n     * loader.add('image.png').load();\n     *\n     * loader.reset();\n     *\n     * // This will request 'image.png?v=1&user=me&password=secret'\n     * loader.add('iamge.png?v=1').load();\n     */\n    defaultQueryString = '';\n\n    /** The middleware to run before loading each resource. */\n    private _beforeMiddleware: Array<ILoaderMiddleware> = [];\n\n    /** The middleware to run after loading each resource. */\n    private _afterMiddleware: Array<ILoaderMiddleware> = [];\n\n    /** The tracks the resources we are currently completing parsing for. */\n    private _resourcesParsing: Array<LoaderResource> = [];\n\n    /**\n     * The `_loadResource` function bound with this object context.\n     * @param r - The resource to load\n     * @param d - The dequeue function\n     */\n    private _boundLoadResource = (r: LoaderResource, d: () => void): void => this._loadResource(r, d);\n\n    /** The resources waiting to be loaded. */\n    private _queue: AsyncQueue<any>;\n\n    /** All the resources for this loader keyed by name. */\n    resources: Dict<LoaderResource> = {};\n\n    /** Dispatched once per loaded or errored resource. */\n    onProgress: Signal<Loader.OnProgressSignal>;\n\n    /** Dispatched once per errored resource. */\n    onError: Signal<Loader.OnErrorSignal>;\n\n    /** Dispatched once per loaded resource. */\n    onLoad: Signal<Loader.OnLoadSignal>;\n\n    /** Dispatched when the loader begins to process the queue. */\n    onStart: Signal<Loader.OnStartSignal>;\n\n    /** Dispatched when the queued resources all load. */\n    onComplete: Signal<Loader.OnCompleteSignal>;\n\n    /**\n     * @param baseUrl - The base url for all resources loaded by this loader.\n     * @param concurrency - The number of resources to load concurrently.\n     */\n    constructor(baseUrl = '', concurrency = 10)\n    {\n        this.baseUrl = baseUrl;\n        this._beforeMiddleware = [];\n        this._afterMiddleware = [];\n        this._resourcesParsing = [];\n        this._boundLoadResource = (r, d) => this._loadResource(r, d);\n        this._queue = AsyncQueue.queue(this._boundLoadResource, concurrency);\n        this._queue.pause();\n        this.resources = {};\n        this.onProgress = new Signal();\n        this.onError = new Signal();\n        this.onLoad = new Signal();\n        this.onStart = new Signal();\n        this.onComplete = new Signal();\n\n        for (let i = 0; i < Loader._plugins.length; ++i)\n        {\n            const plugin = Loader._plugins[i];\n            const { pre, use } = plugin;\n\n            if (pre)\n            {\n                this.pre(pre);\n            }\n\n            if (use)\n            {\n                this.use(use);\n            }\n        }\n\n        this._protected = false;\n    }\n\n    /**\n     * Adds a resource (or multiple resources) to the loader queue.\n     *\n     * This function can take a wide variety of different parameters. The only thing that is always\n     * required the url to load. All the following will work:\n     *\n     * ```js\n     * loader\n     *     // normal param syntax\n     *     .add('key', 'http://...', function () {})\n     *     .add('http://...', function () {})\n     *     .add('http://...')\n     *\n     *     // object syntax\n     *     .add({\n     *         name: 'key2',\n     *         url: 'http://...'\n     *     }, function () {})\n     *     .add({\n     *         url: 'http://...'\n     *     }, function () {})\n     *     .add({\n     *         name: 'key3',\n     *         url: 'http://...'\n     *         onComplete: function () {}\n     *     })\n     *     .add({\n     *         url: 'https://...',\n     *         onComplete: function () {},\n     *         crossOrigin: true\n     *     })\n     *\n     *     // you can also pass an array of objects or urls or both\n     *     .add([\n     *         { name: 'key4', url: 'http://...', onComplete: function () {} },\n     *         { url: 'http://...', onComplete: function () {} },\n     *         'http://...'\n     *     ])\n     *\n     *     // and you can use both params and options\n     *     .add('key', 'http://...', { crossOrigin: true }, function () {})\n     *     .add('http://...', { crossOrigin: true }, function () {});\n     * ```\n     */\n    add: ILoaderAdd;\n\n    /**\n     * Same as add, params have strict order\n     * @private\n     * @param name - The name of the resource to load.\n     * @param url - The url for this resource, relative to the baseUrl of this loader.\n     * @param options - The options for the load.\n     * @param callback - Function to call when this specific resource completes loading.\n     * @returns The loader itself.\n     */\n    protected _add(name: string, url: string, options: IAddOptions, callback?: LoaderResource.OnCompleteSignal): this\n    {\n        // if loading already you can only add resources that have a parent.\n        if (this.loading && (!options || !options.parentResource))\n        {\n            throw new Error('Cannot add resources while the loader is running.');\n        }\n\n        // check if resource already exists.\n        if (this.resources[name])\n        {\n            throw new Error(`Resource named \"${name}\" already exists.`);\n        }\n\n        // add base url if this isn't an absolute url\n        url = this._prepareUrl(url);\n\n        // create the store the resource\n        this.resources[name] = new LoaderResource(name, url, options);\n\n        if (typeof callback === 'function')\n        {\n            this.resources[name].onAfterMiddleware.once(callback);\n        }\n\n        // if actively loading, make sure to adjust progress chunks for that parent and its children\n        if (this.loading)\n        {\n            const parent = options.parentResource;\n            const incompleteChildren = [];\n\n            for (let i = 0; i < parent.children.length; ++i)\n            {\n                if (!parent.children[i].isComplete)\n                {\n                    incompleteChildren.push(parent.children[i]);\n                }\n            }\n\n            const fullChunk = parent.progressChunk * (incompleteChildren.length + 1); // +1 for parent\n            const eachChunk = fullChunk / (incompleteChildren.length + 2); // +2 for parent & new child\n\n            parent.children.push(this.resources[name]);\n            parent.progressChunk = eachChunk;\n\n            for (let i = 0; i < incompleteChildren.length; ++i)\n            {\n                incompleteChildren[i].progressChunk = eachChunk;\n            }\n\n            this.resources[name].progressChunk = eachChunk;\n        }\n\n        // add the resource to the queue\n        this._queue.push(this.resources[name]);\n\n        return this;\n    }\n\n    /* eslint-enable require-jsdoc,valid-jsdoc */\n\n    /**\n     * Sets up a middleware function that will run *before* the\n     * resource is loaded.\n     * @param fn - The middleware function to register.\n     * @returns The loader itself.\n     */\n    pre(fn: ILoaderMiddleware): this\n    {\n        this._beforeMiddleware.push(fn);\n\n        return this;\n    }\n\n    /**\n     * Sets up a middleware function that will run *after* the\n     * resource is loaded.\n     * @param fn - The middleware function to register.\n     * @returns The loader itself.\n     */\n    use(fn: ILoaderMiddleware): this\n    {\n        this._afterMiddleware.push(fn);\n\n        return this;\n    }\n\n    /**\n     * Resets the queue of the loader to prepare for a new load.\n     * @returns The loader itself.\n     */\n    reset(): this\n    {\n        this.progress = 0;\n        this.loading = false;\n\n        this._queue.kill();\n        this._queue.pause();\n\n        // abort all resource loads\n        for (const k in this.resources)\n        {\n            const res = this.resources[k];\n\n            if (res._onLoadBinding)\n            {\n                res._onLoadBinding.detach();\n            }\n\n            if (res.isLoading)\n            {\n                res.abort('loader reset');\n            }\n        }\n\n        this.resources = {};\n\n        return this;\n    }\n\n    /**\n     * Starts loading the queued resources.\n     * @param cb - Optional callback that will be bound to the `complete` event.\n     * @returns The loader itself.\n     */\n    load(cb?: Loader.OnCompleteSignal): this\n    {\n        // #if _DEBUG\n        deprecation('6.5.0', '@pixi/loaders is being replaced with @pixi/assets in the next major release.');\n        // #endif\n\n        // register complete callback if they pass one\n        if (typeof cb === 'function')\n        {\n            this.onComplete.once(cb);\n        }\n\n        // if the queue has already started we are done here\n        if (this.loading)\n        {\n            return this;\n        }\n\n        if (this._queue.idle())\n        {\n            this._onStart();\n            this._onComplete();\n        }\n        else\n        {\n            // distribute progress chunks\n            const numTasks = this._queue._tasks.length;\n            const chunk = MAX_PROGRESS / numTasks;\n\n            for (let i = 0; i < this._queue._tasks.length; ++i)\n            {\n                this._queue._tasks[i].data.progressChunk = chunk;\n            }\n\n            // notify we are starting\n            this._onStart();\n\n            // start loading\n            this._queue.resume();\n        }\n\n        return this;\n    }\n\n    /**\n     * The number of resources to load concurrently.\n     * @default 10\n     */\n    get concurrency(): number\n    {\n        return this._queue.concurrency;\n    }\n    set concurrency(concurrency: number)\n    {\n        this._queue.concurrency = concurrency;\n    }\n\n    /**\n     * Prepares a url for usage based on the configuration of this object\n     * @param url - The url to prepare.\n     * @returns The prepared url.\n     */\n    private _prepareUrl(url: string): string\n    {\n        const parsedUrl = parseUri(url, { strictMode: true });\n        let result;\n\n        // absolute url, just use it as is.\n        if (parsedUrl.protocol || !parsedUrl.path || url.indexOf('//') === 0)\n        {\n            result = url;\n        }\n        // if baseUrl doesn't end in slash and url doesn't start with slash, then add a slash inbetween\n        else if (this.baseUrl.length\n            && this.baseUrl.lastIndexOf('/') !== this.baseUrl.length - 1\n            && url.charAt(0) !== '/'\n        )\n        {\n            result = `${this.baseUrl}/${url}`;\n        }\n        else\n        {\n            result = this.baseUrl + url;\n        }\n\n        // if we need to add a default querystring, there is a bit more work\n        if (this.defaultQueryString)\n        {\n            const hash = rgxExtractUrlHash.exec(result)[0];\n\n            result = result.slice(0, result.length - hash.length);\n\n            if (result.indexOf('?') !== -1)\n            {\n                result += `&${this.defaultQueryString}`;\n            }\n            else\n            {\n                result += `?${this.defaultQueryString}`;\n            }\n\n            result += hash;\n        }\n\n        return result;\n    }\n\n    /**\n     * Loads a single resource.\n     * @param resource - The resource to load.\n     * @param dequeue - The function to call when we need to dequeue this item.\n     */\n    private _loadResource(resource: LoaderResource, dequeue: () => void): void\n    {\n        resource._dequeue = dequeue;\n\n        // run before middleware\n        AsyncQueue.eachSeries(\n            this._beforeMiddleware,\n            (fn: any, next: (...args: any) => void) =>\n            {\n                fn.call(this, resource, () =>\n                {\n                    // if the before middleware marks the resource as complete,\n                    // break and don't process any more before middleware\n                    next(resource.isComplete ? {} : null);\n                });\n            },\n            () =>\n            {\n                if (resource.isComplete)\n                {\n                    this._onLoad(resource);\n                }\n                else\n                {\n                    resource._onLoadBinding = resource.onComplete.once(this._onLoad, this);\n                    resource.load();\n                }\n            },\n            true\n        );\n    }\n\n    /** Called once loading has started. */\n    private _onStart(): void\n    {\n        this.progress = 0;\n        this.loading = true;\n        this.onStart.dispatch(this);\n    }\n\n    /** Called once each resource has loaded. */\n    private _onComplete(): void\n    {\n        this.progress = MAX_PROGRESS;\n        this.loading = false;\n        this.onComplete.dispatch(this, this.resources);\n    }\n\n    /**\n     * Called each time a resources is loaded.\n     * @param resource - The resource that was loaded\n     */\n    private _onLoad(resource: LoaderResource): void\n    {\n        resource._onLoadBinding = null;\n\n        // remove this resource from the async queue, and add it to our list of resources that are being parsed\n        this._resourcesParsing.push(resource);\n        resource._dequeue();\n\n        // run all the after middleware for this resource\n        AsyncQueue.eachSeries(\n            this._afterMiddleware,\n            (fn: any, next: any) =>\n            {\n                fn.call(this, resource, next);\n            },\n            () =>\n            {\n                resource.onAfterMiddleware.dispatch(resource);\n\n                this.progress = Math.min(MAX_PROGRESS, this.progress + resource.progressChunk);\n                this.onProgress.dispatch(this, resource);\n\n                if (resource.error)\n                {\n                    this.onError.dispatch(resource.error, this, resource);\n                }\n                else\n                {\n                    this.onLoad.dispatch(this, resource);\n                }\n\n                this._resourcesParsing.splice(this._resourcesParsing.indexOf(resource), 1);\n\n                // do completion check\n                if (this._queue.idle() && this._resourcesParsing.length === 0)\n                {\n                    this._onComplete();\n                }\n            },\n            true\n        );\n    }\n\n    static _plugins: Array<ILoaderPlugin> = [];\n    private static _shared: Loader;\n    /**\n     * If this loader cannot be destroyed.\n     * @default false\n     */\n    private _protected: boolean;\n\n    /** Destroy the loader, removes references. */\n    public destroy(): void\n    {\n        if (!this._protected)\n        {\n            this.reset();\n        }\n    }\n\n    /** A premade instance of the loader that can be used to load resources. */\n    public static get shared(): Loader\n    {\n        let shared = Loader._shared;\n\n        if (!shared)\n        {\n            shared = new Loader();\n            shared._protected = true;\n            Loader._shared = shared;\n        }\n\n        return shared;\n    }\n\n    /**\n     * Use the {@link PIXI.extensions.add} API to register plugins.\n     * @deprecated since 6.5.0\n     * @param plugin - The plugin to add\n     * @returns Reference to PIXI.Loader for chaining\n     */\n    public static registerPlugin(plugin: ILoaderPlugin): typeof Loader\n    {\n        // #if _DEBUG\n        deprecation('6.5.0', 'Loader.registerPlugin() is deprecated, use extensions.add() instead.');\n        // #endif\n\n        extensions.add({\n            type: ExtensionType.Loader,\n            ref: plugin,\n        });\n\n        return Loader;\n    }\n}\n\nextensions.handleByList(ExtensionType.Loader, Loader._plugins);\n\nLoader.prototype.add = function add(this: Loader, name: any, url?: any, options?: any, callback?: any): Loader\n{\n    // special case of an array of objects or urls\n    if (Array.isArray(name))\n    {\n        for (let i = 0; i < name.length; ++i)\n        {\n            this.add((name as any)[i]);\n        }\n\n        return this;\n    }\n\n    // if an object is passed instead of params\n    if (typeof name === 'object')\n    {\n        options = name;\n        callback = (url as any) || options.callback || options.onComplete;\n        url = options.url;\n        name = options.name || options.key || options.url;\n    }\n\n    // case where no name is passed shift all args over by one.\n    if (typeof url !== 'string')\n    {\n        callback = options as any;\n        options = url;\n        url = name;\n    }\n\n    // now that we shifted make sure we have a proper url.\n    if (typeof url !== 'string')\n    {\n        throw new Error('No url passed to add resource to loader.');\n    }\n\n    // options are optional so people might pass a function and no options\n    if (typeof options === 'function')\n    {\n        callback = options;\n        options = null;\n    }\n\n    return this._add(name, url, options, callback);\n};\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\nnamespace Loader\n{\n    /**\n     * When the resource starts to load.\n     * @param resource - The resource that the event happened on.\n     */\n    export type OnStartSignal = (loader: Loader) => void;\n    /**\n     * When the progress changes the loader and resource are dispatched.\n     * @param loader - The loader the progress is advancing on.\n     * @param resource - The resource that has completed or failed to cause the progress to advance.\n     */\n    export type OnProgressSignal = (loader: Loader, resource: LoaderResource) => void;\n    /**\n     * When a load completes without error the loader and resource are dispatched.\n     * @param loader - The loader that has started loading resources.\n     * @param resource - The resource that has completed.\n     */\n    export type OnLoadSignal = (loader: Loader, resource: LoaderResource) => void;\n    /**\n     * When the loader starts loading resources it dispatches this callback.\n     * @param loader - The loader that has started loading resources.\n     */\n    export type OnCompleteSignal = (loader: Loader, resources: Dict<LoaderResource>) => void;\n    /**\n     * When an error occurs the loader and resource are dispatched.\n     * @param loader - The loader the error happened in.\n     * @param resource - The resource that caused the error.\n     */\n    export type OnErrorSignal = (error: Error, loader: Loader, resource: LoaderResource) => void;\n}\n\nexport { Loader };\n\n/**\n * Plugin to be installed for handling specific Loader resources.\n * @property {Function} add - Function to call immediate after registering plugin.\n * @property {Function} pre - Middleware function to run before load, the\n *           arguments for this are `(resource, next)`\n * @property {Function} use - Middleware function to run after load, the\n *           arguments for this are `(resource, next)`\n */\nexport interface ILoaderPlugin\n{\n    /** Function to call immediate after registering plugin. */\n    add?(): void;\n\n    /**\n     * Middleware function to run before load\n     * @param {LoaderResource} resource - resource\n     * @param {LoaderResource} next - next middleware\n     */\n    pre?(resource: LoaderResource, next: (...args: any[]) => void): void;\n\n    /**\n     * Middleware function to run after load\n     * @param {LoaderResource} resource - resource\n     * @param {LoaderResource} next - next middleware\n     */\n    use?(resource: LoaderResource, next: (...args: any[]) => void): void;\n}\n","import type { ExtensionMetadata } from '@pixi/core';\nimport { ExtensionType } from '@pixi/core';\nimport { Loader } from './Loader';\n\n/**\n * Application plugin for supporting loader option. Installing the LoaderPlugin\n * is not necessary if using **pixi.js** or **pixi.js-legacy**.\n * @example\n * import {AppLoaderPlugin} from '@pixi/loaders';\n * import {extensions} from '@pixi/core';\n * extensions.add(AppLoaderPlugin);\n * @memberof PIXI\n */\nexport class AppLoaderPlugin\n{\n    /** @ignore */\n    static extension: ExtensionMetadata = ExtensionType.Application;\n\n    /**\n     * Loader instance to help with asset loading.\n     * @memberof PIXI.Application#\n     * @readonly\n     */\n    public static loader: Loader;\n\n    /**\n     * Called on application constructor\n     * @param options\n     * @private\n     */\n    static init(options?: GlobalMixins.IApplicationOptions): void\n    {\n        options = Object.assign({\n            sharedLoader: false,\n        }, options);\n\n        this.loader = options.sharedLoader ? Loader.shared : new Loader();\n    }\n\n    /**\n     * Called when application destroyed\n     * @private\n     */\n    static destroy(): void\n    {\n        if (this.loader)\n        {\n            this.loader.destroy();\n            this.loader = null;\n        }\n    }\n}\n","import type { ExtensionMetadata } from '@pixi/core';\nimport { ExtensionType, Texture } from '@pixi/core';\nimport { LoaderResource } from './LoaderResource';\n\n/**\n * Loader plugin for handling Texture resources.\n * @memberof PIXI\n */\nexport class TextureLoader\n{\n    /** @ignore */\n    static extension: ExtensionMetadata = ExtensionType.Loader;\n\n    /** Handle SVG elements a text, render with SVGResource. */\n    public static add(): void\n    {\n        LoaderResource.setExtensionLoadType('svg', LoaderResource.LOAD_TYPE.XHR);\n        LoaderResource.setExtensionXhrType('svg', LoaderResource.XHR_RESPONSE_TYPE.TEXT);\n    }\n\n    /**\n     * Called after a resource is loaded.\n     * @see PIXI.Loader.loaderMiddleware\n     * @param resource\n     * @param {Function} next\n     */\n    public static use(resource: LoaderResource, next: (...args: any[]) => void): void\n    {\n        // create a new texture if the data is an Image object\n        if (resource.data && (resource.type === LoaderResource.TYPE.IMAGE || resource.extension === 'svg'))\n        {\n            const { data, url, name, metadata } = resource;\n\n            Texture.fromLoader(data, url, name, metadata).then((texture) =>\n            {\n                resource.texture = texture;\n                next();\n            })\n            // TODO: handle errors in Texture.fromLoader\n            // so we can pass them to the Loader\n                .catch(next);\n        }\n        else\n        {\n            next();\n        }\n    }\n}\n","const _keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\n/**\n * Encodes binary into base64.\n * @function encodeBinary\n * @param {string} input - The input data to encode.\n * @returns {string} The encoded base64 string\n */\nexport function encodeBinary(input: string): string\n{\n    let output = '';\n    let inx = 0;\n\n    while (inx < input.length)\n    {\n        // Fill byte buffer array\n        const bytebuffer = [0, 0, 0];\n        const encodedCharIndexes = [0, 0, 0, 0];\n\n        for (let jnx = 0; jnx < bytebuffer.length; ++jnx)\n        {\n            if (inx < input.length)\n            {\n                // throw away high-order byte, as documented at:\n                // https://developer.mozilla.org/En/Using_XMLHttpRequest#Handling_binary_data\n                bytebuffer[jnx] = input.charCodeAt(inx++) & 0xff;\n            }\n            else\n            {\n                bytebuffer[jnx] = 0;\n            }\n        }\n\n        // Get each encoded character, 6 bits at a time\n        // index 1: first 6 bits\n        encodedCharIndexes[0] = bytebuffer[0] >> 2;\n\n        // index 2: second 6 bits (2 least significant bits from input byte 1 + 4 most significant bits from byte 2)\n        encodedCharIndexes[1] = ((bytebuffer[0] & 0x3) << 4) | (bytebuffer[1] >> 4);\n\n        // index 3: third 6 bits (4 least significant bits from input byte 2 + 2 most significant bits from byte 3)\n        encodedCharIndexes[2] = ((bytebuffer[1] & 0x0f) << 2) | (bytebuffer[2] >> 6);\n\n        // index 3: forth 6 bits (6 least significant bits from input byte 3)\n        encodedCharIndexes[3] = bytebuffer[2] & 0x3f;\n\n        // Determine whether padding happened, and adjust accordingly\n        const paddingBytes = inx - (input.length - 1);\n\n        switch (paddingBytes)\n        {\n            case 2:\n                // Set last 2 characters to padding char\n                encodedCharIndexes[3] = 64;\n                encodedCharIndexes[2] = 64;\n                break;\n\n            case 1:\n                // Set last character to padding char\n                encodedCharIndexes[3] = 64;\n                break;\n\n            default:\n                break; // No padding - proceed\n        }\n\n        // Now we will grab each appropriate character out of our keystring\n        // based on our index array and append it to the output string\n        for (let jnx = 0; jnx < encodedCharIndexes.length; ++jnx)\n        {\n            output += _keyStr.charAt(encodedCharIndexes[jnx]);\n        }\n    }\n\n    return output;\n}\n","import { LoaderResource } from '../LoaderResource';\nimport { encodeBinary } from '../base/encodeBinary';\n\n/**\n * A middleware for transforming XHR loaded Blobs into more useful objects\n * @ignore\n * @function parsing\n * @example\n * import { Loader, middleware } from 'resource-loader';\n * const loader = new Loader();\n * loader.use(middleware.parsing);\n * @param resource - Current Resource\n * @param next - Callback when complete\n */\nexport function parsing(resource: LoaderResource, next: (...args: any) => void): void\n{\n    if (!resource.data)\n    {\n        next();\n\n        return;\n    }\n\n    // if this was an XHR load of a blob\n    if (resource.xhr && resource.xhrType === LoaderResource.XHR_RESPONSE_TYPE.BLOB)\n    {\n        // if there is no blob support we probably got a binary string back\n        if (!self.Blob || typeof resource.data === 'string')\n        {\n            const type = resource.xhr.getResponseHeader('content-type');\n\n            // this is an image, convert the binary string into a data url\n            if (type && type.indexOf('image') === 0)\n            {\n                resource.data = new Image();\n                resource.data.src = `data:${type};base64,${encodeBinary(resource.xhr.responseText)}`;\n\n                resource.type = LoaderResource.TYPE.IMAGE;\n\n                // wait until the image loads and then callback\n                resource.data.onload = () =>\n                {\n                    resource.data.onload = null;\n\n                    next();\n                };\n\n                // next will be called on load\n                return;\n            }\n        }\n        // if content type says this is an image, then we should transform the blob into an Image object\n        else if (resource.data.type.indexOf('image') === 0)\n        {\n            const Url = globalThis.URL || globalThis.webkitURL;\n            const src = Url.createObjectURL(resource.data);\n\n            resource.blob = resource.data;\n            resource.data = new Image();\n            resource.data.src = src;\n\n            resource.type = LoaderResource.TYPE.IMAGE;\n\n            // cleanup the no longer used blob after the image loads\n            // TODO: Is this correct? Will the image be invalid after revoking?\n            resource.data.onload = () =>\n            {\n                Url.revokeObjectURL(src);\n                resource.data.onload = null;\n\n                next();\n            };\n\n            // next will be called on load.\n            return;\n        }\n    }\n\n    next();\n}\n","import { parsing } from './middleware';\nimport type { ExtensionMetadata } from '@pixi/core';\nimport { ExtensionType } from '@pixi/core';\n\n/**\n * Parse any blob into more usable objects (e.g. Image).\n * @memberof PIXI\n */\nclass ParsingLoader\n{\n    /** @ignore */\n    static extension: ExtensionMetadata = ExtensionType.Loader;\n\n    static use = parsing;\n}\n\nexport { ParsingLoader };\n","export * from './AppLoaderPlugin';\nexport * from './LoaderResource';\nexport * from './Loader';\nexport * from './TextureLoader';\n\nimport { ParsingLoader } from './ParsingLoader';\nimport { TextureLoader } from './TextureLoader';\nimport { extensions } from '@pixi/core';\n\nextensions.add(\n    TextureLoader,\n    ParsingLoader\n);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}