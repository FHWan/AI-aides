{"ast":null,"code":"import \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.to-array.js\";\n/*!\n * @pixi/sprite-tiling - v6.5.10\n * Compiled Thu, 06 Jul 2023 15:25:11 UTC\n *\n * @pixi/sprite-tiling is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nimport { Texture, TextureMatrix, Shader, ExtensionType, QuadUv, State, ObjectRenderer } from '@pixi/core';\nimport { Point, Rectangle, Transform, Matrix } from '@pixi/math';\nimport { Sprite } from '@pixi/sprite';\nimport { WRAP_MODES } from '@pixi/constants';\nimport { premultiplyTintToRgba, correctBlendMode } from '@pixi/utils';\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n/* global Reflect, Promise */\n\nvar extendStatics = function (d, b) {\n  extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) {\n      if (b.hasOwnProperty(p)) {\n        d[p] = b[p];\n      }\n    }\n  };\n  return extendStatics(d, b);\n};\nfunction __extends(d, b) {\n  extendStatics(d, b);\n  function __() {\n    this.constructor = d;\n  }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\nvar tempPoint = new Point();\n/**\n * A tiling sprite is a fast way of rendering a tiling image.\n * @memberof PIXI\n */\nvar TilingSprite = /** @class */function (_super) {\n  __extends(TilingSprite, _super);\n  /**\n   * @param texture - The texture of the tiling sprite.\n   * @param width - The width of the tiling sprite.\n   * @param height - The height of the tiling sprite.\n   */\n  function TilingSprite(texture, width, height) {\n    if (width === void 0) {\n      width = 100;\n    }\n    if (height === void 0) {\n      height = 100;\n    }\n    var _this = _super.call(this, texture) || this;\n    _this.tileTransform = new Transform();\n    // The width of the tiling sprite\n    _this._width = width;\n    // The height of the tiling sprite\n    _this._height = height;\n    _this.uvMatrix = _this.texture.uvMatrix || new TextureMatrix(texture);\n    /**\n     * Plugin that is responsible for rendering this element.\n     * Allows to customize the rendering process without overriding '_render' method.\n     * @default 'tilingSprite'\n     */\n    _this.pluginName = 'tilingSprite';\n    _this.uvRespectAnchor = false;\n    return _this;\n  }\n  Object.defineProperty(TilingSprite.prototype, \"clampMargin\", {\n    /**\n     * Changes frame clamping in corresponding textureTransform, shortcut\n     * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas\n     * @default 0.5\n     * @member {number}\n     */\n    get: function () {\n      return this.uvMatrix.clampMargin;\n    },\n    set: function (value) {\n      this.uvMatrix.clampMargin = value;\n      this.uvMatrix.update(true);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TilingSprite.prototype, \"tileScale\", {\n    /** The scaling of the image that is being tiled. */\n    get: function () {\n      return this.tileTransform.scale;\n    },\n    set: function (value) {\n      this.tileTransform.scale.copyFrom(value);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TilingSprite.prototype, \"tilePosition\", {\n    /** The offset of the image that is being tiled. */\n    get: function () {\n      return this.tileTransform.position;\n    },\n    set: function (value) {\n      this.tileTransform.position.copyFrom(value);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * @protected\n   */\n  TilingSprite.prototype._onTextureUpdate = function () {\n    if (this.uvMatrix) {\n      this.uvMatrix.texture = this._texture;\n    }\n    this._cachedTint = 0xFFFFFF;\n  };\n  /**\n   * Renders the object using the WebGL renderer\n   * @param renderer - The renderer\n   */\n  TilingSprite.prototype._render = function (renderer) {\n    // tweak our texture temporarily..\n    var texture = this._texture;\n    if (!texture || !texture.valid) {\n      return;\n    }\n    this.tileTransform.updateLocalTransform();\n    this.uvMatrix.update();\n    renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);\n    renderer.plugins[this.pluginName].render(this);\n  };\n  /** Updates the bounds of the tiling sprite. */\n  TilingSprite.prototype._calculateBounds = function () {\n    var minX = this._width * -this._anchor._x;\n    var minY = this._height * -this._anchor._y;\n    var maxX = this._width * (1 - this._anchor._x);\n    var maxY = this._height * (1 - this._anchor._y);\n    this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);\n  };\n  /**\n   * Gets the local bounds of the sprite object.\n   * @param rect - Optional output rectangle.\n   * @returns The bounds.\n   */\n  TilingSprite.prototype.getLocalBounds = function (rect) {\n    // we can do a fast local bounds if the sprite has no children!\n    if (this.children.length === 0) {\n      this._bounds.minX = this._width * -this._anchor._x;\n      this._bounds.minY = this._height * -this._anchor._y;\n      this._bounds.maxX = this._width * (1 - this._anchor._x);\n      this._bounds.maxY = this._height * (1 - this._anchor._y);\n      if (!rect) {\n        if (!this._localBoundsRect) {\n          this._localBoundsRect = new Rectangle();\n        }\n        rect = this._localBoundsRect;\n      }\n      return this._bounds.getRectangle(rect);\n    }\n    return _super.prototype.getLocalBounds.call(this, rect);\n  };\n  /**\n   * Checks if a point is inside this tiling sprite.\n   * @param point - The point to check.\n   * @returns Whether or not the sprite contains the point.\n   */\n  TilingSprite.prototype.containsPoint = function (point) {\n    this.worldTransform.applyInverse(point, tempPoint);\n    var width = this._width;\n    var height = this._height;\n    var x1 = -width * this.anchor._x;\n    if (tempPoint.x >= x1 && tempPoint.x < x1 + width) {\n      var y1 = -height * this.anchor._y;\n      if (tempPoint.y >= y1 && tempPoint.y < y1 + height) {\n        return true;\n      }\n    }\n    return false;\n  };\n  /**\n   * Destroys this sprite and optionally its texture and children\n   * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy\n   *      method called as well. 'options' will be passed on to those calls.\n   * @param {boolean} [options.texture=false] - Should it destroy the current texture of the sprite as well\n   * @param {boolean} [options.baseTexture=false] - Should it destroy the base texture of the sprite as well\n   */\n  TilingSprite.prototype.destroy = function (options) {\n    _super.prototype.destroy.call(this, options);\n    this.tileTransform = null;\n    this.uvMatrix = null;\n  };\n  /**\n   * Helper function that creates a new tiling sprite based on the source you provide.\n   * The source can be - frame id, image url, video url, canvas element, video element, base texture\n   * @static\n   * @param {string|PIXI.Texture|HTMLCanvasElement|HTMLVideoElement} source - Source to create texture from\n   * @param {object} options - See {@link PIXI.BaseTexture}'s constructor for options.\n   * @param {number} options.width - required width of the tiling sprite\n   * @param {number} options.height - required height of the tiling sprite\n   * @returns {PIXI.TilingSprite} The newly created texture\n   */\n  TilingSprite.from = function (source, options) {\n    var texture = source instanceof Texture ? source : Texture.from(source, options);\n    return new TilingSprite(texture, options.width, options.height);\n  };\n  Object.defineProperty(TilingSprite.prototype, \"width\", {\n    /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */\n    get: function () {\n      return this._width;\n    },\n    set: function (value) {\n      this._width = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TilingSprite.prototype, \"height\", {\n    /** The height of the TilingSprite, setting this will actually modify the scale to achieve the value set. */\n    get: function () {\n      return this._height;\n    },\n    set: function (value) {\n      this._height = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return TilingSprite;\n}(Sprite);\nvar fragmentSimpleSrc = \"#version 100\\n#define SHADER_NAME Tiling-Sprite-Simple-100\\n\\nprecision lowp float;\\n\\nvarying vec2 vTextureCoord;\\n\\nuniform sampler2D uSampler;\\nuniform vec4 uColor;\\n\\nvoid main(void)\\n{\\n    vec4 texSample = texture2D(uSampler, vTextureCoord);\\n    gl_FragColor = texSample * uColor;\\n}\\n\";\nvar gl1VertexSrc = \"#version 100\\n#define SHADER_NAME Tiling-Sprite-100\\n\\nprecision lowp float;\\n\\nattribute vec2 aVertexPosition;\\nattribute vec2 aTextureCoord;\\n\\nuniform mat3 projectionMatrix;\\nuniform mat3 translationMatrix;\\nuniform mat3 uTransform;\\n\\nvarying vec2 vTextureCoord;\\n\\nvoid main(void)\\n{\\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n\\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\\n}\\n\";\nvar gl1FragmentSrc = \"#version 100\\n#ifdef GL_EXT_shader_texture_lod\\n    #extension GL_EXT_shader_texture_lod : enable\\n#endif\\n#define SHADER_NAME Tiling-Sprite-100\\n\\nprecision lowp float;\\n\\nvarying vec2 vTextureCoord;\\n\\nuniform sampler2D uSampler;\\nuniform vec4 uColor;\\nuniform mat3 uMapCoord;\\nuniform vec4 uClampFrame;\\nuniform vec2 uClampOffset;\\n\\nvoid main(void)\\n{\\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\\n    vec2 unclamped = coord;\\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\\n\\n    #ifdef GL_EXT_shader_texture_lod\\n        vec4 texSample = unclamped == coord\\n            ? texture2D(uSampler, coord) \\n            : texture2DLodEXT(uSampler, coord, 0);\\n    #else\\n        vec4 texSample = texture2D(uSampler, coord);\\n    #endif\\n\\n    gl_FragColor = texSample * uColor;\\n}\\n\";\nvar gl2VertexSrc = \"#version 300 es\\n#define SHADER_NAME Tiling-Sprite-300\\n\\nprecision lowp float;\\n\\nin vec2 aVertexPosition;\\nin vec2 aTextureCoord;\\n\\nuniform mat3 projectionMatrix;\\nuniform mat3 translationMatrix;\\nuniform mat3 uTransform;\\n\\nout vec2 vTextureCoord;\\n\\nvoid main(void)\\n{\\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n\\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\\n}\\n\";\nvar gl2FragmentSrc = \"#version 300 es\\n#define SHADER_NAME Tiling-Sprite-100\\n\\nprecision lowp float;\\n\\nin vec2 vTextureCoord;\\n\\nout vec4 fragmentColor;\\n\\nuniform sampler2D uSampler;\\nuniform vec4 uColor;\\nuniform mat3 uMapCoord;\\nuniform vec4 uClampFrame;\\nuniform vec2 uClampOffset;\\n\\nvoid main(void)\\n{\\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\\n    vec2 unclamped = coord;\\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\\n\\n    vec4 texSample = texture(uSampler, coord, unclamped == coord ? 0.0f : -32.0f);// lod-bias very negative to force lod 0\\n\\n    fragmentColor = texSample * uColor;\\n}\\n\";\nvar tempMat = new Matrix();\n/**\n * WebGL renderer plugin for tiling sprites\n * @class\n * @memberof PIXI\n * @extends PIXI.ObjectRenderer\n */\nvar TilingSpriteRenderer = /** @class */function (_super) {\n  __extends(TilingSpriteRenderer, _super);\n  /**\n   * constructor for renderer\n   * @param {PIXI.Renderer} renderer - The renderer this tiling awesomeness works for.\n   */\n  function TilingSpriteRenderer(renderer) {\n    var _this = _super.call(this, renderer) || this;\n    // WebGL version is not available during initialization!\n    renderer.runners.contextChange.add(_this);\n    _this.quad = new QuadUv();\n    /**\n     * The WebGL state in which this renderer will work.\n     * @member {PIXI.State}\n     * @readonly\n     */\n    _this.state = State.for2d();\n    return _this;\n  }\n  /** Creates shaders when context is initialized. */\n  TilingSpriteRenderer.prototype.contextChange = function () {\n    var renderer = this.renderer;\n    var uniforms = {\n      globals: renderer.globalUniforms\n    };\n    this.simpleShader = Shader.from(gl1VertexSrc, fragmentSimpleSrc, uniforms);\n    this.shader = renderer.context.webGLVersion > 1 ? Shader.from(gl2VertexSrc, gl2FragmentSrc, uniforms) : Shader.from(gl1VertexSrc, gl1FragmentSrc, uniforms);\n  };\n  /**\n   * @param {PIXI.TilingSprite} ts - tilingSprite to be rendered\n   */\n  TilingSpriteRenderer.prototype.render = function (ts) {\n    var renderer = this.renderer;\n    var quad = this.quad;\n    var vertices = quad.vertices;\n    vertices[0] = vertices[6] = ts._width * -ts.anchor.x;\n    vertices[1] = vertices[3] = ts._height * -ts.anchor.y;\n    vertices[2] = vertices[4] = ts._width * (1.0 - ts.anchor.x);\n    vertices[5] = vertices[7] = ts._height * (1.0 - ts.anchor.y);\n    var anchorX = ts.uvRespectAnchor ? ts.anchor.x : 0;\n    var anchorY = ts.uvRespectAnchor ? ts.anchor.y : 0;\n    vertices = quad.uvs;\n    vertices[0] = vertices[6] = -anchorX;\n    vertices[1] = vertices[3] = -anchorY;\n    vertices[2] = vertices[4] = 1.0 - anchorX;\n    vertices[5] = vertices[7] = 1.0 - anchorY;\n    quad.invalidate();\n    var tex = ts._texture;\n    var baseTex = tex.baseTexture;\n    var premultiplied = baseTex.alphaMode > 0;\n    var lt = ts.tileTransform.localTransform;\n    var uv = ts.uvMatrix;\n    var isSimple = baseTex.isPowerOfTwo && tex.frame.width === baseTex.width && tex.frame.height === baseTex.height;\n    // auto, force repeat wrapMode for big tiling textures\n    if (isSimple) {\n      if (!baseTex._glTextures[renderer.CONTEXT_UID]) {\n        if (baseTex.wrapMode === WRAP_MODES.CLAMP) {\n          baseTex.wrapMode = WRAP_MODES.REPEAT;\n        }\n      } else {\n        isSimple = baseTex.wrapMode !== WRAP_MODES.CLAMP;\n      }\n    }\n    var shader = isSimple ? this.simpleShader : this.shader;\n    var w = tex.width;\n    var h = tex.height;\n    var W = ts._width;\n    var H = ts._height;\n    tempMat.set(lt.a * w / W, lt.b * w / H, lt.c * h / W, lt.d * h / H, lt.tx / W, lt.ty / H);\n    // that part is the same as above:\n    // tempMat.identity();\n    // tempMat.scale(tex.width, tex.height);\n    // tempMat.prepend(lt);\n    // tempMat.scale(1.0 / ts._width, 1.0 / ts._height);\n    tempMat.invert();\n    if (isSimple) {\n      tempMat.prepend(uv.mapCoord);\n    } else {\n      shader.uniforms.uMapCoord = uv.mapCoord.toArray(true);\n      shader.uniforms.uClampFrame = uv.uClampFrame;\n      shader.uniforms.uClampOffset = uv.uClampOffset;\n    }\n    shader.uniforms.uTransform = tempMat.toArray(true);\n    shader.uniforms.uColor = premultiplyTintToRgba(ts.tint, ts.worldAlpha, shader.uniforms.uColor, premultiplied);\n    shader.uniforms.translationMatrix = ts.transform.worldTransform.toArray(true);\n    shader.uniforms.uSampler = tex;\n    renderer.shader.bind(shader);\n    renderer.geometry.bind(quad);\n    this.state.blendMode = correctBlendMode(ts.blendMode, premultiplied);\n    renderer.state.set(this.state);\n    renderer.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0);\n  };\n  /** @ignore */\n  TilingSpriteRenderer.extension = {\n    name: 'tilingSprite',\n    type: ExtensionType.RendererPlugin\n  };\n  return TilingSpriteRenderer;\n}(ObjectRenderer);\nexport { TilingSprite, TilingSpriteRenderer };","map":{"version":3,"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__extends","__","constructor","prototype","create","tempPoint","Point","TilingSprite","_super","texture","width","height","_this","call","tileTransform","Transform","_width","_height","uvMatrix","TextureMatrix","pluginName","uvRespectAnchor","defineProperty","get","clampMargin","set","value","update","scale","copyFrom","position","_onTextureUpdate","_texture","_cachedTint","_render","renderer","valid","updateLocalTransform","batch","setObjectRenderer","plugins","render","_calculateBounds","minX","_anchor","_x","minY","_y","maxX","maxY","_bounds","addFrame","transform","getLocalBounds","rect","children","length","_localBoundsRect","Rectangle","getRectangle","containsPoint","point","worldTransform","applyInverse","x1","anchor","x","y1","y","destroy","options","from","source","Texture","Sprite","tempMat","Matrix","TilingSpriteRenderer","runners","contextChange","add","quad","QuadUv","state","State","for2d","uniforms","globals","globalUniforms","simpleShader","Shader","gl1VertexSrc","fragmentSimpleSrc","shader","context","webGLVersion","gl2VertexSrc","gl2FragmentSrc","gl1FragmentSrc","ts","vertices","anchorX","anchorY","uvs","invalidate","tex","baseTex","baseTexture","premultiplied","alphaMode","lt","localTransform","uv","isSimple","isPowerOfTwo","frame","_glTextures","CONTEXT_UID","wrapMode","WRAP_MODES","CLAMP","REPEAT","w","h","W","H","a","c","tx","ty","invert","prepend","mapCoord","uMapCoord","toArray","uClampFrame","uClampOffset","uTransform","uColor","premultiplyTintToRgba","tint","worldAlpha","translationMatrix","uSampler","bind","geometry","blendMode","correctBlendMode","draw","gl","TRIANGLES","extension","name","type","ExtensionType","RendererPlugin","ObjectRenderer"],"sources":["../../../../node_modules/tslib/tslib.es6.js","../../src/TilingSprite.ts","../../src/TilingSpriteRenderer.ts"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __createBinding(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","import { Texture, TextureMatrix } from '@pixi/core';\nimport { Point, Rectangle, Transform  } from '@pixi/math';\nimport { Sprite } from '@pixi/sprite';\nimport type { Renderer, IBaseTextureOptions, TextureSource } from '@pixi/core';\nimport type { IDestroyOptions } from '@pixi/display';\nimport type { IPoint, IPointData, ISize, ObservablePoint } from '@pixi/math';\n\nconst tempPoint = new Point();\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface TilingSprite extends GlobalMixins.TilingSprite {}\n\n/**\n * A tiling sprite is a fast way of rendering a tiling image.\n * @memberof PIXI\n */\nexport class TilingSprite extends Sprite\n{\n    /** Tile transform */\n    public tileTransform: Transform;\n\n    /** Matrix that is applied to UV to get the coords in Texture normalized space to coords in BaseTexture space. */\n    public uvMatrix: TextureMatrix;\n\n    /**\n     * Flags whether the tiling pattern should originate from the origin instead of the top-left corner in\n     * local space.\n     *\n     * This will make the texture coordinates assigned to each vertex dependent on the value of the anchor. Without\n     * this, the top-left corner always gets the (0, 0) texture coordinate.\n     * @default false\n     */\n    public uvRespectAnchor: boolean;\n\n    /**\n     * @param texture - The texture of the tiling sprite.\n     * @param width - The width of the tiling sprite.\n     * @param height - The height of the tiling sprite.\n     */\n    constructor(texture: Texture, width = 100, height = 100)\n    {\n        super(texture);\n\n        this.tileTransform = new Transform();\n\n        // The width of the tiling sprite\n        this._width = width;\n\n        // The height of the tiling sprite\n        this._height = height;\n\n        this.uvMatrix = this.texture.uvMatrix || new TextureMatrix(texture);\n\n        /**\n         * Plugin that is responsible for rendering this element.\n         * Allows to customize the rendering process without overriding '_render' method.\n         * @default 'tilingSprite'\n         */\n        this.pluginName = 'tilingSprite';\n\n        this.uvRespectAnchor = false;\n    }\n    /**\n     * Changes frame clamping in corresponding textureTransform, shortcut\n     * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas\n     * @default 0.5\n     * @member {number}\n     */\n    get clampMargin(): number\n    {\n        return this.uvMatrix.clampMargin;\n    }\n\n    set clampMargin(value: number)\n    {\n        this.uvMatrix.clampMargin = value;\n        this.uvMatrix.update(true);\n    }\n\n    /** The scaling of the image that is being tiled. */\n    get tileScale(): ObservablePoint\n    {\n        return this.tileTransform.scale;\n    }\n\n    set tileScale(value: IPointData)\n    {\n        this.tileTransform.scale.copyFrom(value as IPoint);\n    }\n\n    /** The offset of the image that is being tiled. */\n    get tilePosition(): ObservablePoint\n    {\n        return this.tileTransform.position;\n    }\n\n    set tilePosition(value: ObservablePoint)\n    {\n        this.tileTransform.position.copyFrom(value as IPoint);\n    }\n\n    /**\n     * @protected\n     */\n    protected _onTextureUpdate(): void\n    {\n        if (this.uvMatrix)\n        {\n            this.uvMatrix.texture = this._texture;\n        }\n        this._cachedTint = 0xFFFFFF;\n    }\n\n    /**\n     * Renders the object using the WebGL renderer\n     * @param renderer - The renderer\n     */\n    protected _render(renderer: Renderer): void\n    {\n        // tweak our texture temporarily..\n        const texture = this._texture;\n\n        if (!texture || !texture.valid)\n        {\n            return;\n        }\n\n        this.tileTransform.updateLocalTransform();\n        this.uvMatrix.update();\n\n        renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);\n        renderer.plugins[this.pluginName].render(this);\n    }\n\n    /** Updates the bounds of the tiling sprite. */\n    protected _calculateBounds(): void\n    {\n        const minX = this._width * -this._anchor._x;\n        const minY = this._height * -this._anchor._y;\n        const maxX = this._width * (1 - this._anchor._x);\n        const maxY = this._height * (1 - this._anchor._y);\n\n        this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);\n    }\n\n    /**\n     * Gets the local bounds of the sprite object.\n     * @param rect - Optional output rectangle.\n     * @returns The bounds.\n     */\n    public getLocalBounds(rect?: Rectangle): Rectangle\n    {\n        // we can do a fast local bounds if the sprite has no children!\n        if (this.children.length === 0)\n        {\n            this._bounds.minX = this._width * -this._anchor._x;\n            this._bounds.minY = this._height * -this._anchor._y;\n            this._bounds.maxX = this._width * (1 - this._anchor._x);\n            this._bounds.maxY = this._height * (1 - this._anchor._y);\n\n            if (!rect)\n            {\n                if (!this._localBoundsRect)\n                {\n                    this._localBoundsRect = new Rectangle();\n                }\n\n                rect = this._localBoundsRect;\n            }\n\n            return this._bounds.getRectangle(rect);\n        }\n\n        return super.getLocalBounds.call(this, rect);\n    }\n\n    /**\n     * Checks if a point is inside this tiling sprite.\n     * @param point - The point to check.\n     * @returns Whether or not the sprite contains the point.\n     */\n    public containsPoint(point: IPointData): boolean\n    {\n        this.worldTransform.applyInverse(point, tempPoint);\n\n        const width = this._width;\n        const height = this._height;\n        const x1 = -width * this.anchor._x;\n\n        if (tempPoint.x >= x1 && tempPoint.x < x1 + width)\n        {\n            const y1 = -height * this.anchor._y;\n\n            if (tempPoint.y >= y1 && tempPoint.y < y1 + height)\n            {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Destroys this sprite and optionally its texture and children\n     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy\n     *      method called as well. 'options' will be passed on to those calls.\n     * @param {boolean} [options.texture=false] - Should it destroy the current texture of the sprite as well\n     * @param {boolean} [options.baseTexture=false] - Should it destroy the base texture of the sprite as well\n     */\n    public destroy(options?: IDestroyOptions | boolean): void\n    {\n        super.destroy(options);\n\n        this.tileTransform = null;\n        this.uvMatrix = null;\n    }\n\n    /**\n     * Helper function that creates a new tiling sprite based on the source you provide.\n     * The source can be - frame id, image url, video url, canvas element, video element, base texture\n     * @static\n     * @param {string|PIXI.Texture|HTMLCanvasElement|HTMLVideoElement} source - Source to create texture from\n     * @param {object} options - See {@link PIXI.BaseTexture}'s constructor for options.\n     * @param {number} options.width - required width of the tiling sprite\n     * @param {number} options.height - required height of the tiling sprite\n     * @returns {PIXI.TilingSprite} The newly created texture\n     */\n    static from(source: TextureSource | Texture, options: ISize & IBaseTextureOptions): TilingSprite\n    {\n        const texture = (source instanceof Texture)\n            ? source\n            : Texture.from(source, options);\n\n        return new TilingSprite(\n            texture,\n            options.width,\n            options.height\n        );\n    }\n\n    /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */\n    get width(): number\n    {\n        return this._width;\n    }\n\n    set width(value: number)\n    {\n        this._width = value;\n    }\n\n    /** The height of the TilingSprite, setting this will actually modify the scale to achieve the value set. */\n    get height(): number\n    {\n        return this._height;\n    }\n\n    set height(value: number)\n    {\n        this._height = value;\n    }\n}\n","import { ObjectRenderer, Shader, State, QuadUv, ExtensionType } from '@pixi/core';\nimport { WRAP_MODES } from '@pixi/constants';\nimport { Matrix } from '@pixi/math';\nimport { premultiplyTintToRgba, correctBlendMode } from '@pixi/utils';\n\nimport fragmentSimpleSrc from './sprite-tiling-simple.frag';\nimport gl1VertexSrc from './sprite-tiling-fallback.vert';\nimport gl1FragmentSrc from './sprite-tiling-fallback.frag';\nimport gl2VertexSrc from './sprite-tiling.vert';\nimport gl2FragmentSrc from './sprite-tiling.frag';\n\nimport type { Renderer, ExtensionMetadata } from '@pixi/core';\nimport type { TilingSprite } from './TilingSprite';\n\nconst tempMat = new Matrix();\n\n/**\n * WebGL renderer plugin for tiling sprites\n * @class\n * @memberof PIXI\n * @extends PIXI.ObjectRenderer\n */\nexport class TilingSpriteRenderer extends ObjectRenderer\n{\n    /** @ignore */\n    static extension: ExtensionMetadata = {\n        name: 'tilingSprite',\n        type: ExtensionType.RendererPlugin,\n    };\n\n    public shader: Shader;\n    public simpleShader: Shader;\n    public quad: QuadUv;\n    public readonly state: State;\n\n    /**\n     * constructor for renderer\n     * @param {PIXI.Renderer} renderer - The renderer this tiling awesomeness works for.\n     */\n    constructor(renderer: Renderer)\n    {\n        super(renderer);\n\n        // WebGL version is not available during initialization!\n        renderer.runners.contextChange.add(this);\n\n        this.quad = new QuadUv();\n\n        /**\n         * The WebGL state in which this renderer will work.\n         * @member {PIXI.State}\n         * @readonly\n         */\n        this.state = State.for2d();\n    }\n\n    /** Creates shaders when context is initialized. */\n    contextChange(): void\n    {\n        const renderer = this.renderer;\n        const uniforms = { globals: renderer.globalUniforms };\n\n        this.simpleShader = Shader.from(gl1VertexSrc, fragmentSimpleSrc, uniforms);\n        this.shader = renderer.context.webGLVersion > 1\n            ? Shader.from(gl2VertexSrc, gl2FragmentSrc, uniforms)\n            : Shader.from(gl1VertexSrc, gl1FragmentSrc, uniforms);\n    }\n\n    /**\n     * @param {PIXI.TilingSprite} ts - tilingSprite to be rendered\n     */\n    public render(ts: TilingSprite): void\n    {\n        const renderer = this.renderer;\n        const quad = this.quad;\n\n        let vertices = quad.vertices;\n\n        vertices[0] = vertices[6] = (ts._width) * -ts.anchor.x;\n        vertices[1] = vertices[3] = ts._height * -ts.anchor.y;\n\n        vertices[2] = vertices[4] = (ts._width) * (1.0 - ts.anchor.x);\n        vertices[5] = vertices[7] = ts._height * (1.0 - ts.anchor.y);\n\n        const anchorX = ts.uvRespectAnchor ? ts.anchor.x : 0;\n        const anchorY = ts.uvRespectAnchor ? ts.anchor.y : 0;\n\n        vertices = quad.uvs;\n\n        vertices[0] = vertices[6] = -anchorX;\n        vertices[1] = vertices[3] = -anchorY;\n\n        vertices[2] = vertices[4] = 1.0 - anchorX;\n        vertices[5] = vertices[7] = 1.0 - anchorY;\n\n        quad.invalidate();\n\n        const tex = ts._texture;\n        const baseTex = tex.baseTexture;\n        const premultiplied = baseTex.alphaMode > 0;\n        const lt = ts.tileTransform.localTransform;\n        const uv = ts.uvMatrix;\n        let isSimple = baseTex.isPowerOfTwo\n            && tex.frame.width === baseTex.width && tex.frame.height === baseTex.height;\n\n        // auto, force repeat wrapMode for big tiling textures\n        if (isSimple)\n        {\n            if (!baseTex._glTextures[renderer.CONTEXT_UID])\n            {\n                if (baseTex.wrapMode === WRAP_MODES.CLAMP)\n                {\n                    baseTex.wrapMode = WRAP_MODES.REPEAT;\n                }\n            }\n            else\n            {\n                isSimple = baseTex.wrapMode !== WRAP_MODES.CLAMP;\n            }\n        }\n\n        const shader = isSimple ? this.simpleShader : this.shader;\n\n        const w = tex.width;\n        const h = tex.height;\n        const W = ts._width;\n        const H = ts._height;\n\n        tempMat.set(lt.a * w / W,\n            lt.b * w / H,\n            lt.c * h / W,\n            lt.d * h / H,\n            lt.tx / W,\n            lt.ty / H);\n\n        // that part is the same as above:\n        // tempMat.identity();\n        // tempMat.scale(tex.width, tex.height);\n        // tempMat.prepend(lt);\n        // tempMat.scale(1.0 / ts._width, 1.0 / ts._height);\n\n        tempMat.invert();\n        if (isSimple)\n        {\n            tempMat.prepend(uv.mapCoord);\n        }\n        else\n        {\n            shader.uniforms.uMapCoord = uv.mapCoord.toArray(true);\n            shader.uniforms.uClampFrame = uv.uClampFrame;\n            shader.uniforms.uClampOffset = uv.uClampOffset;\n        }\n\n        shader.uniforms.uTransform = tempMat.toArray(true);\n        shader.uniforms.uColor = premultiplyTintToRgba(ts.tint, ts.worldAlpha,\n            shader.uniforms.uColor, premultiplied);\n        shader.uniforms.translationMatrix = ts.transform.worldTransform.toArray(true);\n        shader.uniforms.uSampler = tex;\n\n        renderer.shader.bind(shader);\n        renderer.geometry.bind(quad);\n\n        this.state.blendMode = correctBlendMode(ts.blendMode, premultiplied);\n        renderer.state.set(this.state);\n        renderer.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}