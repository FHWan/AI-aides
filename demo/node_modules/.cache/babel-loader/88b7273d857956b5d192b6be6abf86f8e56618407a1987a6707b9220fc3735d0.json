{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.some.js\";\n/*!\n * @pixi/spritesheet - v6.5.10\n * Compiled Thu, 06 Jul 2023 15:25:11 UTC\n *\n * @pixi/spritesheet is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nimport { Rectangle } from '@pixi/math';\nimport { Texture, BaseTexture, ExtensionType } from '@pixi/core';\nimport { getResolutionOfUrl, deprecation, url } from '@pixi/utils';\nimport { LoaderResource } from '@pixi/loaders';\n\n/**\n * Utility class for maintaining reference to a collection\n * of Textures on a single Spritesheet.\n *\n * To access a sprite sheet from your code you may pass its JSON data file to Pixi's loader:\n *\n * ```js\n * PIXI.Loader.shared.add(\"images/spritesheet.json\").load(setup);\n *\n * function setup() {\n *   let sheet = PIXI.Loader.shared.resources[\"images/spritesheet.json\"].spritesheet;\n *   ...\n * }\n * ```\n *\n * Alternately, you may circumvent the loader by instantiating the Spritesheet directly:\n * ```js\n * const sheet = new PIXI.Spritesheet(texture, spritesheetData);\n * await sheet.parse();\n * console.log('Spritesheet ready to use!');\n * ```\n *\n * With the `sheet.textures` you can create Sprite objects,`sheet.animations` can be used to create an AnimatedSprite.\n *\n * Sprite sheets can be packed using tools like {@link https://codeandweb.com/texturepacker|TexturePacker},\n * {@link https://renderhjs.net/shoebox/|Shoebox} or {@link https://github.com/krzysztof-o/spritesheet.js|Spritesheet.js}.\n * Default anchor points (see {@link PIXI.Texture#defaultAnchor}) and grouping of animation sprites are currently only\n * supported by TexturePacker.\n * @memberof PIXI\n */\nvar Spritesheet = /** @class */function () {\n  /**\n   * @param texture - Reference to the source BaseTexture object.\n   * @param {object} data - Spritesheet image data.\n   * @param resolutionFilename - The filename to consider when determining\n   *        the resolution of the spritesheet. If not provided, the imageUrl will\n   *        be used on the BaseTexture.\n   */\n  function Spritesheet(texture, data, resolutionFilename) {\n    if (resolutionFilename === void 0) {\n      resolutionFilename = null;\n    }\n    /** For multi-packed spritesheets, this contains a reference to all the other spritesheets it depends on. */\n    this.linkedSheets = [];\n    this._texture = texture instanceof Texture ? texture : null;\n    this.baseTexture = texture instanceof BaseTexture ? texture : this._texture.baseTexture;\n    this.textures = {};\n    this.animations = {};\n    this.data = data;\n    var resource = this.baseTexture.resource;\n    this.resolution = this._updateResolution(resolutionFilename || (resource ? resource.url : null));\n    this._frames = this.data.frames;\n    this._frameKeys = Object.keys(this._frames);\n    this._batchIndex = 0;\n    this._callback = null;\n  }\n  /**\n   * Generate the resolution from the filename or fallback\n   * to the meta.scale field of the JSON data.\n   * @param resolutionFilename - The filename to use for resolving\n   *        the default resolution.\n   * @returns Resolution to use for spritesheet.\n   */\n  Spritesheet.prototype._updateResolution = function (resolutionFilename) {\n    if (resolutionFilename === void 0) {\n      resolutionFilename = null;\n    }\n    var scale = this.data.meta.scale;\n    // Use a defaultValue of `null` to check if a url-based resolution is set\n    var resolution = getResolutionOfUrl(resolutionFilename, null);\n    // No resolution found via URL\n    if (resolution === null) {\n      // Use the scale value or default to 1\n      resolution = scale !== undefined ? parseFloat(scale) : 1;\n    }\n    // For non-1 resolutions, update baseTexture\n    if (resolution !== 1) {\n      this.baseTexture.setResolution(resolution);\n    }\n    return resolution;\n  };\n  /** @ignore */\n  Spritesheet.prototype.parse = function (callback) {\n    var _this = this;\n    if (callback) {\n      deprecation('6.5.0', 'Spritesheet.parse callback is deprecated, use the return Promise instead.');\n    }\n    return new Promise(function (resolve) {\n      _this._callback = function (textures) {\n        callback === null || callback === void 0 ? void 0 : callback(textures);\n        resolve(textures);\n      };\n      _this._batchIndex = 0;\n      if (_this._frameKeys.length <= Spritesheet.BATCH_SIZE) {\n        _this._processFrames(0);\n        _this._processAnimations();\n        _this._parseComplete();\n      } else {\n        _this._nextBatch();\n      }\n    });\n  };\n  /**\n   * Process a batch of frames\n   * @param initialFrameIndex - The index of frame to start.\n   */\n  Spritesheet.prototype._processFrames = function (initialFrameIndex) {\n    var frameIndex = initialFrameIndex;\n    var maxFrames = Spritesheet.BATCH_SIZE;\n    while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length) {\n      var i = this._frameKeys[frameIndex];\n      var data = this._frames[i];\n      var rect = data.frame;\n      if (rect) {\n        var frame = null;\n        var trim = null;\n        var sourceSize = data.trimmed !== false && data.sourceSize ? data.sourceSize : data.frame;\n        var orig = new Rectangle(0, 0, Math.floor(sourceSize.w) / this.resolution, Math.floor(sourceSize.h) / this.resolution);\n        if (data.rotated) {\n          frame = new Rectangle(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.h) / this.resolution, Math.floor(rect.w) / this.resolution);\n        } else {\n          frame = new Rectangle(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);\n        }\n        //  Check to see if the sprite is trimmed\n        if (data.trimmed !== false && data.spriteSourceSize) {\n          trim = new Rectangle(Math.floor(data.spriteSourceSize.x) / this.resolution, Math.floor(data.spriteSourceSize.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);\n        }\n        this.textures[i] = new Texture(this.baseTexture, frame, orig, trim, data.rotated ? 2 : 0, data.anchor);\n        // lets also add the frame to pixi's global cache for 'from' and 'fromLoader' functions\n        Texture.addToCache(this.textures[i], i);\n      }\n      frameIndex++;\n    }\n  };\n  /** Parse animations config. */\n  Spritesheet.prototype._processAnimations = function () {\n    var animations = this.data.animations || {};\n    for (var animName in animations) {\n      this.animations[animName] = [];\n      for (var i = 0; i < animations[animName].length; i++) {\n        var frameName = animations[animName][i];\n        this.animations[animName].push(this.textures[frameName]);\n      }\n    }\n  };\n  /** The parse has completed. */\n  Spritesheet.prototype._parseComplete = function () {\n    var callback = this._callback;\n    this._callback = null;\n    this._batchIndex = 0;\n    callback.call(this, this.textures);\n  };\n  /** Begin the next batch of textures. */\n  Spritesheet.prototype._nextBatch = function () {\n    var _this = this;\n    this._processFrames(this._batchIndex * Spritesheet.BATCH_SIZE);\n    this._batchIndex++;\n    setTimeout(function () {\n      if (_this._batchIndex * Spritesheet.BATCH_SIZE < _this._frameKeys.length) {\n        _this._nextBatch();\n      } else {\n        _this._processAnimations();\n        _this._parseComplete();\n      }\n    }, 0);\n  };\n  /**\n   * Destroy Spritesheet and don't use after this.\n   * @param {boolean} [destroyBase=false] - Whether to destroy the base texture as well\n   */\n  Spritesheet.prototype.destroy = function (destroyBase) {\n    var _a;\n    if (destroyBase === void 0) {\n      destroyBase = false;\n    }\n    for (var i in this.textures) {\n      this.textures[i].destroy();\n    }\n    this._frames = null;\n    this._frameKeys = null;\n    this.data = null;\n    this.textures = null;\n    if (destroyBase) {\n      (_a = this._texture) === null || _a === void 0 ? void 0 : _a.destroy();\n      this.baseTexture.destroy();\n    }\n    this._texture = null;\n    this.baseTexture = null;\n    this.linkedSheets = [];\n  };\n  /** The maximum number of Textures to build per process. */\n  Spritesheet.BATCH_SIZE = 1000;\n  return Spritesheet;\n}();\n/**\n * Reference to Spritesheet object created.\n * @member {PIXI.Spritesheet} spritesheet\n * @memberof PIXI.LoaderResource\n * @instance\n */\n/**\n * Dictionary of textures from Spritesheet.\n * @member {Object<string, PIXI.Texture>} textures\n * @memberof PIXI.LoaderResource\n * @instance\n */\n\n/**\n * {@link PIXI.Loader} middleware for loading texture atlases that have been created with\n * TexturePacker or similar JSON-based spritesheet.\n *\n * This middleware automatically generates Texture resources.\n *\n * If you're using Webpack or other bundlers and plan on bundling the atlas' JSON,\n * use the {@link PIXI.Spritesheet} class to directly parse the JSON.\n *\n * The Loader's image Resource name is automatically appended with `\"_image\"`.\n * If a Resource with this name is already loaded, the Loader will skip parsing the\n * Spritesheet. The code below will generate an internal Loader Resource called `\"myatlas_image\"`.\n * @example\n * loader.add('myatlas', 'path/to/myatlas.json');\n * loader.load(() => {\n *   loader.resources.myatlas; // atlas JSON resource\n *   loader.resources.myatlas_image; // atlas Image resource\n * });\n * @memberof PIXI\n */\nvar SpritesheetLoader = /** @class */function () {\n  function SpritesheetLoader() {}\n  /**\n   * Called after a resource is loaded.\n   * @see PIXI.Loader.loaderMiddleware\n   * @param resource\n   * @param next\n   */\n  SpritesheetLoader.use = function (resource, next) {\n    var _a, _b;\n    // because this is middleware, it execute in loader context. `this` = loader\n    var loader = this;\n    var imageResourceName = resource.name + \"_image\";\n    // skip if no data, its not json, it isn't spritesheet data, or the image resource already exists\n    if (!resource.data || resource.type !== LoaderResource.TYPE.JSON || !resource.data.frames || loader.resources[imageResourceName]) {\n      next();\n      return;\n    }\n    // Check and add the multi atlas\n    // Heavily influenced and based on https://github.com/rocket-ua/pixi-tps-loader/blob/master/src/ResourceLoader.js\n    // eslint-disable-next-line camelcase\n    var multiPacks = (_b = (_a = resource.data) === null || _a === void 0 ? void 0 : _a.meta) === null || _b === void 0 ? void 0 : _b.related_multi_packs;\n    if (Array.isArray(multiPacks)) {\n      var _loop_1 = function (item) {\n        if (typeof item !== 'string') {\n          return \"continue\";\n        }\n        var itemName = item.replace('.json', '');\n        var itemUrl = url.resolve(resource.url.replace(loader.baseUrl, ''), item);\n        // Check if the file wasn't already added as multipacks are redundant\n        if (loader.resources[itemName] || Object.values(loader.resources).some(function (r) {\n          return url.format(url.parse(r.url)) === itemUrl;\n        })) {\n          return \"continue\";\n        }\n        var options = {\n          crossOrigin: resource.crossOrigin,\n          loadType: LoaderResource.LOAD_TYPE.XHR,\n          xhrType: LoaderResource.XHR_RESPONSE_TYPE.JSON,\n          parentResource: resource,\n          metadata: resource.metadata\n        };\n        loader.add(itemName, itemUrl, options);\n      };\n      for (var _i = 0, multiPacks_1 = multiPacks; _i < multiPacks_1.length; _i++) {\n        var item = multiPacks_1[_i];\n        _loop_1(item);\n      }\n    }\n    var loadOptions = {\n      crossOrigin: resource.crossOrigin,\n      metadata: resource.metadata.imageMetadata,\n      parentResource: resource\n    };\n    var resourcePath = SpritesheetLoader.getResourcePath(resource, loader.baseUrl);\n    // load the image for this sheet\n    loader.add(imageResourceName, resourcePath, loadOptions, function onImageLoad(res) {\n      if (res.error) {\n        next(res.error);\n        return;\n      }\n      var spritesheet = new Spritesheet(res.texture, resource.data, resource.url);\n      spritesheet.parse().then(function () {\n        resource.spritesheet = spritesheet;\n        resource.textures = spritesheet.textures;\n        next();\n      });\n    });\n  };\n  /**\n   * Get the spritesheets root path\n   * @param resource - Resource to check path\n   * @param baseUrl - Base root url\n   */\n  SpritesheetLoader.getResourcePath = function (resource, baseUrl) {\n    // Prepend url path unless the resource image is a data url\n    if (resource.isDataUrl) {\n      return resource.data.meta.image;\n    }\n    return url.resolve(resource.url.replace(baseUrl, ''), resource.data.meta.image);\n  };\n  /** @ignore */\n  SpritesheetLoader.extension = ExtensionType.Loader;\n  return SpritesheetLoader;\n}();\nexport { Spritesheet, SpritesheetLoader };","map":{"version":3,"names":["Spritesheet","texture","data","resolutionFilename","linkedSheets","_texture","Texture","baseTexture","BaseTexture","textures","animations","resource","resolution","_updateResolution","url","_frames","frames","_frameKeys","Object","keys","_batchIndex","_callback","prototype","scale","meta","getResolutionOfUrl","undefined","parseFloat","setResolution","parse","callback","_this","deprecation","Promise","resolve","length","BATCH_SIZE","_processFrames","_processAnimations","_parseComplete","_nextBatch","initialFrameIndex","frameIndex","maxFrames","i","rect","frame","trim","sourceSize","trimmed","orig","Rectangle","Math","floor","w","h","rotated","x","y","spriteSourceSize","anchor","addToCache","animName","frameName","push","call","setTimeout","destroy","destroyBase","_a","SpritesheetLoader","use","next","loader","imageResourceName","name","type","LoaderResource","TYPE","JSON","resources","multiPacks","_b","related_multi_packs","Array","isArray","item","itemName","replace","itemUrl","baseUrl","values","some","r","format","options","crossOrigin","loadType","LOAD_TYPE","XHR","xhrType","XHR_RESPONSE_TYPE","parentResource","metadata","add","_i","multiPacks_1","loadOptions","imageMetadata","resourcePath","getResourcePath","onImageLoad","res","error","spritesheet","then","isDataUrl","image","extension","ExtensionType","Loader"],"sources":["../../src/Spritesheet.ts","../../src/SpritesheetLoader.ts"],"sourcesContent":["import { Rectangle } from '@pixi/math';\nimport { Texture, BaseTexture } from '@pixi/core';\nimport { deprecation, getResolutionOfUrl } from '@pixi/utils';\nimport type { Dict } from '@pixi/utils';\nimport type { ImageResource } from '@pixi/core';\nimport type { IPointData } from '@pixi/math';\n\n/** Represents the JSON data for a spritesheet atlas. */\nexport interface ISpritesheetFrameData\n{\n    frame: {\n        x: number;\n        y: number;\n        w: number;\n        h: number;\n    };\n    trimmed?: boolean;\n    rotated?: boolean;\n    sourceSize?: {\n        w: number;\n        h: number;\n    };\n    spriteSourceSize?: {\n        x: number;\n        y: number;\n    };\n    anchor?: IPointData;\n}\n\n/** Atlas format. */\nexport interface ISpritesheetData\n{\n    frames: Dict<ISpritesheetFrameData>;\n    animations?: Dict<string[]>;\n    meta: {\n        scale: string;\n        // eslint-disable-next-line camelcase\n        related_multi_packs?: string[];\n    };\n}\n\n/**\n * Utility class for maintaining reference to a collection\n * of Textures on a single Spritesheet.\n *\n * To access a sprite sheet from your code you may pass its JSON data file to Pixi's loader:\n *\n * ```js\n * PIXI.Loader.shared.add(\"images/spritesheet.json\").load(setup);\n *\n * function setup() {\n *   let sheet = PIXI.Loader.shared.resources[\"images/spritesheet.json\"].spritesheet;\n *   ...\n * }\n * ```\n *\n * Alternately, you may circumvent the loader by instantiating the Spritesheet directly:\n * ```js\n * const sheet = new PIXI.Spritesheet(texture, spritesheetData);\n * await sheet.parse();\n * console.log('Spritesheet ready to use!');\n * ```\n *\n * With the `sheet.textures` you can create Sprite objects,`sheet.animations` can be used to create an AnimatedSprite.\n *\n * Sprite sheets can be packed using tools like {@link https://codeandweb.com/texturepacker|TexturePacker},\n * {@link https://renderhjs.net/shoebox/|Shoebox} or {@link https://github.com/krzysztof-o/spritesheet.js|Spritesheet.js}.\n * Default anchor points (see {@link PIXI.Texture#defaultAnchor}) and grouping of animation sprites are currently only\n * supported by TexturePacker.\n * @memberof PIXI\n */\nexport class Spritesheet\n{\n    /** The maximum number of Textures to build per process. */\n    static readonly BATCH_SIZE = 1000;\n\n    /** For multi-packed spritesheets, this contains a reference to all the other spritesheets it depends on. */\n    public linkedSheets: Spritesheet[] = [];\n\n    /** Reference to ths source texture. */\n    public baseTexture: BaseTexture;\n\n    /**\n     * A map containing all textures of the sprite sheet.\n     * Can be used to create a {@link PIXI.Sprite|Sprite}:\n     * ```js\n     * new PIXI.Sprite(sheet.textures[\"image.png\"]);\n     * ```\n     */\n    public textures: Dict<Texture>;\n\n    /**\n     * A map containing the textures for each animation.\n     * Can be used to create an {@link PIXI.AnimatedSprite|AnimatedSprite}:\n     * ```js\n     * new PIXI.AnimatedSprite(sheet.animations[\"anim_name\"])\n     * ```\n     */\n    public animations: Dict<Texture[]>;\n\n    /**\n     * Reference to the original JSON data.\n     * @type {object}\n     */\n    public data: ISpritesheetData;\n\n    /** The resolution of the spritesheet. */\n    public resolution: number;\n\n    /**\n     * Reference to original source image from the Loader. This reference is retained so we\n     * can destroy the Texture later on. It is never used internally.\n     */\n    private _texture: Texture;\n\n    /**\n     * Map of spritesheet frames.\n     * @type {object}\n     */\n    private _frames: Dict<ISpritesheetFrameData>;\n\n    /** Collection of frame names. */\n    private _frameKeys: string[];\n\n    /** Current batch index being processed. */\n    private _batchIndex: number;\n\n    /**\n     * Callback when parse is completed.\n     * @type {Function}\n     */\n    private _callback: (textures: Dict<Texture>) => void;\n\n    /**\n     * @param texture - Reference to the source BaseTexture object.\n     * @param {object} data - Spritesheet image data.\n     * @param resolutionFilename - The filename to consider when determining\n     *        the resolution of the spritesheet. If not provided, the imageUrl will\n     *        be used on the BaseTexture.\n     */\n    constructor(texture: BaseTexture | Texture, data: ISpritesheetData, resolutionFilename: string = null)\n    {\n        this._texture = texture instanceof Texture ? texture : null;\n        this.baseTexture = texture instanceof BaseTexture ? texture : this._texture.baseTexture;\n        this.textures = {};\n        this.animations = {};\n        this.data = data;\n\n        const resource = this.baseTexture.resource as ImageResource;\n\n        this.resolution = this._updateResolution(resolutionFilename || (resource ? resource.url : null));\n        this._frames = this.data.frames;\n        this._frameKeys = Object.keys(this._frames);\n        this._batchIndex = 0;\n        this._callback = null;\n    }\n\n    /**\n     * Generate the resolution from the filename or fallback\n     * to the meta.scale field of the JSON data.\n     * @param resolutionFilename - The filename to use for resolving\n     *        the default resolution.\n     * @returns Resolution to use for spritesheet.\n     */\n    private _updateResolution(resolutionFilename: string = null): number\n    {\n        const { scale } = this.data.meta;\n\n        // Use a defaultValue of `null` to check if a url-based resolution is set\n        let resolution = getResolutionOfUrl(resolutionFilename, null);\n\n        // No resolution found via URL\n        if (resolution === null)\n        {\n            // Use the scale value or default to 1\n            resolution = scale !== undefined ? parseFloat(scale) : 1;\n        }\n\n        // For non-1 resolutions, update baseTexture\n        if (resolution !== 1)\n        {\n            this.baseTexture.setResolution(resolution);\n        }\n\n        return resolution;\n    }\n\n    /**\n     * Parser spritesheet from loaded data. This is done asynchronously\n     * to prevent creating too many Texture within a single process.\n     * @method PIXI.Spritesheet#parse\n     */\n    public parse(): Promise<Dict<Texture>>;\n\n    /**\n     * Please use the Promise-based version of this function.\n     * @method PIXI.Spritesheet#parse\n     * @deprecated since version 6.5.0\n     * @param {Function} callback - Callback when complete returns\n     *        a map of the Textures for this spritesheet.\n     */\n    public parse(callback?: (textures?: Dict<Texture>) => void): void;\n\n    /** @ignore */\n    public parse(callback?: (textures?: Dict<Texture>) => void): Promise<Dict<Texture>>\n    {\n        // #if _DEBUG\n        if (callback)\n        {\n            deprecation('6.5.0', 'Spritesheet.parse callback is deprecated, use the return Promise instead.');\n        }\n        // #endif\n\n        return new Promise((resolve) =>\n        {\n            this._callback = (textures: Dict<Texture>) =>\n            {\n                callback?.(textures);\n                resolve(textures);\n            };\n            this._batchIndex = 0;\n\n            if (this._frameKeys.length <= Spritesheet.BATCH_SIZE)\n            {\n                this._processFrames(0);\n                this._processAnimations();\n                this._parseComplete();\n            }\n            else\n            {\n                this._nextBatch();\n            }\n        });\n    }\n\n    /**\n     * Process a batch of frames\n     * @param initialFrameIndex - The index of frame to start.\n     */\n    private _processFrames(initialFrameIndex: number): void\n    {\n        let frameIndex = initialFrameIndex;\n        const maxFrames = Spritesheet.BATCH_SIZE;\n\n        while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length)\n        {\n            const i = this._frameKeys[frameIndex];\n            const data = this._frames[i];\n            const rect = data.frame;\n\n            if (rect)\n            {\n                let frame = null;\n                let trim = null;\n                const sourceSize = data.trimmed !== false && data.sourceSize\n                    ? data.sourceSize : data.frame;\n\n                const orig = new Rectangle(\n                    0,\n                    0,\n                    Math.floor(sourceSize.w) / this.resolution,\n                    Math.floor(sourceSize.h) / this.resolution\n                );\n\n                if (data.rotated)\n                {\n                    frame = new Rectangle(\n                        Math.floor(rect.x) / this.resolution,\n                        Math.floor(rect.y) / this.resolution,\n                        Math.floor(rect.h) / this.resolution,\n                        Math.floor(rect.w) / this.resolution\n                    );\n                }\n                else\n                {\n                    frame = new Rectangle(\n                        Math.floor(rect.x) / this.resolution,\n                        Math.floor(rect.y) / this.resolution,\n                        Math.floor(rect.w) / this.resolution,\n                        Math.floor(rect.h) / this.resolution\n                    );\n                }\n\n                //  Check to see if the sprite is trimmed\n                if (data.trimmed !== false && data.spriteSourceSize)\n                {\n                    trim = new Rectangle(\n                        Math.floor(data.spriteSourceSize.x) / this.resolution,\n                        Math.floor(data.spriteSourceSize.y) / this.resolution,\n                        Math.floor(rect.w) / this.resolution,\n                        Math.floor(rect.h) / this.resolution\n                    );\n                }\n\n                this.textures[i] = new Texture(\n                    this.baseTexture,\n                    frame,\n                    orig,\n                    trim,\n                    data.rotated ? 2 : 0,\n                    data.anchor\n                );\n\n                // lets also add the frame to pixi's global cache for 'from' and 'fromLoader' functions\n                Texture.addToCache(this.textures[i], i);\n            }\n\n            frameIndex++;\n        }\n    }\n\n    /** Parse animations config. */\n    private _processAnimations(): void\n    {\n        const animations = this.data.animations || {};\n\n        for (const animName in animations)\n        {\n            this.animations[animName] = [];\n            for (let i = 0; i < animations[animName].length; i++)\n            {\n                const frameName = animations[animName][i];\n\n                this.animations[animName].push(this.textures[frameName]);\n            }\n        }\n    }\n\n    /** The parse has completed. */\n    private _parseComplete(): void\n    {\n        const callback = this._callback;\n\n        this._callback = null;\n        this._batchIndex = 0;\n        callback.call(this, this.textures);\n    }\n\n    /** Begin the next batch of textures. */\n    private _nextBatch(): void\n    {\n        this._processFrames(this._batchIndex * Spritesheet.BATCH_SIZE);\n        this._batchIndex++;\n        setTimeout(() =>\n        {\n            if (this._batchIndex * Spritesheet.BATCH_SIZE < this._frameKeys.length)\n            {\n                this._nextBatch();\n            }\n            else\n            {\n                this._processAnimations();\n                this._parseComplete();\n            }\n        }, 0);\n    }\n\n    /**\n     * Destroy Spritesheet and don't use after this.\n     * @param {boolean} [destroyBase=false] - Whether to destroy the base texture as well\n     */\n    public destroy(destroyBase = false): void\n    {\n        for (const i in this.textures)\n        {\n            this.textures[i].destroy();\n        }\n        this._frames = null;\n        this._frameKeys = null;\n        this.data = null;\n        this.textures = null;\n        if (destroyBase)\n        {\n            this._texture?.destroy();\n            this.baseTexture.destroy();\n        }\n        this._texture = null;\n        this.baseTexture = null;\n        this.linkedSheets = [];\n    }\n}\n\n/**\n * Reference to Spritesheet object created.\n * @member {PIXI.Spritesheet} spritesheet\n * @memberof PIXI.LoaderResource\n * @instance\n */\n\n/**\n * Dictionary of textures from Spritesheet.\n * @member {Object<string, PIXI.Texture>} textures\n * @memberof PIXI.LoaderResource\n * @instance\n */\n","import { url } from '@pixi/utils';\nimport { Spritesheet } from './Spritesheet';\nimport { LoaderResource } from '@pixi/loaders';\nimport type { Loader } from '@pixi/loaders';\nimport type { ExtensionMetadata } from '@pixi/core';\nimport { ExtensionType } from '@pixi/core';\n\n/**\n * {@link PIXI.Loader} middleware for loading texture atlases that have been created with\n * TexturePacker or similar JSON-based spritesheet.\n *\n * This middleware automatically generates Texture resources.\n *\n * If you're using Webpack or other bundlers and plan on bundling the atlas' JSON,\n * use the {@link PIXI.Spritesheet} class to directly parse the JSON.\n *\n * The Loader's image Resource name is automatically appended with `\"_image\"`.\n * If a Resource with this name is already loaded, the Loader will skip parsing the\n * Spritesheet. The code below will generate an internal Loader Resource called `\"myatlas_image\"`.\n * @example\n * loader.add('myatlas', 'path/to/myatlas.json');\n * loader.load(() => {\n *   loader.resources.myatlas; // atlas JSON resource\n *   loader.resources.myatlas_image; // atlas Image resource\n * });\n * @memberof PIXI\n */\nexport class SpritesheetLoader\n{\n    /** @ignore */\n    static extension: ExtensionMetadata = ExtensionType.Loader;\n\n    /**\n     * Called after a resource is loaded.\n     * @see PIXI.Loader.loaderMiddleware\n     * @param resource\n     * @param next\n     */\n    static use(resource: LoaderResource, next: (...args: unknown[]) => void): void\n    {\n        // because this is middleware, it execute in loader context. `this` = loader\n        const loader = (this as any) as Loader;\n        const imageResourceName = `${resource.name}_image`;\n\n        // skip if no data, its not json, it isn't spritesheet data, or the image resource already exists\n        if (!resource.data\n            || resource.type !== LoaderResource.TYPE.JSON\n            || !resource.data.frames\n            || loader.resources[imageResourceName]\n        )\n        {\n            next();\n\n            return;\n        }\n\n        // Check and add the multi atlas\n        // Heavily influenced and based on https://github.com/rocket-ua/pixi-tps-loader/blob/master/src/ResourceLoader.js\n        // eslint-disable-next-line camelcase\n        const multiPacks = resource.data?.meta?.related_multi_packs;\n\n        if (Array.isArray(multiPacks))\n        {\n            for (const item of multiPacks)\n            {\n                if (typeof item !== 'string')\n                {\n                    continue;\n                }\n\n                const itemName = item.replace('.json', '');\n                const itemUrl = url.resolve(resource.url.replace(loader.baseUrl, ''), item);\n\n                // Check if the file wasn't already added as multipacks are redundant\n                if (loader.resources[itemName]\n                    || Object.values(loader.resources).some((r) => url.format(url.parse(r.url)) === itemUrl))\n                {\n                    continue;\n                }\n\n                const options = {\n                    crossOrigin: resource.crossOrigin,\n                    loadType: LoaderResource.LOAD_TYPE.XHR,\n                    xhrType: LoaderResource.XHR_RESPONSE_TYPE.JSON,\n                    parentResource: resource,\n                    metadata: resource.metadata\n                };\n\n                loader.add(itemName, itemUrl, options);\n            }\n        }\n\n        const loadOptions = {\n            crossOrigin: resource.crossOrigin,\n            metadata: resource.metadata.imageMetadata,\n            parentResource: resource,\n        };\n\n        const resourcePath = SpritesheetLoader.getResourcePath(resource, loader.baseUrl);\n\n        // load the image for this sheet\n        loader.add(imageResourceName, resourcePath, loadOptions, function onImageLoad(res: LoaderResource)\n        {\n            if (res.error)\n            {\n                next(res.error);\n\n                return;\n            }\n\n            const spritesheet = new Spritesheet(\n                res.texture,\n                resource.data,\n                resource.url\n            );\n\n            spritesheet.parse().then(() =>\n            {\n                resource.spritesheet = spritesheet;\n                resource.textures = spritesheet.textures;\n                next();\n            });\n        });\n    }\n\n    /**\n     * Get the spritesheets root path\n     * @param resource - Resource to check path\n     * @param baseUrl - Base root url\n     */\n    static getResourcePath(resource: LoaderResource, baseUrl: string): string\n    {\n        // Prepend url path unless the resource image is a data url\n        if (resource.isDataUrl)\n        {\n            return resource.data.meta.image;\n        }\n\n        return url.resolve(resource.url.replace(baseUrl, ''), resource.data.meta.image);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}